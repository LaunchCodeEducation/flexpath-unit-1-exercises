Next, we're going to be diving into one of the most important aspects of JavaScript, functions. Now up to this point, we have written out our statements in JavaScript for everything we want to do, but what do we do if we want to perform the same logic in different places in our JavaScript file? Well, we could certainly copy and paste that code, but then every time we want to update it, we would have to go back and update it in multiple places. That seems like a mistake waiting to happen. Real JavaScript applications are built using functions, which allow us to group together code logic in reusable blocks, and within these blocks, we can define their input, which we call parameters, and their output, which we call the return value. So let's say that we want to validate any input that the user enters for a new employee. Let's start by looking at strings. If we were entering the department for an employee, we might want to only allow an entry from the list of departments we have at the company. We could add in a check to be sure that we received a string and that it is from that list. Now let's make this into a function. First, we need to give our function a name, just like we do when we create a variable. As I mentioned in an earlier clip, naming is really important here, and honestly, there's just a bit of an art to it. The JavaScript engine does not care what you call it, but your teammates, and honestly, your future self, will thank you for good naming. Our function will be returning a Boolean to indicate if the input value is valid, so I'm going to start the function with the word is. Something either is or it is not, so this fits well with the Boolean value that is either true or false. Next, I'm going to define what it is that we're checking, so I'll add in input. And next, I'll say what we're checking for, which would be ValidDepartment. There we go. So any developer can read that name and say, oh, you're checking to see if the input value is a valid department. Perfect. Let's get this into some code. So while we have three ways to create functions, I'm going to start with a function declaration. To use this, we start with the function keyword followed by the name that we just created. Next, we need to define the parameters of the function. Now if you remember, I mentioned that the parameters are the inputs of the function. Functions can have zero parameters or they can have a lot. In our case, we will have just one parameter, input. Notice that I am using the same language I used in the function name. Now after this, I can define the code block for my function using curly braces, just like we did when working with loops. The code that exists inside of this block will get executed every time that we call this function. So I'll go ahead and add in a logging statement in the function. We'll add in the real logic in just a minute. Now, when I want to execute the function, I can simply use its name followed by parentheses. Now, inside of the parentheses, I can put in the parameters that I want to use to execute my function. If I had multiple parameters, I would separate them with commas. So now we have created a function using a function declaration and we have executed it. That is a great first step. Next, we need to talk about something else. We need to talk about scope. Yes, this is a critical concept to understand when working in JavaScript. Up to this point, our variables and our scripts have been available anywhere after we've defined them. Now there are a few exceptions to that when we were dealing with loops, but I didn't really address it at that point. When you create a function in JavaScript, the variables that you create inside of that function, as well as the parameters, are a part of the function scope for that function. You cannot use those variables outside of that function. Now this is different from variables that we create outside of the function, which are a part of the global scope. Thankfully, this is pretty cut and dry, and not as complex as it used to be when we defined variables with the var keyword. This is why you should avoid using the var keyword in modern JavaScript. Now if we go back to our code, we can see this demonstrated there. If I created a variable, isValid, within that function and assigned it a value of true, I couldn't read it outside of our function. It is limited to the scope of the function itself. So how do we let the caller know if the input was valid? Well, in this case, we will use a return value with the return keyword. Functions in JavaScript only return a single value, although they can certainly return a collection or an object if you need to return more information. Also, your functions don't have to have a return value, which I demonstrated earlier by running our function when all it had was a log statement. Now I'm going to put in the real logic for checking the validity of our input. Here we will use an array to store the actual department names. You can see that I am defining this as a constant since the value of those departments won't change while our program is running. Now we can check to see if the input value is contained within that array or not. Now if it is, we would return true; if it's not, we would return false. In this case, since the includes method on the array returns a Boolean, we can simplify it like this. Remember, since we defined our array of departments inside of that function, we cannot use that variable outside of the function since it is contained within the function scope. There is a lot more to get to with functions. We need to get into some additional syntax for different ways of defining functions, as well as discussing some additional best practices for working with functions, just as we did for function names. We'll even explore a completely new way to iterate over collections using our newly discovered power of JavaScript functions.
So now, we're going to dive in and use our newfound power of function declarations to improve the application that we have been working on here within this course. Now, as a reminder, inside of the exercise files for this module, you'll be able to see both the before, meaning where we're at right now in the application, as well as the after state of the application, meaning, after we've integrated all of these new concepts at the end of this module. So, let's go ahead and jump right into VS Code. So here, I have the application pulled up that we were working on at the end of the last module. Now, what I'm going to do here because I don't yet have my node modules directory is I'm going to run npm install to install the dependency that we have. Now that that's in place, we can start working here within the application. Now, the first thing we're going to do is we're going to use function declarations to isolate some of the code. Currently, you'll see that all of the logic for our application exists within this switch statement, and at times, that can make it a little bit hard to read, so we're going to isolate each of the different actions, like list and add, into their own functions. So to start off with, just for organization sake, I'm going to go ahead and add in some comments. First, I'm going to add in a comment that's going to specify that all of our individual commands are going to happen here in the top portion of our application file. Then, what we're going to do is we're going to have another section which is where we actually have the logic that will run every single time that our application executes, and that's going to be where we parse out the command from the command line arguments and where our switch statement resides. So, now that I have that in place, I'll neaten up some line spacing here, I'm going to start off here by removing the code that exists under this list option. So here, I'm going to replace this with a call to a function that we will be creating, in this case we'll call this listEmployees. Then, I'm going to go through and do the same thing for add. Now again, this is a lot of code that exists here, so what we're going to do is we're going to take all of this, and again, we'll be moving this to earlier within the file. So I'm going to go ahead and delete this and then we'll add in the call to addEmployee. Okay, so now we've neatened up this information here within our switch statement. Here, we can clearly see that if we call list, we're going to call our listEmployees function. And if we call add, we're going to do our addEmployee function. So now, let's go ahead and create those functions. So here, we're going to go ahead and create our function for listEmployees. Now here, we don't need to add any parameters, and we won't have any parameters for these particular types of commands because here, we're just going to execute logic that the user will then interact with. So, we just define it with no parameters and you can see that because there are no values in between the parentheses. However, now that we get inside of the function, I'm now going to move all of the logic that was previously inside of that switch statement. Great! Now that we've defined this function, we need to add in our function for adding an employee. So here, we will add this one in, and I'm going to take all of the logic that was in the switch statement earlier as well and we're going to drop that into this function. So now here we have the logic for our addEmployee function. Now we're going to create another function, and this is not going to be a function that's going to be under our application commands. Here, we're going to create a function that will really bring all of the logic together around how we get information from the end user using the prompt, and how we validate that, and then what we do with that result because in some cases we'll need to do some custom logic for processing that or transforming that. So here, I'm going to create a new function here, we're going to call this getInput, and it's going to have three different parameters. The first is going to be prompt text, which is what we show to the end user. But then we'll have a validator function that will go through and validate to ensure that that input value is correct. And then after that, we're going to have a transformer function, which will potentially transform that value into something else. And so, over the course of this module, this will get implemented. Now one of the things I haven't talked about yet is default values for parameters. Let's say that we wanted to have a default value for prompt text so that when the user called the function, even if they didn't enter in a value, we would have something for that parameter. Well in this case, we could define that in this way. If we say equal, and then we pass in a default value, that will become the default. So that if the user calls the function without entering a value for that parameter, it would use this value. If we don't do this, the user can still call the function without entering a value for one or more of the parameters, but all of those parameters would be undefined. Now in this case, I'm not going to use a default value, but I wanted to be sure you knew how to use that if you wanted to have a default value for one of your parameters. Now, we have a lot more we'll be doing with the getInput function over this module, but for now, I'm simply going to have it get the value from the user through the prompt and then return that value. So now that we have this in place, we have taken the first step of integrating functions into our application. However, before we look at integrating our validator and transformer functions, we're going to have to learn about a new way to define functions with function expressions.
So now, we're going to talk about another concept called function expressions, and this is going to integrate nicely with our process of validating the input that the end users are giving. So, let's go ahead and jump right into VS Code. So here within VS Code, I'm exactly where I was at the end of the last clip. Now I want to go ahead and show you something. If we look under addEmployee, we can see that we're doing a lot of the same logic over and over again. So let's look, for example, at what we're doing to validate our strings. So here, when the user enters a firstName, for example, we're checking to be sure that it's returning a value, meaning that it's not an empty string, it's not undefined, it actually has a value to it. But we're doing the exact same thing for lastName. And then if we look at when we're entering in the numeric values for the year, for the month, and for the day, we're doing a lot of the same logic as well. We're checking to be sure we have a valid number and that it's an integer, and if not, then we want to exit from the application. Well, wouldn't it be great if there was a way we could bring a lot of this logic together. That's what we're going to be doing, but to do this, we're going to utilize a new way of defining functions, and that is a function expression. So here I'm going to go above my Application commands and I'm going to create a new section for functions. We're going to call these our validator functions. Now, if we think about the different types of input that we have coming into our application through the prompt, users could be entering in a string, they could be entering in a number, or they could be entering in a Boolean value, so let's think about what would be some common logic that we would use to define the validation that needs to happen for each. So to start off with, and I'm going to use here a function expression to do this, we're going to start by looking at string input. So here I'm going to create a new function expression. Now, you'll notice that one of the big differences here is I'm actually defining this like I'm defining a variable. And here, what I'm doing is I'm saying that isStringInputValid is going to be equal to a function. So by defining it in this way, I'm able to pass around this just like I would pass around a variable. So here, I'm still going to specify the function keyword, I'm still going to have parameters, and I'm still going to have my curly braces that define the code block that's going to execute. Now, here I've defined the logic for is our string input valid. We're going to say here that if we have an input, meaning that it's not an empty string, it's not undefined, it's not null, we're going to return true, otherwise, we're going to return false, and we get this by using the ternary operator that we learned in a previous module. So that takes care of strings, but what about Boolean values? Well, in this case, we could go through and enter in an isBooleanInputValid function as well. And here, we're just going to check to see is it either the word yes or the word no, and if it's either of those, then we can return true saying that this is valid; otherwise, we'll return false. Now we need to add in some validation for numbers. Now, I'm going to go ahead and let you in on a little secret. At the end of this module, I'm going to walk you through the process of creating one validation function that can handle pretty much any type of number validation that we need to do here in our application. For now, we're going to create three separate number validation functions, one for the year, one for the month, and one for the day, but just know that we will be simplifying this a little bit later. So let me go ahead and create the first one here, which is going to be focusing on the year. And so here we're going to go through and check, as we did before, that it is a valid integer value. And then, in addition, we know that our year should fall between a specific range, which again, is 1990 to 2023. So we're going to add in those checks here, and we'll return true if everything meets that criteria. Then we'll do the same thing for month. We know here that it needs to be an integer and it needs to be between the numbers 1 and 12. And then finally, we'll have ours for the day. Now, as I mentioned earlier, you can still see we have a good deal of reused code here between these three functions. That's why we'll be unifying them later, but again, don't worry about that part for just now. Now the next thing we need to do is we need to actually look at our getInput function. So here what we want to do is we want to integrate in these functions, our validator functions, and what's going to happen, and you'll see this in just a minute, when we call our getInput function, we will pass in the function that we want to use to validate our input, so I need to add in some logic to do that. But let's talk about a few scenarios that we want to handle. First is, if we don't pass in a validator function, we don't want to validate the input, but if we do pass in a validator function, we want that to analyze the value that's returning from the prompt. So to do this, I'm going to add in an if statement here and I'll say if validator and validator returns false. So what I'm doing here is I'm saying, if we have passed in a validator function, we want to call it, and we're going to see that here by treating validator as though it were a function that we've defined, but in this case, it's going to be the result of a function expression that we're passing in. And don't worry if that doesn't make complete sense just yet, you'll see it in action here in just a minute. But if that returns false, then we want to go through and say ‑‑Invalid input and we want to exit the application, very similar to what we were doing within our addEmployee function. Okay, now that we have all of this in place, what we're going to do now is we're going to completely change the logic inside of our addEmployee function. So what I'm going to go do is I'm going to go under our addEmployee function, and we're going to remove most of the logic that exists within this function. So I'm going to scroll all the way down, all the way until we get down to where we actually get the Boolean value, and we're going to delete all of this. So that leaves us just with our employee object and then outputting the Employee JSON. Now, what we're going to be able to do here is utilize our getInput function to ask the user for these values. So here I'm going to start off by getting firstName and lastName, and you'll notice here that we're entering in a prompt and then we're passing in the function as a parameter to our getInput function. In this case, it is our isStringInputValid. Now notice here, when I'm passing this in, I'm not putting the open and closing parentheses after. I'm not calling the function, I'm just simply passing the function as a parameter to our getInput function. Now this is how it would work for our string values, but let's look at our next values. So here, I'm going to go ahead and define our startDateYear, and we'll do the same thing. I'm going to go through and say our start year, pass in the prompt, and then we'll see isStartYearValid being passed in. The same thing here for month. We'll go through and enter in the prompt value, and then we're going to say isStartMonthValid. And, of course, you've probably figured this out. We'll do the same thing for the day, so we'll pass in the prompt with getInput, and then we're going to say isStartDayValid. Okay, so now that we have that in place, we can create our date based on those input values. Now, this part is exactly as it was before. This line of code actually hasn't changed from what we had previously. Now we have one more step here, and that is is that we need to define our employee.isActive value. So here we'll do the same thing, we'll call getInput. We're going to check it with our isBooleanInputValid. Perfect, so now that we have this in place, we should be able to run our application. So I'm going to go ahead and bring back up the terminal, and here within the terminal I'm going to call node index.js, and then add, and now we can interact with our application. So first I'm going to enter in a First Name, then I'm going to enter in a Last Name, and then I need to start off by entering in an Employee Start Year. In this case, if I try to enter in 1989, we should see that the application will exit because that is outside of the allowed values, and indeed, that's what happens. If I run it again and I enter in a correct value, and a correct month, and a correct day, then I can enter in Is the employee active (yes or no). Now, I'm purposely here going to say no. Now, we can see here that it does output all of the correct values, we do get a date output, however, you'll notice here that for isActive we're not getting a Boolean value yet, we're getting a string, and in this case, a string that just says no, so we're going to have to do some additional work in the next clip to make all of this work. And in the next clip, we're going to introduce another new concept, our third way to define functions, and that is with arrow functions.
So next, we're going to talk about arrow functions. Now these were introduced to JavaScript in ES6, so this is even newer than function declarations or function expressions. So according to the MDN Web Docs, an arrow a function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage. Now I'll go ahead and tell you I'm not going to cover the limitations in usage here within this course, but we will cover those thoroughly later within this learning path. So let's take a look at arrow functions. So here, I just want to remind you what a function expression looks like. So here we can have a function called isDavid, and if we're checking to see if the name equals David, we can denote this this way. This gives us our function expression that we covered in the last clip. Now if we want to use an arrow function, a multiline arrow function, and you'll see what I mean because not all arrow functions are multiline in just a minute, but here you can see that we're really changing out by not using the function keyword. And then in between our parentheses for our parameters and the opening curly brace, we have this arrow symbol, which is really just an equal sign followed by a greater‑than sign placed together, and then we can return a value just like we would in a normal function. But if you remember, one of the things about arrow functions was that they could be compact. That was a part of the description that was provided in the documentation. Well, here we have a single‑line arrow function with a parameter. So here, we can define this entire function entirely on one line without those curly braces. Now if we do this, that means that our function really has just one statement that's going to be executed. And if that statement returns a value, you don't have to use the return keyword here, it will return the result of that one statement. Let's take a look at some other examples here of arrow functions. We could also have a single‑line arrow function that has no parameters. Now if we do that, we absolutely have to use these open and closing parentheses, even if we don't have one. Now, I will say if you have a single parameter and you don't use the parentheses, that's okay, and we'll see some examples of that later within this clip. You can also have multiple parameters with an arrow function, just like you could with any other function, and you separate them with a comma, just like you would in other functions. So now that you have an overview of what arrow functions are let's take a look at how we would use them within our application. So let's jump over to VS Code. So here in VS Code, I have the application in exactly the state it was in at the end of the last clip. Now if you remember, we had a problem we were trying to solve, and that was we wanted to be able to solve a situation where we enter in yes or no and have that correspond to be true or false. Now we're going to solve this using arrow functions, but before we do, I want to show you that we could convert any of the validator functions we have, we could convert these into arrow functions. We would simply need to delete the function keyword, and then we could enter in the arrow, which, again, is really just an equal sign with a greater‑than sign right next to each other, and now we have an arrow function instead of a function expression. So I could save this and go through and run it, and everything would work just as it did before. Now, we're going to do something different here, we're going to add in a transformer function. So the way that this is going to work is we're going to create a section here for our transformer functions, just like we did for our validator functions. Now, as a kind of a quick side note here, we're actually going to delete this in a minute. We're not going to need this, but I'm going to take you on a journey to show you why. Now here, within here, let's think about what we want our logic to do. We're basically saying if the user enters in yes, we want it to translate to true, and if the user enters a no, we want that to translate to false. So we could easily create a function in here utilizing an arrow function that would give us the logic we need to transform the Boolean value. Here we have a single parameter of input, and then we're going to return the result of this conditional. Now the conditional here is input strictly equals yes. So if the user has yes included, then that would return true. And if they type in no, then it's going to return false. Now you might say, well, what if they put in something else? Well, we've already handled that with our validator function, so we don't have to worry about that in this situation. If it actually is a value that's not yes or no, it wouldn't ever reach this point. But to make that work, we need to go up here and add in our logic for how we're going to handle our transformer function. So here, we're going to say if(transformer), then we want to return the result of our transformer function. Great. So now that we have this in place, I should be able to go down into our logic where we're getting the Boolean value, and I'm going to include a third parameter, and that's going to be our transform Boolean value function. Okay, now all of this should work to give us the correct value for true or false. So I'm going to go ahead and run the application, and here we'll enter in a first name and a last name, and we'll go ahead and do the start year, and here's where we enter yes or no. Now in this case, I'm going to enter yes, and we should see here that are isActive value is set to true. I also could go through and do the same thing and enter in no, and we would see that it returns false. So our arrow function is working exactly as intended. However, I'm going to tell you that everything we've done with this so far is, in some ways, too much. We can actually write this with a lot less code. So what I'm going to do, I want you to remember what we included here for our transformer function, but I'm going to delete it. And what I'm going to do is I'm going to go down here where we're entering in the transform, and I'm going to delete this, and I'm going to replace this with an arrow function. And here what we're going to do is we're just going to say that we have a single parameter, which is going to be i. Now if you remember, I said you don't have to include the parentheses if you only have a single parameter, and that's the situation here. And if we have a single statement as a part of your function like we do, which is we're returning the value of the conditional i strictly equals yes, then we don't have to use the return keyword, it will return the result of that. So if everything works as expected with this single line, this in‑line arrow function, I should be able to get the same result as the code that I had before. So here I'm going to open back up the terminal, and here we'll go ahead and run the application again. I'm going to go ahead and enter in my name. We'll enter in the values for the Year, the Month, and the Day. And now, I should be able to type in yes and still have it return true. And indeed, it does work that way. Now when we get into other areas of JavaScript, you'll see that arrow functions can be quite powerful, and we're going to be using that in the next clip to provide a new and different way to actually work with collections to go through and loop through them, to go through and search in them, to filter in them, and we'll do that by pairing those capabilities with arrow functions.
So next, we're going to use the power of arrow functions to work with collections in new and different ways than what we've done so far. So, let's just jump right into the code. So here within VS Code, the first thing I want to do is I want to create a function that will log out a single employee. Now this is one of the great uses of functions. If there's something you need to do multiple places within your file, you can isolate that logic in to a single function. So here, I'm going to call this function, logEmployee. Now, we're going to have a few new things here, but again, all stuff that you can pick up, so I'm going to talk you through what I'm doing here within this function. Now, the first thing I want you to notice is we're actually creating an arrow function here that's going to actually do the logging. Here, it's going to take a single parameter of entry. So, how are we going to get the values for a single employee? Well here, there is a function called entries on the global object called object, and you can pass in an object, and then what it's going to do, it's going to enable you to basically loop over each of the properties within an object. Now, you could do this just like you were doing a for in loop, it's basically the same thing, but here, instead, we're using what we would call the functional approach, we're using an arrow function to do it. So once we get back an array of entries for an object, we can then call the forEach method on that array. Within that forEach method, it will execute the arrow function that you pass in once per item in the array. Okay, so now that we have that in place, we're going to take a different approach to how we're listing out our employees in our application. So here, I'm actually going to completely delete our two for loops. Now, I'm going to tell you, in many ways, this is a matter of preference, you can keep using the four loops, they work just fine. But in many cases, you'll see developers using the approach I'm going to show you here, which we would call the functional approach. So I'm going to go ahead and delete these for loops, and now, we're going to include some additional logic. Here, I'm going to use that forEach function again on the array of employees, and then we'll go through and for each of the items in that array, we'll log out that employee. So, let's see if this works. So here, I'm going to go ahead and pull my terminal back up, and, I'm just going to go ahead and call node index.js, and we'll say list. And here, we can see it lists out our employees just as it did before. Great. So we really haven't changed anything, but we have optimized the code within our application. But now, we're going to add in some new functionality. So we're going to actually add in new commands. So the first new command that I want to add in is going to be a command called searchById, and here's what I'm thinking. We're going to go through and try to find a given employee based on their ID. If we look back at the data, you remember that each employee has an ID, which is a numeric value, all the way from 0, up to our very last one, which is 8. So here, we want to be able to search by that ID. So to make this work, we're going to need to go up under our application command section, and we're going to need to create a function that will house this logic. So here inside of this function, we need to do a few things in particular, but first of all, I want to let you know that we're going to be relying on the capability of the array object called find. So here in the documentation, you can see that find enables you to find a specific value out of an array. You can pass in an arrow function, and if that arrow function returns true, then it will return that specific value from inside of the array. So let me show you how we're going to use it. So here within VS Code, what we're going to do is we're first going to go through and get a value from the user. So here, I'm going to say that we're going to get an ID, we're going to say getInput, we're going to have a prompt of Employee ID. Now, we don't want to validate it in this case, so I'm going to include null for the validator, and for the transformer, I'm just going to include number because that will convert the value that is passed in to be a number value. Otherwise, it would be a string. So now that we have that in place, what I want to do next is I want to go through and try to find the employee based on that ID that the user enters. Now I can do that here by utilizing the find capability of the array that I just mentioned to you. So here, we'll pass in an arrow function that is going to check and see if the ID of that specific user matches the ID that our user just entered. Now if so, it will return that value and we'll have a value for result. However, we're not guaranteed a result, are we? If I enter in an ID of 1000, well we don't have that many employees, so we need to account for a scenario where we might not have a result at all. So here, I'm going to create a conditional and we'll say if result is defined, we'll create a console.log statement to add in a bit of a space, and then we'll log the employee. If not, we're going to return a message telling the user that hey, we're sorry, but you don't have any results. Perfect. So now, we've integrated a new capability to our application. So here, I'll save it. So here, it's asking us for an ID, we'll first target a user that does exist, so we'll enter in the number three, and we can see that it does log out that specific employee. Now, next, I'm going to go through and run it again, but I'm going to include an ID that I know we don't have, which is 1000, and here, we can see that it does return no results. Great, so here we've been able to utilize arrow functions to completely change the way that we're listing our employees with our list capability, and we've added in a new capability to search for users by ID.
So now, we're going to build on the concepts that we've learned so far with functions, and we're going to do something else. So instead of going through and looping over an array or even going in and trying to find a single value out of an array, we are going to filter the values from an array, and we're going to use this to add in an additional search capability in our application. So here in the documentation, we're going to use the filter method of array. So what this does is this allows you to provide a function, and if this function returns true for a given item in the array, it will include it in the results. And so we're going to implement this to search for users by first and last name within our application. So, let's jump over to VS Code. So I'm here in VS Code, and here, the application is in exactly the same state as it was at the end of the previous clip, and now, we're going to add in that search capability for searching for a user by name. So I'm going to go down to my switch statement, and we're going to add in another case. So here, I'll go ahead and enter in search‑by‑name, and we'll have a function called searchByName that we'll use for the logic for this search. So now that I have that in place, I'm going to go ahead and move up directly below where we're searching by ID, and here, we'll go ahead and create our function shell that will enable us to search by name. So, now that we have this in place, we need to talk about how we're actually going to do this. What we want to enable users to do is to enter in a partial first and a partial last name, and if the user enters in a first name, for example, let's say they enter in the letter D, well, anyone who has a first name that includes the letter D should be included in the results, but if we don't include anything for first name, then we should just return all of the values. So, let's go ahead and implement this. First, we're going to go ahead and prompt the user to enter in the first name that they're searching for. Again, this can be a partial value. Now notice here we're not using any type of validator or transformer in this case with the getInput function. We're not validating it because if the user doesn't want to enter a value, we want to accept an empty string here in this case. And notice that for both of these, we're converting whatever the user inputs into the lowercase version of it. This way, we can compare lowercase versus lowercase, that way, it's not going to be case‑specific. Okay, that's kind of the easy part, we've covered a lot of those concepts before, let's go through now and look at how we're going to actually filter this array. I'm going to go ahead and create a variable to hold our results. Then, we're going to create an arrow function. Now when you pass an arrow function into the filter function, what this does is it's going to pass each individual value from the array to this filter function. And, if the function returns true, then it will include that item in the results. If it returns false, it will not include that item in the results. So here, let's figure out how we're going to evaluate each of the names that the user has the option to pass in. So here, we're first going to check for the first name. Now, if the user actually does include a string to search by, then we're going to want to go through and see if that is included in the name of the current item in the array. Now, specifically what we're doing here is we're checking first to see if they pass that value in, and then we're checking to see if it doesn't include the value that the user has passed in. So think about that, let's pretend for the moment that we pass in the letters D‑A‑V‑I‑D. Well if there's no one in our directory that has the letters D‑A‑V‑I‑D in their first, we should return false, and that will make sure that that item is not included in the end results. But, if we get this far, that means we also need to evaluate the last name, and here, this is going to be identical, just with the last name instead of the first name. And notice that with both of these, we're also converting this to lowercase before we check for the value. Now if we get to this point, that means that we should return it to the results because that means it has passed the test for both our first name and the last name. It could be that the user didn't enter in a search value for first or last name, and if that's the case, it will just return all of it. Okay, so now we've been able to filter that array. We should get back a list of results that match the criteria that we've specified. Now what we need to do is we need to loop over each of those results and we need to display them for the end user. Now, we're going to use the forEach function as we've done before. We're going to take that results array and we'll create an arrow function that will loop over those values. Now, as a note, we actually have multiple parameters here. You've seen me use forEach before and I only used a single parameter. However, you can get access to the index, as well as the specific item in the array, and that's what we're doing here, and you can see how to create an arrow function that has multiple parameters. Okay, we've done a lot of work to put this search into place, let's go ahead and test it out. So I'm going to bring up the terminal, and here, I'm going to be using the search‑by‑name command, and we can see that it's asking us here for the first name, I'm just going to enter in the letter D, and then for the last name, I'm not going to enter in anything. So, what we should see is that we should get results back that have the letter D in the first name. And here we can see that we do have two search results that were returned, and both of these do indeed have a letter D in the first name. So here, we've been able to use arrow functions to help filter out an array to values that we've specified.
Now we have two remaining concepts to cover with functions in JavaScript and the first of these is recursion. Now, when we're talking about programming, recursion is when you call a function within itself. Now in doing this, an infinite loop can occur, so this must be done in a way where a function will not call itself continually. Now you might not immediately think of a use case where you would need to call a function within itself, but we're going to integrate one of these examples within our application. So, let's jump over to VS Code. So here within our application I want to take a look at our getInput function. So, let's talk about what happens inside of the getInput function. We go through and check to see if there is a validator in place, and if there is a validator and the input comes back as being invalid, we simply exit the application. But what if we wanted to do something else? What if we just wanted to ask them again and give them a chance to go through and actually enter in a correct value? Well, instead of exiting out of the application, we could choose to do something else. So, what we're going to do is we're going to call again the getInput command. So here, we're going to return the value that we get from calling getInput again and we'll pass in all of the same values. We'll pass in our promptText, we'll pass in our validator, and we'll pass in our transformer. And so if again, the second time, the user enters the correct value, it will proceed just as though they had done it the first time. But if they don't, it will keep asking them again and again until they enter in a value that is valid. So, now that we've integrated this into the application, let's test it out. So here I'm going to go ahead and start the application, and here we'll use the add command. So I'll go through and enter in the first name, then I'll enter in the last name. Now I'm purposely adding in these to be valid, but let's say I enter in 1989, which would not be valid in this case. You can see that it says Invalid input, but then it goes through and asks me again. Let's say I enter in 2024, also not a valid option. It'll tell me again that it's invalid, but it will let me keep going. Then, I could enter in 1991, which would be a correct value, and now I can progress through all the options and then finally specify that this employee is active. And here we can see that I do get the correct value actually returned. So, this is one example, an albeit a simplistic example, for how we can leverage recursion to help implement the goals we have within our application.
Now we have one final stop on our journey to learning about functions in JavaScript, and that is higher‑order functions. Now, within JavaScript, a higher‑order function takes one or more parameters and then returns another function as its return value. Now, you might be thinking, I can't think of why I would ever need to use that, but, we actually have a use case within our application that is a perfect fit for this type of function. So, let's jump over to VS Code. So here within our application, I'm going to scroll down to our validator functions, and if you remember, earlier on in this module, I said that we had a lot of code that was reused between these three different validator functions, and that ideally we would have a way to bring them all together, and I said towards the end of the module I would be doing that. Well this is the time. So, I'm going to actually just delete all three of the validator functions that we have and now we're going to start the process of integrating something new. So here, I'm going to create a new function, and this function will be called isIntegerValid. So ideally, this will give us the ability to really get any integer that we need from our end users, and we'll pass in a min and max value when we create this. But that won't work for our validator function because we expect that our validator function is only going to have one argument, and it's going to be the input value. So, how do we do this? Well, the answer is that we actually return another function within this function. So here, we'll go through and return another arrow function that does indeed take that input value. Now what we can do is that inside of this, we can now include all of the logic that we've been using to verify that something is a number, and also to verify that it fits within the min and max values that we have defined. So now, we can take this input function and we can actually use this as a validator. Now if this doesn't make a ton of sense yet, let me show you how we'll use this. So I'm going to scroll down to where we add our employees, and I'm going to replace what we're using here currently. So instead of isStartYearValid, here, we're going to call isIntegerValid, and then we'll pass in our min and max values. You might say, well, we're calling this function here, and we didn't call the other one before. But remember what our return value is for this function, it's another function. We're basically creating our custom validation function at runtime. So now, I'm going to do the same thing with checking for the month, and we'll go through here and we'll enter in the min value as 1 and the max value as 12. And, we'll do the same thing here for isStartDayValid by going through and actually passing in the min as 1 and the max as 31. So, if all of this works, we should see our application perform just as it did before, but with one custom validator function instead of three. So, let's test it out. So here, I'm going to go ahead and call add within my application, I'll pass in a first name and a last name, and here, we should see it be able to validate between the years 1990 and 2023. So if I enter in 1989, it's going to tell me invalid input, and then it will let me enter one again. I'll go ahead and enter 1990 again, and it does get the correct value. I'll do the same thing here for both the month and the day, and then I'll specify that the employee is active. And, we can see that everything succeeded just as it should. So here, we have leveraged a higher‑order function to return a custom validator function for each of our different use cases, where we can specify a min and max value.