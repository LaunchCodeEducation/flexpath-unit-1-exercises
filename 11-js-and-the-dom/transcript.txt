Course Overview
Hi everyone. My name is Christian Wenz, and welcome to my course, JavaScript in the Browser. I'm an independent web developer and software architect, and support many companies and enterprises in anything web. JavaScript can be used almost everywhere, but most of the time it runs in the browser, so let's see how that works. In this course, we are going to discover several ways how to use JavaScript in a browser context. Some of the major topics that we'll cover include using the document object model, or DOM, to access all elements on the current page, implementing event handling, working with special events such as those triggered by a mouse or a keyboard, and accessing and validating HTML forms with JavaScript. By the end of this course, you will know how to use JavaScript within the browser to create dynamic web applications. Before beginning the course, you should be familiar with the basics of HTML and the fundamentals of the JavaScript language. I hope you'll join me on this journey to learn how to use JavaScript for web applications with the JavaScript in the Browser course at Pluralsight.

Document Object Model Fundamentals
Course Overview
Hi, and welcome to JavaScript in the Browser. I'm Christian Wenz, and will guide you through this course, starting with Document Object Model fundamentals. The Document Object Model, or DOM, is the main focus of this course, and we will learn how to work with that API, which essentially allows us to access any element on the current HTML page from JavaScript code. Another important aspect of the DOM is event handling, so we can write code that reacts to events, events that are part of the lifecycle of an HTML page, but also events that are triggered by the user, for instance, mouse events or keyboard events. And finally, we will learn everything about accessing HTML forms from JavaScript code, allowing us to leverage features such as form validation. Among other things, we can prevent the submission of a form if some information is missing. All that comes up in this course here at Pluralsight.

Version Check
This course has been created using the latest ECMAScript version supported by browsers at the time of recording. The code I demonstrate will be supported by all major browsers. This slide shows the versions of ECMAScript for which the information in this course applies.

Demo Application
This course will feature the Globoticket website. That's a fake brand which will serve our needs just fine. Globoticket is a platform to purchase and also to sell tickets for events. You see some inventory here for upcoming concerts, and there are also hints at a shopping cart functionality, but nothing works at the moment. We will add some features and we will use JavaScript to enrich the experience when working with that site. Be aware, though, that we are working in the browser only, so there is no server functionality we could use, so our options are in a way limited. Still, we will be able to provide additional value to that site with JavaScript.

Document Object Model (DOM) Explained
As I have briefly mentioned at the beginning of this course, the Document Object Model is an API. However, the name Document Object Model is still quite accurate because, yes, there is a model. Let me try to visualize that. Here on the left, you see some HTML markup. This HTML markup shows some HTML page, and you see that's kind of okay, but, for instance, there are no closing tags for head and for the paragraph. Still, that works. Why does it work? Because the browser loads that, parses it, and then makes it right. Among other things, the browser creates a tree‑like structure, sometimes also called the DOM, and it looks similar to this. There is a root element, here it's html, and that element has children, and you see that basically each html tag on the left is now a node in that tree structure on the right, including some of the text here. And that's basically what the browser does. That's the model the browser creates in memory, so to speak, and the DOM API now allows us to use JavaScript to access each of those nodes and then to work with them, read them, write them, delete them, change them, and also to add new nodes to that structure, and that's what you will see throughout this course.

DOM Version History
Let's have a quick look at the different versions of the Document Object Model, the DOM, so that you get some historical context and also understand why nowadays there's only one version left, but we'll talk about that in a minute. First, let's go back to 1998 when the World Wide Web Consortium, the W3C, released DOM Level 1. This version of the standard, so level basically means version, contains more or less that tree‑like structure approach that you've just seen. In 1998 JavaScript was 3 years old, and of course those browsers that supported JavaScript already had that DOM model, but there wasn't a standard, and the World Wide Web Consortium considered a standard as being paramount for having an option to implement a JavaScript‑based application that runs everywhere. DOM Level 2, or version 2, followed two years later in 2000, and it added various APIs, methods, properties, etc, to access DOM elements. This was a really important version of the DOM, but it took some browsers, well, one browser, Internet Explorer, over 10 years to fully implement that standard. So, yes, back in the days, the standard didn't mean that all the relevant products supported it or would support it in the near future, sometimes it was the rather distant future. The situation is much, much better now, so most of the existing DOM features are supported uniformly across all modern browsers. Back to DOM versions, DOM Level 3, or version 3, was then published in 2004, and after that, the group behind the DOM disbanded. Instead, the WHATWG, Web Hypertext Application Technology Working Group, a community where most of the browser vendors or browser developers were part of, they now took over the DOM and started curating the DOM standard document as a living standard, similar to how HTML is now a living standard as well. So there are no version numbers, but if something gets changed or gets added, the standard gets updated, and most of the time browsers then very quickly implement those new features. The main DOM features, accessing elements, changing them, event handling, etc, that has been stable for many, many years now, and that works in all modern browsers, so using the DOM is certainly something where you have cross‑browser support and you have had that for many years now.

Demo: Accessing the DOM
We will cover the Document Object Model in depth starting with the following module, but I would like to use the opportunity to at least quickly show you how you can access and change a DOM element with JavaScript in no time. Let's first start by looking at the html markup of the Globoticket page so far. First, we have a navbar, and within that navbar, we have the shopping cart, which, as I mentioned, isn't functional yet. And then we basically have a long table with all of the events that Globoticket has in stock. And at the bottom of the page, we have a footer, and the footer currently says copyright Globoticket, but what I'd like to have is that it shows the corporate year as well. But I'm lazy, I don't want to update the year each and every time there's a new year, so I'd like to use JavaScript to take the current year and just put it in that footer. Yes, I could do that on the server side, but I'm using JavaScript here, so let's use that option. In order to achieve this, I need a DOM element since we would like to access DOM elements, and I'm using a span here, which basically serves as a placeholder. Now, I give this span element an id. How about copyright‑year. That ID will become important in a second because that allows us to easily access that placeholder. Next up, I'd like to add some JavaScript code, so I'm adding a script tag, and that's important. For now, we are always putting the script tag with the DOM access JavaScript code at the very bottom of the page just before the closing body tag. Why? Because then we can be sure that those DOM elements we would like to access have already been part of the page and haven't parsed so they are accessible to us. The code would not work at the beginning of the page where the DOM element I would like to access hasn't been created yet. Later in this course, we will find another, and possibly better option, though. And now I'd like to access that placeholder. There are several options, but probably the easiest one is a method called document.getElementById. That's a method that was officially standardized as part of DOM Level 2, and it gets an element, a DOM element, of course, by its ID, so I just have to provide the value of the id attribute of the element as an argument here. This call then gives me the DOM element so I can do basically everything with it. And the most famous, so to speak, property of a DOM element, or of most DOM elements, is the innerHTML property, which contains the HTML that's within that element. So for the span element, that's an empty string because there's nothing within the span. We can read it, but we can also write it, so I'd like to write something into my placeholder, the current year. So in JavaScript, we just get a new Date instance or a new Date object, which defaults to the current date, and then we can do something like get and then FullYear. And this is now written directly into that placeholder courtesy of JavaScript. Let's reload the page, take a look at the footer, and JavaScript has now added the current year, so while I'm recording this that's 2023, and shows it in the footer. And that was our first DOM element access, and we've not only accessed the DOM element, but we've also changed its content. We have now laid the foundation for understanding the DOM, so we are ready to actually work with the DOM, and that's up next.

Working with the DOM
Terminology
Hi, and welcome to Working with the DOM. So, yes, now we will interact with the Document Object Model, but before we do, we should clarify some terminology. Remember, the DOM structure you've already seen in the previous module can look like this for a typical HTML document. In HTML, we have the html tag or the html element, and then there's head, and there is body, and there is a relation to that. So head is kind of a sub element of html, as is body, and then another element, another relationship. Everything is connected in HTML, or if it's not connected in HTML, it will be connected once the browser parses the HTML and then sets up this, as I call it, DOM tree. And we see a few specific things here. We see html elements, we see text content, and we also see attributes. But that's HTML. When talking about the DOM, there are specific terms, and I'd like to discuss those terms with you now. The centerpiece, so to speak, of working with the DOM is a node. So basically a node represents one thing, quote unquote, in that object tree, in that tree structure. So, for instance, if we have, say, a p element, a p tag in the html, then there will be a p node in that tree structure. And then there are two more terms, and it's important that we know the difference. In HTML, we have attributes, so for instance the style attribute of most HTML elements can be used to provide CSS. But there are other attributes as well, such as id, for instance. So these are attributes in HTML, and there will be an API to read and also to set those attributes. But if we have a DOM node, they are small, we also have DOM properties. Imagine that we have an API so we can program with DOM nodes and, of course, we can access those html attributes of those nodes or of those corresponding html elements. However, there are also properties, so that would then be JavaScript properties since we're using JavaScript to interact with the DOM, and those properties are not necessarily attributes. For instance, you've previously seen the innerHTML property. There is no innerHTML attribute in HTML, but there is a property. So we can work with properties and have more options there than just with attributes alone. And now we are ready to dive into the DOM.

Accessing DOM Elements
The DOM API is huge, so we cannot cover everything, but I'll make sure that we talk about those things that you're most likely to use in your JavaScript‑based applications. Let's start with looking at several ways to access a DOM element. So here's our tree structure again. We have html, we have head, we have body, and in the body part of the HTML document we now have two paragraphs that will become important in a minute. You have already encountered the getElementById method. We've used that in the previous module. So if we have an element with an ID, we can access it via that ID. And as the name ID already suggests, there can only be one element like that. There are other methods, however, that return more than one element, well, can return more than one element, or to be precise, more than one node. And one of those is getElementsByTagName. Notice the plural in the method name, so we get elements. Here, I just say give me all the elements that have the HTML tag "p". So in our example there are two of those, and that's why getElementsByTagName("p") will return a list of nodes, an array, and that list will contain two elements here. Another option is to call getElementsByClassName. So very often we are using CSS classes to kind of mark elements so that we can assign uniform styles to uniform elements. But in that case, we can also use that assigned CSS class to get all of the elements that have one CSS class. And if an element has several CSS classes, the one that we provide in the getElementsByClassName call, that needs to be present, and it's not relevant whether there are any other classes or not, so that would work as well. And since we've already touched CSS, there's more, and nowadays that's probably the most commonly used way to access DOM elements from JavaScript, apart from maybe getElementById, and that's querySelector. So querySelector basically says here is a CSS selector. On the slide, we have a very simple one, just "p", which basically means element 'p', but we could have any supported CSS selector supported by the browser, so whatever the browser supports can be used with querySelector, so all of, say, CSS3 is possible. QuerySelector returns one element, and that's the first one that matches. So in our example, querySelector("p") returns the first 'p' node in our tree structure even though there is another paragraph as well. So if you're sure or certain that the CSS selector you're using only returns one node, you're good to go, or if you specifically want the first node, make sure that your CSS selectors are that way, otherwise, there might be surprises. If, however, you are expecting that you have more than one node that will match your selector, you can use querySelectorAll. QuerySelectorAll works basically like querySelector, so a CSS selector is expected as an argument, however, as the name suggests, querySelectorAll, all of the matching nodes will be returned, so in our example, both the 'p' nodes will be the value that we get when calling querySelectorAll("p"). And these are the most important methods to actually access a DOM element. If you recall the demo from the previous module where we introduced getElementById, we could now change that and use querySelector as a replacement. We just have to find a matching CSS selector for that element. So we could use something like footer, and then div, and then span, and the span has an ID of copyright‑year, but since we have an ID anyway here in that case, and that ID has to be unique, we basically can just use the ID, and that's it. Now document.querySelector("#copyright‑year") returns the node with the ID copyright‑year, so our span placeholder, and then, once again, we write the current year into that element.

Navigating the DOM
We now know how to access any node in our DOM tree, in our DOM structure. CSS is so powerful, and that's why with querySelector or the other DOM methods, we can basically go anywhere and then change that node. But what if we have a structure? So here is, once again, an example. What if you would like to move around? What if you would like to walk the tree? And that's called DOM navigation. We navigate the tree. And, once again, I'll show you the most important APIs here. Let's start with the html node, and you see it has two sub‑nodes, head and body, and sub‑node actually is not the correct term, they are child nodes. So we have a parent/children relationship. And everything is in order here from left to right, from top to bottom. So head is the first child of the html node, and appropriately, the property is called firstChild. And you may have already guessed it, if you add the html node and would like to access the body node, we could use lastChild, because body is the last child of the html node. And if a node only has one child node, then firstChild and lastChild point at the same thing. Let's have a look at the children now. So head and body have the same parent node, the same parent element, therefore, they are siblings. If we start at head and would like to access the body element, we can use the nextSibling property. Also, if we are at the body node and would like to access the head node, we could use previousSibling. So when we enter the DOM tree, we can go downwards so we can access children, and grandchildren, etc, and we can also move to the left and to the right on the same level between siblings. But there's a bit more. We've seen firstChild and lastChild, but what do we do if a node has more than two children? Well, all of the children can be accessed with the childNodes property that's always either empty or a list. Even if it's only one child, it will be a list then. So child notes gives us that. So, once again, we can go downwards within the tree, but we can also go upwards. Each node has a parent node, except for the root node, which is html here, so both head and body can use the parentNode property to access the html node. So not only can we access any element in the tree, but once we are in the tree, we can walk around and therefore once again access anything there, especially if you know the HTML structure of your markup really well. That can be really useful to then be able to access select elements or to search things in a pre‑defined structure. We could use that DOM navigation in our demo code as well. So, for instance, we could use a selector such as footer div, then we have access to the div element, but what's next? What then? In the browser console, or in the developer tools to be exact, we see that the div element has three children, a text node, just text; then the span element, where we want to set the copyright‑year; and then another text node, so three children. That's the data we needed, so if I access childNodes, I get a list of three nodes with indexes 0 through 2, and we need the middle one. So this would access the div element, and then once again we would write the year into it. And, of course, we should add some error handling and make sure that we do have enough child nodes. We could also make the CSS selector a bit more precise, but this shows you that walking in the tree is also an option to access certain elements.

Updating DOM Elements
We know how to access an element in the DOM tree, we can walk around the DOM tree, so let's now discuss how we can access specific content of elements in the tree and change them, because that's kind of a missing ingredient. So, of course, we start by accessing some DOM element. It doesn't matter how we do it, getElementById, querySelector, anything goes. And then, if we would like to write something into that DOM element, so far the only thing we've seen is the innerHTML property which sets the HTML content, so we can write both plain text and markup into that. That's not the fastest option, especially in an example like ours, where we just write plain text. InnerHTML expects HTML, so it parses what it gets. And we have to be careful whether that string we assign does not contain, say, JavaScript content, unless of course we specifically want it, but if we know it's just text, there are other options as well. InnerText is like innerHTML, but it just expects text, so if there are special characters like angle brackets, they are used as text, they are not used as markup elements. So that sets the text content. There's another option, and that's called, aptly, textContent. And essentially it's the same thing, so there are some very, very subtle differences between those two, but also the textContent property can be used to set the text within an element. So if el here is, say, the span element for the copyright‑year, then we can set the text content with the textContent and the innerText properties. There's one more, that's a property called nodeValue, but that's not a property of an element like span, it's a property of a text node. If an element contains text, it has a child element, and that child element is a text node and we can set the value of that text node, and that's why we have to use something like firstChild to get the text node, .nodeValue here. Let's quickly go back to the DOM structure. So you see the blue nodes, DOM, Pluralsight, these are text nodes, for instance, the title. The title tag of html, we set the title as a string, we're just putting text between the opening and the closing title tag, so the title node has a child node that's a text node with a nodeValue of DOM. Same for the text of the link on the right. So far, about essentially changing text and markup, but what about HTML attributes? Indeed, we can change them as well. There is the setAttribute method. The setAttribute method expects the name of an attribute, so, for instance, style, or id, or anything else, and a value, and this then sets the HTML attribute. We could also read out an existing attribute by using the getAttribute method. And these are the major methods to change specific text, and to some extent markup and attributes in the DOM. Back in our application, instead of setting the copyright‑year via innerHTML, we could use innerText or textContent. So that would work really well here, and would also be a bit more efficient than using innerHTML. What will not work is this approach. So childNodes[1] gives us the span element with the copyright‑year, so we cannot do firstChild and then nodeValue. Why? Because that span element does not have a firstChild yet. There is no text in it yet. If there was a placeholder, like xxxx, then we would have a first Child, then we could set the nodeValue, but at the moment we don't have it yet. So we could either create a new text node, we will see that shortly, or we just revert and use textContent.

DOM and CSS
Apart from changing the text content of an element, we could also change the layout by changing the CSS, and there are different options, and I'd like to show you which they are and what to use when, what the differences are. The first thing that probably comes to mind is setting the style attribute, because we've already encountered the setAttribute method. So if you have an element, we call setAttribute, and then set style to, say, color: orange, this would apply this inline style to that element, because it sets or adds the style attribute, and therefore, the text in that element would be in orange. Now, previously we have discussed the differences between attributes and properties when it comes to DOM, and we can return to that topic now, because each DOM element or DOM node has a style property, and this gives us an API to access specific styles. So, for instance, we can access style.color and then set the color style property, so to speak. There are some subtle differences between setAttribute and using the style property, especially when we have styles with special characters like dashes, for instance, background‑color. Of course, there cannot be a property with a dash in it, so it will be background color with a capital C, but this also allows us to directly set styles. But, of course, inline styles is not always a good way to make code maintainable. Using CSS classes could be a better option and we could set the CSS classes, as well the setAttribute, so we could set the class property or the class attribute, but it's getting a little bit better with the classList property, because the classList property exposes an API to manage the list of classes assigned to that very element. Among other things, we have the add method to assign a class to an element, and we add it so if there are other classes already applied to that element, they remain intact. Add just adds one extra class to the list of classes. You can also remove a class with the remove method; you have toggle to switch a class on and off, so to speak; and you can also replace the existing classes with a new class, and that's a little bit better than just going via the attribute, because then you have to parse the list of classes yourself, the classes property does it for you. Let's try updating the CSS on the fly in our demo application. I once again start with document.querySelector, footer, and div, and notice that that div element has a couple of CSS classes. I've set them up in this application, and one of them is font‑xxlarge. However, I think the font is maybe a little bit too large, so how about we access the classList and then remove font‑xxlarge. That works well, however, in the next step, I would also like to add another class, I've prepared one, font‑large, so that the font is a little bit large, but not extra, extra large. Remove, however, returns void, so it's not chainable, therefore, I can't change several things at once removing and adding, therefore, I need to do copy/paste, call add, and then use font‑large here. I remove one class and add another. Of course, I could do this in the markup as well, but if I want it to happen on the fly, maybe I have an increase or decrease font size functionality on the page, that would be one way to do it. Here's our application. Note the font size of the copyright line, and then I reload because we've saved our changes, and font size now is smaller, courtesy of JavaScript code.

Deleting DOM Elements
So far, we have only changed content. Now, let's get rid of some content, let's remove DOM elements, and that's super, super easy. However, when you look at existing code bases, more often than not, you will see an approach that was the only option many, many years ago, and some developers are still so used to it that they can't get rid of it, and that's how it looks. First of all, once again, you get a DOM node document, get document ID, document.querySelector, however you do it, and then, since each DOM node has a parent, except for the root node, and we have this kind of linked list, the parent node needs to be informed that one of the child nodes is gone, or is to go. And therefore, in order to remove a node, you have to access the parent node and then tell the parent node, okay, please, I'd like to remove one of your child nodes, that's the one here, so you had a call that looked like this. Of course, it's not super intuitive. If you think about the DOM structure and the dependencies there, it's, I wouldn't say it makes a lot of sense, but it's understandable. But, of course, after a while, and thanks to popular JavaScript libraries like JQuery, the browser teams decided, okay, it's time for a more approachable API, and therefore, what they did is they added a couple of helper methods, and for removing DOM elements, it's just called remove. So each node has a remove method, and that remove method gets rid of the DOM node, removes the DOM node from the DOM tree, the browser renders, and the node is gone. In our demo application, let's go to the shopping cart. Yes, I know it's not really functional without a server backend, but I can show you how to remove nodes here on that page. So the shopping cart has a couple of items, and also nonfunctional 'remove from this cart' buttons, however, we could use JavaScript to actually get rid of some of those items. Here is the markup. The details are not that interesting, however, eventually we'll find that there is a development with the id of carttable, so it contains the table with the shopping cart items. We have the table indeed here, and then further down below a tbody element, and within that tbody element, each tr table row is one item of the shopping cart. So how about this? Here at the bottom we just implement a helper function, so removeFromCart, and then as an argument, the index of the row, because where are the shopping cart items? We do a querySelectorAll this time, so we are interested in a couple of elements, and we had carttable as the entry point, and then we had a table, and then we had tbody, and then we had rows within tbody. So this gives us all of the cart items, so how about we call this items. And then let's start counting from 0, as arrays do. So say we have five different items in the shopping cart, the index goes from 0 through 4, so if the idx we provide is smaller than items.length, then we can happily remove it. So we access items of idx, because we now can be safe to assume it exists, then we can just remove it. We don't know yet how to tie that code to that 'remove from cart' buttons, but we can still use the browser console. So I make sure that I reload the page so we get the latest code, and then in the console, I just call removeFromCart, and then how about we just remove the second item here, so the index is 1. I just call removeFromCart, and as you can see, that entry is gone, so we can now remove elements from our shopping cart, or since we are talking about the DOM, we can remove DOM nodes from the DOM tree.

Adding DOM Elements
A common requirement when working with data is to provide CRUD functionality, C‑R‑U‑D. That stands for create, read, update, and delete. We covered reading, updating, and deleting, so far. One thing is missing, creating. And, once again, there are several options. Of course, if you would like to add something to the DOM tree, we have to start somewhere, so we have to access an element and then start from that element. That element serves as a placeholder. And then we could just be lazy and, well, assign some markup. That is okay. As I've mentioned before, it's not super efficient, and you have to trust that markup, because if it's user supplied, maybe there's JavaScript in there that's certainly not what you want. But there are other options as well. Remember that we have that tree structure. So if we would like to add something to that tree structure, we have to think in that structure, we have to know about parent node, child node, dependencies or relationships, and then we have to add elements using that paradigm, and I'll show you how that's done. There are a few API steps. It looks cumbersome at first, but especially when automatically accepting structure data and putting that onto an HTML page, that approach works really, really well and is then also easy to understand. So first of all, when we'd like to add something to a page, say a paragraph with some text, we have to create that element, and the DOM method for that is document.createElement, and the argument expected is the name of the html tag, so it's just p, it's not <p>, it's p, and that creates a new element, in memory, so to speak, nothing gets rendered. That's good for all elements within angle brackets, but you've already learned that there are also text nodes for text content. Well, these can also be created using an API, and that method is then called document.createTextNode. Document.createTextNode creates, as the name suggests, a new text node. And of course we could use the new _p element we've created and set its text content, but I'd like to show you both ways, because now we have two nodes. We have the p node representing a paragraph element and we have a text node. And what's that relationship? The text node needs to be a child of the paragraph, and for that there's a method called appendChild. So appendChild takes another node and makes it an extra child, and if there's none, the first and so far only child of an existing node. So we say new_p, our paragraph node, .appendChild gets a new child node, and that new child node is the text node you've just created, so now in memory we have a paragraph with some text in it essentially. And then what's next? Well, we would like that paragraph to be rendered, so we have to add it to the page somehow, and since we already have our placeholder, why not just use the placeholder and then call appendChild for the placeholder? And if you have a more complex structure than that, you, of course, have more appendChild calls. There are also some helper methods similar to remove, for instance, after, which adds an element after another element or before, but most of the time appendChild is what you'll be using.

Demo: Adding DOM Elements
The ability to add new DOM elements to our HTML pages gives us great opportunities for our application, for instance, we could dynamically fill the shopping cart or fill the table with events. However, since there's quite some markup involved, it also includes quite a number of API calls, so let's start with something simpler here. In our footer, we have the copyright notice and we also have Globoticket, the brand name. This could be turned into a link, and we do that by showcasing a few of the things we've already learned. We first remove the Globoticket text node, and then we add a link in its place. And I'm happy to do that here in our code, so maybe here in between, and here's what we could do. First of all, let's access the Globoticket text node. Remember that the element here has three child nodes, the copyright character, then the span element, and then Globoticket with a blank. Let's remove the letter. So once again we do querySelector as method of the document object, we access footer div, then we access the lastChild, and then we remove it. That's the first step, and then we can add a new element. So first of all, I would like to create a text node that's just the space character, because there's a space character in front of Globoticket, and that should not be part of the link. So how about we create blank as document.createTextNode with just space character, and since I'm using the footer div element a couple of times, I'll put this in a variable now. So how about we just call it placeholder, document.querySelector, and then footer div, and we can use that actually everywhere here, so placeholder it is. And further down below, placeholder it is, and now we can add that new text node as a new child to our placeholder, so placeholder.appendChild(blank). And now let's create the new link. So I start with document.createElement, and since it's a link, it's a. I set the href attribute for the link target, so a.setAttribute, href, and I set it to, let's just say index.html, but it could be anything else. And then I either create a new text node and append it, or I set the textContent property. Let's just create a new text node so that you see this in action once again. So I call the element a_href, or a_text would even be better, and then document.createTextNode, Globoticket it is. And then we put everything together, so a.appendChild(a_text), so we append this text node as a child to our new link. And then I go to the placeholder, the placeholder receives a new child, and that's the link we have just created. Back in the browser, refresh the page, have a look at the footer at the bottom, there we go. And now we do have a link in the footer, and if we have a look in the browser DevTools, we will certainly see that now the div element has a couple of child nodes. So we have the copyrights character, we have the placeholder with the year, we have the blank. The blank isn't shown here specifically as a text node because there is just a blank in it, where in the parsing it is not considered specifically a text node because then all of the indentations would have to be shown as text nodes here, but technically, yes, there is a text node, and we can actually prove that by doing document.querySelector, and then we just go to footer and div, and then we have a look at the child nodes, and you see, indeed, the length of the childNodes is 4, so, yes, we have 4 child nodes. So the display here might be a bit confusing. It's the first child node is the copyright character, the second one is the span element, the third one, that blank we specifically created, and the fourth one is our new link, so we can now add arbitrary DOM elements to our pages. We can now completely change the DOM. We can create elements, we can read elements, we can update elements, and we can delete elements, so full CRUD, but so far this happened ad hoc, but we would like to have some user interaction and we'd like users to trigger those things, and that's what we need event handling for, and that's up next.

Event Handling Fundamentals
Event APIs Overview
Hi, and welcome to Event Handling Fundamentals, where you will learn everything you need to know to handle events from JavaScript. Historically, there are a few APIs, or a few approaches to handle events from JavaScript, and not all of them stood the test of time, so I'm using this opportunity to show you what you can actually use and what you shouldn't. The oldest event API is to use an element property like on and then the name of the event, on click, for instance, for a mouse‑click event. There are other events, you will see them during the course of this module and also in future modules. And you could also use an HTML attribute of the same name, onClick. This comes from Netscape. The team at Netscape invented the JavaScript language, so they had to make up something to make event handling work, and that's what they chose. Let's have a look. I have created a very simple function, addToCart, which basically increases the number next to the shopping cart in the header of the page by one. And I like to call this whenever the 'add to cart' button is clicked. There are two ways how I can do this using the Netscape‑inspired API. So either I could go to the button and then just add onclick=, and now the content, the value of this HTML attribute needs to be valid JavaScript code, so addToCart, and then parentheses, and that's it. So that would be one option. The other option would be that I'm setting the onClick property. So how about we start by selecting the first button, so let our btn be document.querySelector, and I'm just looking for a button element. I have five button elements on the page, at least currently. The querySelector only returns the first one, so I will be using that. And then I could use that btn and set its onclick property to addToCart. And this time I'm setting a property, so I cannot run code here, or should not run code here, instead, I just reference or point to that function, so that would work as well. Let's try this out in the browser. I hit the ADD TO CART button, and every time I do, the code runs and I increase the number of tickets in my shopping cart. I could also use an anonymous function, so something like this, and then in the function, I run some code. So this is now, of course, some extra typing and doesn't have much benefit here, but in practice, pretty often if there's just some throwaway code that you need exactly once, it often is put in an anonymous function like this and not put into a separate function. There are other options as well. One method is called attachEvent, also as a method of an element you have previously selected, for instance, by using document.getElementById, and that's what the Internet Explorer team came up with. They also supported the Netscape API, but they were looking for something different, maybe something better. Well, they were the only ones who believed in the superiorness of their approach, so no other browser adopted that, and eventually Internet Explorer chose to follow what the W3C suggested, a method called addEventListener. So that's the only thing that's really standardized, standardized in the DOM specification. It's not a JavaScript feature, but addEventListener is usually the recommended way to go, although you can come very far with the Netscape approach that's valid to this day still. We'll have a closer look at addEventListener and how that works in the next video.

Adding an Event Listener
Let's have a look at the most common and recommended way of adding something called an event listener to a DOM element. An event listener is basically a mechanism that waits, that listens, for an event to occur. Once it does, there's some code that handles the event. You have already seen how that method is called. We start by selecting a DOM element, for instance, by using document.getElementById, but, of course, any of the other DOM selection methods will work equally well, and then we call addEventListener. At minimum, that method expects two arguments. The first one is the name of the event. So click is a common one when a mouse click or a tap on, say, a button, a link or any other DOM element occurs. And the second argument is the event handling code, the code that needs to be run once that event occurs. So here's a very simple example. We have a function. That function can receive information about that event. So I'm storing in the variable e, which I can then use in the function body, well, and then we will handle the event. Let's have a look. Let's migrate our existing code to addEventListener, so let's use addEventListener here. As the name already suggests, you add one more event listener, so you can have several, which is the main advantage over just using onclick on something. And, as you've just seen, the first argument is the event and the second one is the handler function, which we already have here, addToCart. And, once again, you could have an anonymous function here, which you might be able to add in, so both approaches work, but I'd like to show this one. So this is the code. My new refactoring still will work sufficiently well. However, one thing we can do when adding event listeners like this, we can also remove them later. If you have several event listeners, we can remove individual ones. However, that does not work easily with anonymous functions, but if we have a name function like here, we could do it. I show you a very simple implementation that only makes sense if there's only one place where you're using this function. For the sake of simplicity, I think this approach is viable here. It will not be viable if you are using the addToCart function on several places on the page, which you would usually do. So we can also do a removeEventListener, and this method also expects the name of the event and then the listener. Let's give this a try. Here we go. So I hit the button once, and we now have one ticket in our shopping cart, and I hit it again, and nothing happens. Why? Because we removed the event listener. There is an extra argument to the addEventListener method, and historically, there only was an option to provide a Boolean value. Modern browsers also allow a hash table with some settings, and the most useful one, at least in my opinion, is once, because once basically says this event listener works once, and once the event occurs, so for instance, once a user clicks on a DOM element, the code runs and then the event listener is removed again. So let's quickly refactor this. I think this approach is much better. So we set once to true, and then we can remove the removeEventListener call, which also makes the addToCart method or addToCart function a little bit more independent on the addEventListener call.

Event Arguments
You may remember the argument the event handling function automatically receives. It contains information about the event. There are different options, and they differ a little bit between browsers, but here are the most common ones. First of all, the type event. So for instance, if it's the click event, type is set to click, which is pretty important, especially if you have an event handler that listens to different events, or event handling code that should run for different events, for instance, a click or a double‑click. And, of course, you might also be interested in the element where that event was fired or triggered. Just imagine you have five buttons, you have the same event handler for all of them, but of course, you have to find out which of these five buttons has been clicked, and that's what you can find by using the target property of that event argument parameter. That gives you the DOM element, and then you can query it and, for instance, have a look at some attributes of it or its tag name. Depending on the event, there are also event‑specific properties. For instance, if you have keyboard events, you might be interested in which key was pressed. If you have a mouse event, you might be interested in the coordinates of, say, the click, so where was the mouse pointer or where exactly did the user tap on the screen. We'll cover mouse and keyboard events later in this course, so you'll get much more details about that. Here on the shopping cart page, we already have the removeFromCart function from earlier, which expects the index of the table row to remove when removing an item from the cart. And the table rows in our example go from 0 through 4, so we could add an event listener to the removeFromCart button in the first row, and then call removeFromCart of 0, and for the next row, remove from card of 1, etc, etc, but I'd like to solve this with just one event handler. In order to do that, there are different strategies and approaches, and the one I'm showing you looks a bit complicated at first, but it also gives me the opportunity to point out some other things to watch out for when doing event handling with the DOM. I've already prepared the HTML a little bit for our endeavors. So for each table row, I have added an attribute called data‑idx, and I have written the table row index in it, so values from 0 through 4. Then if we look at the HTML hierarchy, if we are at the bottom with the removeFromCart icon and go up once, we reach the table cell, and if we go up once more, we reach the table row, where we can access the data‑idx property. However, it could be that we do not really hit the button, we hit the text on the button, the icon, the removeFromCart icon to be exact. In that case, we have to go up three times, once to reach the button, once more to reach the table cell, and a third time to reach the table row. That's pretty important, and why that is the case and why we could hit both of those HTML elements is something that we'll cover in a bit, but this is all we need to know. So how about this implementation? I start by accessing all of the buttons on my page. Now, I happen to know that document.getElementsByTagName works this time, because the only buttons on the page are those removeFromCart buttons. If you have more buttons, you probably should use document.querySelectorAll and then have a more specific selector. But here, all buttons is exactly what I want, and then I would like to iterate over them, like this forEach. However, there's a catch. I can't forEach over the data returned by getElementsByTagName, but using the spread operator, I can do that. So I iterate over all of the buttons, and for each button, I just do a button.addEventListener. The event name is click. I would like to listen for the click event. And the event handling code is in the function, removeItemFromCart, which I'm about to write right now, so function removeItemFromCart. And since this is an event handling function, it automatically receives event arguments, and I'll use the local variable e for that. And then I try to access the table row. So I start by doing something like this e.target, because target gives us the element where the event was triggered. So if I clicked on the button, that's the button. And in case it's the button, .parentNode is the table cell and .parentNode again is the table row. If I clicked on the icon, however, that's not the table row, it's the table cell, so I have to go up once more. So I take a look at the tagName property. The tagName property of a DOM element is the HTML tag name in all uppercase. So if that's not TR, if I'm not in a table row, then I just say row = row.parentNode, going up once again. That's it, and now I can read out the data‑idx attribute, so idx = row.getAttribute, and then data‑idx, and I can call removeFromCart(idx). That works relatively well. Of course, I could cast the attributes to an integer first, but still I have to change the removeFromCart function. Why? Because look at the implementation. We iterate over all table rows and then basically count which one we want. That works well until we have removed a row, because that changes the numbering, and therefore we need a different strategy. So how about this? We use querySelector instead of querySelectorAll because we are just reading out one item, and in order to do that, I am changing the selector a little bit. So I am not interested in just all of the table rows, but just in those table rows or in that table row, to be exact, where data‑idx has a value of, well, and that's what's in the idx variable. And then if that item exists, then I remove it. And that's the whole implementation that we need for that removal functionality. Back in your browser, so how about we remove this one first, and it's gone, and now this one, and it's gone as well. So the implementation might not be perfect, but it works really well, and also shows you a couple of concepts with regards to DOM event handling.

Event Bubbling
HTML has a hierarchy, and that's super important when talking about event handling, because, by default, what the browser does for events is something called event bubbling. Let me explain that with the structure we have already seen a few times in this course. Let's just imagine that someone clicks on the link. So there will be a click event here on that 'a' element. But if you click on the link that's part of a paragraph, essentially, you also click on the paragraph, and that's why the event is bubbling up. So the 'a' element receives the event, and if you have an event listener there, that event listener is triggered. But afterwards, the event bubbles up, it goes up the tree if the root is at the top. So also the 'p' element here receives the click event, and that goes on, and on, and on. So in our example, we also click on the body element, so if you had a click event handler there, that event handler then takes care of the click event, and then we would even go up to the root of the document. That can be pretty useful if you have a complex structure in your HTML and you don't really care where within that structure the user is clicking, and you need a central place for handling those clicks. Thanks to event bubbling, we can simplify our implementation somewhat. Instead of assigning multiple event listeners one per table row, you could just assign one to somewhere else higher up in the hierarchy, for instance, to the table or even to the container that includes the table. The container already has an id, carttable, so why not use that? So what we are doing is we are calling getElementById of carttable, so this container, and then we add an event listener. That event listener listens for the click event and then calls removeItemFromCart. Please note that this only makes sense if this is the only place, or the buttons, the removeFromCart buttons are the only place where you are intending to work with click events. Otherwise, the implementation might get a little bit more messy. Now, in the removeItemFromCart function, basically, all we need to do is, once, again read out the data‑idx attribute. Remember, wherever we click in our table now, the event is either at the span element with the icon or at the button, and then bubbles up, table cell, table row, table, and then at one point the container. So, once again, we have to have a look at e.target, and I'm implementing it a little bit differently this time. So I'm storing the DOM element where the click event originated in el, and then I have a close look at it to find out which row we need to remove. So I start by setting the row to null, and then I have a specific look at the element. So if the element is the button, so if the tagName property is BUTTON, then the row is el and then .parentNode.parentNode, twice up. Otherwise, if the tagName is SPAN, and I mean there might be so many spans, so let's be a little bit more specific. We know that the span element contains the removeFromCart icon, so let's look for that icon. We assign that icon by applying a CSS class. So we can have a look at the classList and then see whether it contains a certain entry, and the one here is this one, fill removeFromCart icon. Basically, that's all there is. And if we have a span like this, then row =, and then el, and then three times up, so parentNode.parentNode.parentNode. All right, and if row is not null, then we can basically proceed as before. So we read out the data‑idx attribute and then we call removeFromCart. Here we go, we remove this one, we remove that one, it works exactly as intended. There is one more thing. Maybe if we handle the event, we don't want it to bubble even further up because there might be side effects. If that is the case in your scenario, here's what you can do. So if we remove an item from the cart, we would like to stop the event from bubbling up. And this is how it works. I just go to the event arguments and then call stopPropagation. StopPropagation makes sure that the event doesn't bubble up further in the DOM hierarchy. However, if there are event listeners listening to the same event on the same level in the hierarchy, remember addEventListener means we can have multiple event listeners even for the same event, then those other event handling functions will still be run. If you even would like to avoid this, you can also do stopImmediatePropagation, but you never know which of those event listeners is run first, so usually stopPropagation is what I recommend. For the sake of completeness, I want to mention that there is also an event, let's say, hierarchical movement mechanism, that goes into the opposite direction when compared to event bubbling. It's called event capturing. So, once again, we click on the link, but the event needs to find its way through the structure. So it starts at the top and goes to the body element, down to the paragraph, and finally, down to the 'a' element where the user was clicking. There's also a way to handle those events during that capturing phase. However, most of the time, event bubbling is what you would like to use because you click on something and then the outer container might be relevant, usually not the other way around. And that's why, by default, the addEventListener method uses event bubbling and not event capturing.

Preventing Default Behaviors
I'd like to show you a pretty important feature when doing event handling with JavaScript. I would like to prevent certain default behaviors of the browser. Let me explain what I mean with that. Typical examples for such default behaviors are buttons, or to be precise, submit buttons within an HTML form. The default behavior of such a button is that the form is submitted, or if we have links, for instance, that link to the shopping cart page here, if we click somewhere on or inside that link, the default behavior is that that link is loaded, no matter whether we wire up some event handlers or not. Let me demonstrate that. For instance, we could say we do not allow going to the shopping cart page if there are no items within the shopping cart. In order to do that, let me write a helper function first. So how about getCartItemCount, and I just copy that in here, and then just do a return, and then let count = getCartItem count, because I need that now as well, that's the idea. So I'd like to add an event listener to our link to the cart page. How could we do this? For instance, by calling document.querySelector, and then my selector could be something like this, all a elements where the href attribute is set to ./cart.html. That's what we have in the HTML markup. And once we have that element, we can do addEventListener, the event name, once again, is click, and I'll use an anonymous inline handler function here. And I first get the count, so let count = getCartItemCount. And then if the count is 0, I'm opening up a model warning box and saying, no, the cart is empty. All right, so far, so good. Let's try this out in the browser. The shopping cart is empty. I click here on that icon, for instance, because that's within the cart link, and, yes, I get the message the cart is empty. But what happens if I close this message with OK here? I was redirected to the cart.html page. Why? Because a link has that default behavior. But in that specific case, maybe I just don't want that default behavior. What can we do about that? Well, in that specific case, if there are no items in a shopping cart, I would like to prevent the default behavior of that link, and that's exactly what I'm writing here in JavaScript now. I'm using the event arguments and then call preventDefault. The name of the method says it all, prevent the default behavior. Let's go back to the main page. Still the shopping cart is empty. I click on that icon, yes, cart is empty. I hit OK, and nothing happens, so I am not redirected back to the shopping cart because I have prevented the default behavior of the hyperlink.

Waiting Until the DOM Is Ready
And now it's time to keep a promise that I've made a while ago. We talk about waiting until the DOM is ready. So far, our code has been put at the very bottom of the page, because then we know the page has been rendered, the DOM should be ready, so we can do that. However, now that we know how event handling works, we have better approaches to use, and I will show you how. Let's take the whole script block here, cut it, and then paste it, how about here in the head block. Then I reload the page in the browser, but first I open up the console. So reload, and, oh, it doesn't work. Well, there's some dummy data here, but all of the event handling code is not in effect because we were applying it before the DOM has been fully rendered. For instance, the footer does not show the current year. One event that comes in handy here is the load event. We could do something like this, onload=, and then we run some code, but yeah, we didn't want to use HTML attributes for that, did we? So instead we can set up an event listener, so how about this? Retry, and now let's import not document, but window, and then addEventListener, because load is a window event, not a document event, and that will become important in a minute. So the event name is load and the code we would like to run is, well, basically this whole code here. So let's close that, and we are good. Now the JavaScript code only runs once while the page has been loaded, whatever that means. In order to be able to show you that, I go to the Network tab and add some throttling, so how about Fast 3G. So it takes a while until everything has been loaded, and now let's give it a try. So I reload the page, and you see, ah, at first the font is missing, now the font is there, but the copyright year is still not there. And slowly the images are loaded. It takes a while, and once the images are fully there and all of the other resources on the page, CSS, etc, etc, then the code runs. So the load event is fired once the full page is there. In some cases, that's what we want. However, in our case, we are not interested in all of the images being there, we would like that the functionality, adding elements to the cart, etc, works as soon as possible, and also that the copyright year appears as quickly as possible. And for that, that the DOM is there independent of images, style sheets, and other external resources, for that we have a specific event, and that's called DOMContentLoaded. We can use document.addEventListener for that. And now back in the browser, we can witness the following thing, throttling is still activated. I reload, and you see that immediately the copyright year is there even though the images are still being loaded. So DOMContentLoaded is probably the event you'd like to use for all of your DOM setup JavaScript code. We have now taken a look at general event handling for JavaScript, but for specific events, especially when talking about mouse events and keyboard events, there are additional things to consider, so that's why we will cover them next.

Mouse and Keyboard Event Handling
Mouse Events Overview
Hi, and welcome to Mouse and Keyboard Event Handling. You probably have already guessed it, we will be talking about specifics when working with events that were triggered by a mouse or a keyboard. Let's start with the former. There are a couple of events that are specific to mouse movements or someone working with a mouse, to some extent also when using gestures, and we are starting with events that relate to movement of the mouse. We have an element here, and we can attach a couple of event handlers to that element, and those event handlers are triggered once the mouse pointer is moved towards inside and then again outside that element. I'm using a mouse. I can hear not a mouse pointer, so it's better to see. So we are moving the mouse, the mouse is entering the element, that's the mouseenter event, then mousemove while we are over the element, and mouseleave once we have left the element again, so we can use those three events. There are two very popular and well‑known events that seem similar to mouseenter and mouseleave. They are called mouseover and mouseout. However, I prefer mouseenter and mouseleave because they do not bubble, and bubbling from mouseover and mouseout is, in my opinion, not a good idea because a subelement of another element does not necessarily have to be rendered inside of the parent element, so bubbling those events usually doesn't make sense or could lead to side effects. There are other types of mouse events as well. So when we click with the mouse, there is mousedown, which means we press a mouse button and hold it down, and then when we release the mouse button again, we have mouseup. And mousedown plus mouseup on the same element is something you already know, that's the click event. Why is it important that mousedown and mouseup are on the same element? Well, just imagine you have, say, two buttons. You put the mouse pointer over one button, click down the mouse, and then move the mouse to the other button and then release the mouse button. Then you would have mouseup on the second button, but you certainly did not click the second button, so that's why click requires mousedown and mouseup on the same element. Let's use those mousemove events to show you an effect on the Globoticket main page and also show you one more trick. At the bottom, we spot the addToCart icon. Basically it's a span, and then it references a Bootstrap icons class here, bi‑cart‑plus‑fill. So how about we select that? So we could do, let's say, btnCart, and then document.querySelector, and the selector would be span, but then what? We can't check for whether the class property is set to something specific, we need to look for an entry in the list of classes, and that's what can be done with that syntax here. So we have the tilde and then the equal sign, and then we just look for bi‑cart‑plus‑fill. That should give us our cart button, and now we can add event listeners, because we need two. So first of all, we'd like to listen for the mouseenter event, and if the mouse pointer hovers over the cart, we would just like to change the visual appearance. Now, I'm absolutely aware that this can be done with CSS only, but I just wanted to show you the mouseenter and later mouseleave events in action, so let's just do that. So we just access the icon and then it's classList, and then we just add an extra class. I've already prepared one, it's called cart‑highlight, which basically changes the color of that specific icon, and that's it. And then we do the same thing again for mouseleave. Let me just copy and paste that just to save some time. So once the mouse leaves the icon again, we remove the class we have previously added, and that's basically it. Here we go in the browser, let's have a look at the icon. The mouse pointer is approaching, and the color is different, and once we leave the icon, the color is back to its original form. Very simple effect, of course, but it showed you how to put the mouseenter and mouseleave events to good use.

Mouse Event Arguments
If we attach an event listener to an element, we again get event data, for instance, which element fired that event. Since we are using mouse events, there are specifics that would not be possible with, say, a keyboard event, that we can access via those event data arguments as well, and here are a few of them. I'd like to start with clientX and clientY. So these are the X and Y coordinates, but the coordinates of what? Well, obviously, of the position of the mouse pointer when the event was fired. And there are a few of those, so the differences are pretty important. ClientX and clientY contain the coordinates relative to the current window. For instance, if you click in the top left corner within the browser window, clientX and clientY will be 0, or close to 0. If you scroll horizontally or vertically and click in the top left corner, it's still 0 and 0, so that's relative to the viewport, and that's what clientX and clientY contain. PageX and pageY, they contain the X and Y coordinates of the mouse pointer relative to the current document. So if you, say, scroll horizontally by 10 pixels and then click in the top left corner, pageX will be close to 10, and not 0, as it was with clientX. And the third important one is screenX and screenY. So these are the coordinates, you may have guessed it, relative to the screen. Of course, if the browser runs in full‑screen mode, then only the browser chrome is basically added, but especially if the browser is not in full‑screen mode, then here the differences are, of course, pretty huge. So most of the time clientX/clientY or pageX/pageY is of interest, but not where on the big, big desktop screen the browser window currently happens to be, at least in most use cases. And there is a fourth set which I'd like to discuss, it's offsetX and offsetY. Once again, X and Y coordinates, and this time relative to the target property of the event data or the event arguments, so the target DOM element. So if you click on the top left corner of a button and then capture that event and then have a look at the event data, offsetX and offsetY are 0 or close to 0. So these are the most important, let's say, positional properties there are. Another set of interesting ones is button and buttons, singular and plural. So the button property contains the button which was pressed, because most mice have two or even three or even more buttons. Basically, the values are a bit weird, especially if you look at both options. So 0 is the main button, so usually it's the left button, but if you have a mouse for left‑handed people where the left and right buttons are basically reversed, and then it will be the right button. So the main button is 0 and the secondary button, so most of the time it's the right button, is 2, and the number between 1 is, if possible or available, the middle button or the wheel button. So if you have a mouse wheel, you can click it, and so that would be 1. So 0 is left, 2 is right, and 1 is in the middle. If you have extra buttons, the specification actually cares about two more extra buttons, and these have the numbers 3 and 4, but they are super rare in practice, obviously. It's a bit different with the buttons property, because as the name suggests, it also covers the use case that several buttons are clicked at the same time, and so the values are just added up. But to make this unique, they have 0 for no buttons, 1 for the left button, 2 for the right button, and then 4 for the wheel button, if available, etc, etc, and so you add things up. So pressing the left and the right mouse button at the same time would be 1 plus 2 equals 3. In practice, it's rather rare that you work with other mouse buttons than the left one. And while pressing the mouse button, you can also determine whether any special keys were pressed. So the ctrlKey property is a Boolean property that returns whether the Ctrl key was pressed while that mouse event occurred, but there are others as well like Alt key or Shift key, and others. Ctrl key is interesting, because quite often pressing Ctrl and clicking on, say, a link, opens it up in a new tab, so maybe knowing that would allow us to possibly open up new content in a new tab as well because the users might expect it. So these are the main additional mouse event arguments that we have access to. Let's also have a quick look at the X/Y coordinates that we can determine. So how about this? We write a quick helper function, and this helper function shows XY, just logs something to the console, the offsetX and the offsetY values, and then we call it. So when the mouse enters the addToCart icon element, we add the CSS class, and then we just add an event listener for mousemove, and whenever the mouse moves, we would like to output the X and Y coordinates. And why did I put that in a specific name function? Because then once the mouse leaves the element, I can stop this so I can remove the event listener again. So, once again, we access e.target, and then removeEventListener for the mousemove event, we'd like to get rid of the showXY listener, and that's it. In the browser, let's open up the dev tools, go to the console, and then I start moving over that icon, and you see that we get the position of the mouse pointer within, well, the padding of that icon, so that's why we don't get 0 0 if I'm at the top left corner, but values that are a little bit higher, because the link that contains that icon that provides the padding box here, and so we can find out where on that icon the mouse pointer currently is.

Demo: Drag & Drop
There is one more use case for mouse events that is very specific, maybe even a little bit outside the scope of this course, could be a course of its own, but still, I would just like to show you within the context of our application, and that's drag and drop. There have been different attempts at specifying that. Before there was a specification, basically there were user‑led implementations of drag and drop, so you wait for mouse events and then handle things and position elements. Now it's a little better, and I'd like to show you how that can be done. In the Globoticket application, I would like to add the functionality to drag and drop events directly into the shopping cart. Wouldn't that be nice? Let's just implement that right away. There are two steps involved. First of all, I have to tell the events that they can be dragged, and then I have to tell the shopping cart that things can be dropped onto or into it. Let's start with the former. So here's the first table row representing the first event, and I just add the draggable attribute and I set it to true, so this now may be dragged; out‑of‑the‑box browser feature, no actual coding necessary, and I just have to make sure that this is part of each table row now. That being done, I have to make the drop zone work. The drop zone is the link. Actually, I am selecting the link to the shopping cart which contains the addToShoppingCart icon and the 0 ticket, 1 ticket, etc, text. I already have that, so since I need it again, how about I create a variable cart and put that in here, and then just use the cart variable instead. And actually, since we already have event listeners for mouseenter and mouseleave for parts of that shopping cart thing, we could actually consider that we remove that variable and we attach that to the cart here as well, so we have less elements with event listeners. But now what do we need to do? There are a couple of events when it comes to drag and drop, and we will have to add event listeners for several of them. And the first one I'd like to cover is dragenter. It's like mouseenter, but this time not just the mouse is entering an element, but the mouse is currently also dragging something. And in that case, well, the default behavior is that the browser shows an error icon, because dropping is not allowed if you drag something on the page and would like to drop it somewhere else on the page. How do we prevent that default behavior? Well, we've already seen that, we call preventDefault, and that's it, and that's an important first step. The next event we add an event listener for is dragover. Dragover is like mouseover. So the mouse, or the finger or whatever is moving over an element, it has already entered it, but it's also dragging something. Once again, we would like to get rid of the error icon, so we just call preventDefault, all right. And now, what is the missing ingredient? The missing ingredient is what happens if we are dropping something. And this is pretty interesting, because there is a way to pass data along with the stuff we are dropping. Let me show you. First of all, I'd like to add event handlers that actually send data along with the events that are dragged. How do I do that? And actually, I will do it up here. I'll first select all of the events, so document.querySelectorAll, and I select in the eventtable table tbody tr. So I select all the table rows and then I iterate over them, and for each row, I add an event listener, and the event listener is for an event called dragstart. Dragstart means I start dragging that element. So what do I do when I start dragging an element? Well, the event arguments in that case have, among other things, a property called dataTransfer. That's basically an object that allows me to send structured data or just plain text. I would like to make it simple here, so I'm using plain text, and it works like this. I call the setData method, and first I provide the format. I just use plain text. I'm using the MIME type here, and then the value, I mean there are different options that I could send. How about we access the element that's being dragged and use its innerText, because then later we can see whether we get the correct information. So when an event is dragged, this data is dragged along with the event. So the final step is when we are dropping that event, we have to make sure that this data is also now part of the mechanism. So how can we do that? Well, we have events for dragenter, dragover, and what happens if we let go an element that we are dragging while we are over an element? Well, we are adding an event listener, and this time for the drop event, we are dropping something. And when we do, there are a couple of things which we need to do. First of all, preventDefault. That's always a good idea, because you can also drag and drop from outside the browser and the defaultBehavior would be to open that, so preventDefault always a good idea here when dropping something. And then we could just have a look at the data. How about we just log it to the console, so e.dataTransfer. We had setData before, now it's getData("text/plain"). And then, well, what happens if we drop something into the shopping cart? Remember, we don't have a real shopping cart, so before when we clicked on the addToCart button, we basically incremented the number by one in our addToCart function. Let's just do that again here just that we can prove that everything works as expected. The real proof, of course, is in the browser, so here we are. Let's open up the browser console, and then how about we take this element here. And you can see we are dragging it, but we can't drop it, error icon, but once we are over the shopping cart, oh, we can drop it, and we have one ticket, and the console says, yeah, that was the Talk Docker to Me Tour. So how about we try this again with another element, so how about the Code Empire Tour. Once again, drag/drop, and in the console we have here the Code Empire Tour, and this was adding drag and drop functionality to our Globoticket application.

Keyboard Events Overview
Let's turn our attention to keyboard events now. There are also a couple of things to know and some of them are actually pretty weird, if you ask me. There is the keydown event, which basically means, okay, a key has been pressed down. So the finger is on the key on the keyboard or on the on‑screen keyboard, and the key is in a pressed down state. And then there is a follow‑up event, so to speak, keypress, so the key has been pressed. So what's the difference? It turns out that keypress is, and it's really keypress, not keypressed, keypress is only fired when we have letters, when we have digits, when we have things like commas, dots, etc, but not for specific keys like Shift or Ctrl or F keys or arrow keys. There have been some browser differences, and so it's rather inconvenient to use, but basically the event is there, so if you see it in code, you then can understand what it means. And eventually the key will need to be released again, and that's when the keyup event is fired. As I mentioned, keypress is not always fired because it depends a little bit on which key was pressed, and therefore, there's, so to speak, a shortcut. So after keydown, maybe only keyup is following. My personal recommendation is avoid using keypress because of subtle browser differences. Usually keyup is what you want to do, so once a key is released you take an action, or if the action should be taken immediately when a key is pressed, say you implement a game or some navigation and you would like to work with the arrow keys, then keydown is the way to go.

Working with Keyboard Events
When working with keyboard events, we are certainly interested in finding out which key was pressed. However, before we do that, it's important to understand, and this may already be obvious to you, but I just would like to mention it just in case, that there are different keyboard layouts. For instance, here we see a MacBook keyboard using a German keyboard layout, sometimes called the QWERTZ layout because the top letter row starts with Q, W, E, R, T, and Z, so the Z and the Y change places, so to speak, when you compare it with, for instance, the U.S. layout. Also, there are some, I would say, language‑specific keys, for instance, the three letters here with the umlaut. So apart from QWERTZ, which we see here, or QWERTY, which is, for instance, used a lot in the U.S. there are also other keyboard layouts. This is an AZERTY keyboard, or keyboard layout popular in Belgium, France, and some other countries. And here, the Z, the Y, the W kind of switch places. And why am I mentioning this? There are different approaches how to access which key was pressed. Of course, we are most of the time interested in the actual value, so if you press on something labeled with a Y, we would like to get the information, yes, someone entered a Y. But in other cases, we are interested in which of the hardware keys was pressed, no matter what the label is. So maybe the top left letter, and that could be a Q, but here it would be an A, so how do we handle that? We get access to different keyboard event data or keyboard event arguments, and here are four. We start with the code property. The code property contains a string representation of the hardware key, so, for instance, key A, if I press the A, or if on a German keyboard layout, I press the Y, I get key Z, or key Zed, because from a hardware perspective, I just pressed the first key in the third row of letters, which on a German keyboard is a Y, but on a U.S. keyboard, which basically serves as a blueprint, that's a Z. The next property is called key, but that's not the hardware key, but that's what you would see if you were, say, in a text editor and hit that key. So if I press on a Y on any keyboard layout, the key property would be a Y. If I hit Shift and Y, it would be an uppercase Y. So this is for receiving the text that would appear once the key order key combinations would be pressed. In the code property, you can directly access pressing, say, the Ctrl key or the Shift key, because you get a specific code for that. There are two more properties that sound very promising, but hear me out first, there's keyCode, which returns the ASCII code of the key that was pressed. That sounds okay, so we could use that, and then convert it, and then find out what the output of that key would be. However, that's deprecated, is or will be removed from browsers, so don't use it. And, I mean ASCII sounds pretty old and dated, right? How about Unicode? Well, there is the charCode property that does exactly that, so returns the Unicode value of the key that was pressed, but once again, use is discouraged. If you're interested in what the output would be of a key that was pressed, use the key property instead, and if you're interested in the hardware key or in special keys like Shift or Ctrl or one of the F keys, then use the code property. Handling key events in web applications, especially when special keys are involved, is relatively rare because it might also surprise users, which isn't always a good thing. Still, I'd like to show you, so how about we try to implement a simple undo operation in our Globoticket application. So far, we have an event listener. When the user clicks on the first addToCart button, an element is added to the cart, and we have the once set to true option here so that the event handler is only ran once, and removing that so that we can add an item multiple times to the shopping cart. And then we can undo that. We have the addToCart function, and the opposite will be the removeFromCart function. Once again, we get our count, so getCartItemCount by basically reading it from the DOM. And then I set the textContent, not just to count ‑ 1. Why? Because then eventually that could turn negative, so how about we take the larger of count ‑ 1 and 0 so that the value can never get lower than 0. And now let's call this, so how about this? When we add an element to the shopping cart, we increment a counter, the undoCount. So undoCount is set to 0, and this will be increased whenever addToCart is called. So how about we do undoCount++. And then we would like to undo that later, and the typical key combination for undo is Ctrl+Z, or Zed. So how about we addan event listener to that? And here's how we can do that. We add an event listener for the whole document, and we could either choose keydown or keyup, but what happens if we hold the key for a while, then keydown might be fired multiple times, so let's just use keyup. And then let's have a look at what key was pressed. And there are two options which we're interested in, or two pieces of information, was the Z or Zed pressed and was the Ctrl key pressed at the same time. So we first look at the key property, and if that is a Z, and if also the Ctrl key was pressed at the same time, then we know, ah, it's Ctrl+Z. Maybe there is some default behavior in the browser and maybe we can prevent it, and of course it's up to the browsers what they are doing. Some browsers do not want specific key combinations to be overwritten like Ctrl+P or everything that would close the browser or close a browser tab. So just by good measure, let's prevent the default behavior, and then if the undoCount is still positive, then we decrease it by 1, and then we call removeFromCart. Let's try this out. So I'm adding 1, 2, 3, 4, 5 tickets to the shopping cart, and now I hit Ctrl+Z once, twice, three times, four times, five times, and I'm still trying to press Ctrl+Z, Ctrl+Z, Ctrl+Z. Nothing happens because we have already reached 0. One specific type of both events and DOM access is still missing, HTML forms. So we could, for instance, do an automated JavaScript‑based validation of a form, and that will be up next in our final module.

HTML Form Handling
Accessing HTML Form Elements
Hi, and welcome to HTML Form Handling, where we will not only cover specific events that we have not discussed yet, but we will also talk about specific approaches to access certain elements on a page. We are talking about HTML forms, and the first step or the first question is how do we access individual HTL form elements? There are a couple of approaches, and I would like to cover the most common ones, although I do have a preference, at least in most cases. We have already talked about the DOM and we've seen various methods to select DOM elements on a page, and I would say that's the preferred way of doing things when working with HTML forms as well. Assign a unique ID to each form element and then access that element via that ID, because then you always know that you're getting specifically the element you want. That doesn't always work. Think about radio button groups where you have several radio buttons, but even their DOM selection might get you pretty far. Another approach or another option that I'm seeing quite a bit looks like this. So we have the document object and then the forms property. The forms property is an array containing all of the forms on the current page, so all of the form elements. The array can have zero elements or several elements, so document.forms[0], since the index is zero‑based, gives us the first form on the page. And then when we're in that form, the elements property, once again, is an array that contains all of the form elements, so inputting a few others within that form, so elements[2] is the third form element in that form. It works reliably well when you specifically know how the form looks like and when that does not change, otherwise, using a specific number is a bad idea if, say, one form element is added somewhere in the middle. So a good compromise, so to speak, might be this approach: document.forms, and then if we apply a name attribute to that form HTML element, we can use that as an index as well, so we can use strings, not only numbers. In most cases, document.forms[0] still works well enough because it's rather rare that you are adding another form to one page, however, when then looking at the elements, that can be that elements change, get added, removed, etc, so using a name there, and that's, once again, the name attribute of that form element, is a good approach. Nevertheless, your form elements need name attributes anyway, because only then is the data being sent to the server when the form is submitted.

Accessing HTML Form Element Values
We have now seen how we can access an HTML form and the individual form elements within that form, but what about the values, because we might be interested in seeing what the user entered in their form fields. And that depends a little bit on the type of form field, but in most cases for most input fields, so input type equals text, password, and several others, the value attribute or the value property is what we need. So for a text field, the value property gives us text that was entered in the text field, also for a text area, so a multi‑line text field, also for password fields, also for the caption on a button, so value is what we need. However, there are some special cases, and they're noteworthy, so let's have a specific look at a few of them. If we have a selection list, so the select HTML element, could be a drop‑down list, could be a combo list, but it's a select element, then we have a couple of extra properties that could be of interest. One is options. So the options property of a select list contains all of the entries in that list, and for each of those entries, we can not only find out the text in those entries, but also whether the entry is selected or not. It's the selected property. We will see that a little bit later in this module. When we are just interested in which element was selected, then one approach that has been very popular for many, many years is to take a look at the selectedIndex property. That gives us the index of the element that's selected. So 0 means the first element was selected, 1 means the second element was selected, and if no element is selected, then the value is ‑1; maybe a bit unusual, but since JavaScript doesn't have strict typing, that's probably a good way of conveying that information. However, we can also use the value property. The value property contains the value of the selected option, and it's similar to how HTML form data is received by the server when a form is submitted. So if the selection list option has a value property in the option HTML elements, that value is sent, and if that value attribute is missing, then the caption is sent to the server. That doesn't work, though, for multiple select lists, so if you have select multiple, where several options can be selected, in order to get all of them, you would need to iterate over all of the options. And there's another special case, and that's checkboxes and also radio button. So for checkboxes, if you have a checkbox, the input type equals checkbox, then the checked property is a Boolean value that contains information whether that checkbox is checked or not. It's the same for radio buttons. There is also a value property here, but the value property contains the value of the value attribute of that checkbox or that radio button, and that is not really useful. So this is how you can get access to what has been entered in an HTML form element.

Preventing Form Submission
In some not too distant future, we would like to validate an HTML form with JavaScript, and if the form does not validate, we would like to prevent that the form is submitted, the data sent to the server. So how can we do that? How can we prevent form submission? There are a couple of approaches. There have been additional approaches that did not stand the test of time, but these still work. So one option is to hook to the submit event of a form, we could use an HTML attribute like this, onsubmit, and then as code we just say return false, and this actually prevents form submission. That looks relatively weird, but it works. We've already discussed this. I'm not a big fan of having these attributes because it ties the code so much to the markup, but it works, and if you see this, you now know why there is a return false. Just writing return false here isn't super helpful, though, because it just prevents the form submission forever, so to speak, but it makes a little bit more sense if we try something like this, so onsubmit= return, and then some function call, checkForm(this). This refers to the form because we are in the form element, so the argument that is then submitted to that checkForm function is the current form. So we can use that value or that variable we are getting, access its elements, and then do some validation. If the validation then fails, that checkForm function can return false, so basically, we have onsubmit= return false, and the form can't be submitted. If the validation does not fail, checkForm could return true, so we have return true, and the form is submitted. But let's get away from that markup and just write code. So, once again, the submit event of that form is crucial here. You might be tempted to attach something to, say, the click event for the submit button of the form, but depending on the form, you could also submit it by hitting Enter while in any form field, and then you would miss that form submission, so hook to the submit event of the form. As usual, the event listener, we are setting up, and I'm using the shorthand version here. Of course, we could and should do an addEventListener, but for the sake of brevity I was using a short form here. We are getting the event argument variable here, e, and I mean, what do we usually do if you would like to prevent the default behavior of something in the browser and the default behavior of a form when it's about to be submitted is to, well, submit the data, we are calling preventDefault, and that reliably prevents the form from being submitted. So the only thing left is that we implement the rest of the logic, so we need to find out how we can validate a form.

Demo: Validating Forms with JavaScript (Part 1)
There is certainly no better way of seeing how to validate a form with JavaScript than by actually trying it out, so let's do some form validation with JavaScript. Before we do, one quick notice. Of course, we are all aware that with modern HTML, there is built‑in validation functionality, so we have attributes like required and many others, so much of the validation work could also be done by the browser itself. Still, especially for advanced scenarios, JavaScript often is still the way to go, so let's have a look how to set that up. In order to show validation in the Globoticket application, I've added an order page, well, rather an excerpt from a real order page. We have a couple of fields here, a text field which will hold the email address of the person filling out that form, then we have a radio button group with continents, and yes, I'm aware that depending on where you're from, you are probably used to distinguishing between four and seven different continents, and in some areas of the world you refer to Australia, and in others you refer to Oceania, but it doesn't really matter for our purposes here. We also have a combo box for seating preferences, where we could select multiple entries, and of course we have a checkbox with terms of service, and then a button which will submit the form. In the HTML markup, the form has an id, orderform, which allows easily referencing it, and then each of the form fields we are working with both have a name attribute set so that the form data is sent to the server and the form is submitted, and also an id attribute which facilitates accessing that element with one of our DOM methods, if needed. And basically, that's it. At the bottom of the page, we already have two helper JavaScript functions. Essentially, they either set a CSS class to an element named is‑valid or the is‑invalid CSS class, and then remove the other. This is a class that comes with Bootstrap, and essentially if, say, is‑invalid is set, then there is a red border around the element indicating that something is wrong here. We are using that to show the results of our validation. And now let's start implementing the actual validation, and I would like to start by storing a reference to the form in a variable, because I will be able to use that later. So I am accessing it via document.getElementById, and the name is orderform, as we have just seen. And then I'm implementing a function, and I'll call it checkForm, and it receives event arguments because I would like to use that function as an event listener function for several events, as you'll see in a bit. Well, we are about to implement that function, but I'd like to show you how this function can be used. So I have the form in the f variable already, so I'm doing addEventListener, and the event I'm listening for is the submit event of that form, and if the form is submitted, I'd like to call checkForm, so now I've tied that up. In that checkForm function, I'm essentially accessing all of the form fields, and then check the value in there, and that's basically my validation. I'm using a relatively simple approach here, so, for instance, in the email field, I'm just checking whether there's something in there, but not whether that's a valid email address, but, of course, it would be trivial to add that functionality, and I'm also not directly accessing the individual form elements via their IDs, but I like to use the elements property of the form so that you see both things in this course. So let's start with the email. So we just check f.elements, and the name and id of that email field is email, so I can check the value. And if that's an empty string, yes, I know, maybe a blank string isn't a good idea either, but let's just assume if it's empty, then it's invalid, I can call makeInvalid and then f.elements[email]. However, if it's not invalid, it may have been invalid before, because later this validation will run while we are filling out that form, so I am calling makeValid(f.elements["email"]). However, if I don't have a valid value in there, I like to prevent form submission, how can I do that? Well, it's the default behavior for the submit event, and you already know what's going to happen, so preventDefault. We've covered that before. So that was the email field. That's arguably the easiest of them, but don't worry, the others are also easy to do.

Demo: Validating Forms with JavaScript (Part 2)
Let's continue with the radio buttons. That's a bit complicated because the seven radio buttons we have for the seven continents, they all have their own IDs, and they are more or less independent. They have the same name, that's how radio button groups work in HTML, but they are not really grouped. There are some different approaches how that could be done. Here's what I would recommend now. So, I introduce a variable, continentSelected, whether a continent has been selected or not. And by default I say, no, I don't think so, so I set it to false, and then I iterate over all of the elements called continent. There will be seven because they all have the same name. So f.elements["continent"] is not one element, it's an array of all with that name. And then if that specific element, so that would be f.elements["continent"], and then the index, so [i], and then if that's checked, then we say, okay, continentSelected = true, so, yes, I have checked one of those radio buttons, so I have selected a continent, and in that case, I could even leave the for loop. And if at the end no continent has been selected still, then I know form submission needs to be prevented, so preventDefault. You could now also iterate over all of those radio buttons and try to make all of them invalid CSS. Why? So that we see a lot of red, but I'd like to skip that here. It wouldn't look that pretty. For the multi‑select or combo box, the approach is pretty much the same. So this time, I would like to introduce the seatingSelected variable, also defaulting to false. And then, once again, I iterate over it, so i = 0, i < f.elements, and it's called seating. And that's the select list, and the select list has a couple of options, and I'd like to iterate over those options, so that's what I'm using here. And now I just check the options, so if f.elements["seating"], and you see it's a lot of typing, so maybe using one of the other DOM methods might be more viable, and then options[i]. And if that one is selected, then we know our seatingSelected is true and we can leave the for loop, and then, once again, in the end, so if no seats have been selected, then e.preventDefault. And this time we can make it invalid again, so we access the seating select list and assign that specific CSS class that makes it look invalid by adding a red border. However, if we did select some seating, then we have to make it valid, so f.elements["seating"]. So far, so good. What's left? We have the checkbox, terms of service, and I would like to make that really quick and easy here. So if f.elements["tos"] is not checked, then preventDefault, so I don't bother with the red border at the moment. And that's it. That validates the form once it's submitted. However, I already mentioned that I would also like this validation to run while users are still filling out the form, so what event could I pick? For text fields, there is the input event. That is fired whenever something is put into that form, so while I'm typing, each keystroke, basically, where a new character is added or removed from the text field, fires that input event. I don't know about you, but when there are forms where I'm filling out a field, say my email address, and I get all of that red while typing, but I know myself I'm not done, that's only half of my email address, please bear with me, I don't like that. I don't like if there's already the red validation error, so I prefer something else. I prefer the change event, because a change event is fired when we have changed the value in a form field, so for instance, in a selection list we have selected something, but for text fields, it means we've entered something into a text field and then switched over to some other field, so if the blur event usually has been fired for that text field, and that's what I'd like to do. So how about this? So, we set up a variable called formelements, and that contains all of the form fields. So how about this, querySelectorAll, and we are interested in the selector within the orderform, all input fields, and within the orderform, all select lists, I think these are the two HTML elements we are using, and then we iterate over it. So formelements.forEach, and for each element, we just do el.addEventListener("change", checkForm). That's all we need to do. Of course, for the change events, there is no default behavior that could be prevented with preventDefault, but the validation runs, so we see in the browser whether the input is okay or not. Let's give this a try. So here's the form in the browser. I don't fill out anything, I hit the Submit button, and you see nothing's happening, but we get the red validation error for the email and the selection lists, because that's where we have added those makeValid and makeInvalid calls. So I pick some seating preferences, and immediately after starting that, you see that the border turns into green, change event was fired, so I am now good here as well. I am also picking a continent, I am accepting the terms of service, and for the email address, once I start typing, nothing happens, because we didn't attach to that input event, just the change event, so I'm just doing example.com. I tab out of it, and now we are good. And if I hit Submit order, the form is actually submitted. You see that if you look at the address bar of that browser. So the data has now been sent to the server because the form has now passed validation.

Course Summary
And that's it. We have together reached the end of this course in which we covered a lot of stuff related to using JavaScript in a browser context. We have had a look at the Document Object Model, which is crucial for JavaScript to access any element on a page and also to modify it to our liking. We also worked with event handling, so we learned different APIs to attach event handlers to DOM elements, and also talked about specific types of events like mouse events, keyboard events, and form events. And that was indeed the final topic of this course, HTML form handling, where we've just seen how to access forms and form elements and their values on a page, and use that to implement custom form validation. And with that, I say thank you very much for following along, and good luck with all your future JavaScript endeavors. See you again soon here at Pluralsight.