Course Overview
Hi there. My name is Maaike van Putten, and welcome to my course, Debugging JavaScript Applications. I'm a software developer and trainer at Bright Boost. Debugging JavaScript is a very important skill when you want to create a JavaScript application. When you improve your debugging skills, you improve your coding skills and understanding of real‑world applications drastically as well, both in terms of speed and quality. It even becomes easier to learn new things yourself when you're able to troubleshoot it better. And this course is going to teach you exactly that. I'm going to help you to understand debugging JavaScript in both the back end and front end. Some of the major topics that we'll cover include using VS Code to debug the back end, working with Chrome DevTools to debug the front end, common bugs that might occur when working with JavaScript. And by the end of this course, you're ready to continue your JavaScript journey and learn more advanced concepts and create interactive web applications. Before beginning the course, you should be familiar with the basics of JavaScript. From here, you should feel comfortable diving into many other JavaScript topics with courses on building a web application with JavaScript, network requests in JavaScript, error handling in JavaScript, and many more. I hope you'll join me on this journey to take your JavaScript development skills to the next level with my Debugging JavaScript Applications course here, at Pluralsight.

Basic Debugging Concepts
Module Intro: Basic Debugging Concepts
Welcome. In this module, we're going to be dealing with the basic debugging concepts. I'll start off with the fundamentals. We're going to be talking about what debugging is and when we need it. Then, we'll move on to the basic debugging concepts. For example, we're going to see what breakpoints are, and we'll see what step over, step into, and step out mean. Next, we're going to see what watching expression means and what exceptions are. Then, we'll see how to read a stack trace. After that, I'll show you the buggy application that we're going to be using for the next modules. We'll end the module by going over the main takeaways. Why wait any longer? Let the debug fun begin.

Debugging and Bugs
Even if you don't know what debugging is, when you have written code, you've probably did some debugging, unless you've written 100% flawless code that is, which, and let's be honest, is nearly impossible. But it would be super impressive. Debugging is the process of identifying a problem within your applications and solving it. Merriam‑Webster defines the verb debug as to eliminate errors in or malfunctions of. I added the part where we need to find them first. But clearly, that would be necessary for the removal. So, when to debug. Well, debugging is something that starts as soon as you start coding, but it continues to be a process that you'll do in the testing stage and even after moving the application to production. Ideally not, of course, but in reality, debugging is still often required to deal with reported bugs by users. So a bug. What is a bug? A bug is an error, flaw, a failure, or a fault in a computer program. And these flaws causes the program to produce incorrect or unexpected results. Clearly, not all problems are equally problematic. Sometimes the bug is a small problem that doesn't require immediate fixing, for example when the user updates the address details, but the page doesn't automatically refresh. And after doing so, they might be redirected to the home page instead. This can definitely be annoying, but they can easily navigate back and see the new details. They can still use the website. And sometimes it's a big problem that needs to be fixed as soon as possible, for example a security problem or something that really breaks the process. Imagine that the user cannot update the address details at all. This way, shippings and letters might end up at the wrong address. And the fixing also differs in size. Sometimes you can solve the bug with adjusting just one line of code, but it could also be two components that have issues communicating that require a total restructuring of the entire application. Small bugs are often easier to fix, but that definitely doesn't need to be the case. A small problem can sometimes require a huge fix, and a huge problem can sometimes only require adjusting one line of code. So to summarize, debugging and bugs happen and exist in many shapes and sizes during all stages of the product development and maintenance. In order to make debugging smooth, it's important to have the following best practices applied. Great documentation helps to understand what different parts of the applications do and why certain technical decisions were made. For example, sometimes integrating two systems requires little workarounds. Documenting this can help your future you, but also colleagues and potential new hires later to understand what is going on. Unit tests can help to catch bugs before they make it to production. And this is, of course, most ideal because if you have bugs, as long as they are not in the production environment, your users don't experience the negative effects of them. And lastly, well‑organized code that sticks to the best practices helps a lot as well. It's much easier to find a problem when it's well organized, and the same goes for solving it. Think of finding an object in an unorganized home and tidying it up versus an organized home. With the definition of bugs and debugging in mind, let's explore one of the most basic debugging concepts in our next video, namely breakpoints.

Breakpoints
Now you're getting to grips with what debugging means, let's dive into some fundamental debugging concepts, starting with breakpoints. We're not going to see these basic concepts in action just yet. This is just a small theoretical part to get you ready for all the action in the next modules. So what are breakpoints? You can think of breakpoints as the pause button for your code. You know, just like passing a video when you want to check out some of the details that are happening on the screen. For example, when you're watching a magic show and you want to look closely to see what's happening, you could pause the program. And the same goes for your code. You set breakpoints at specific lines in your code where you suspect things might be going wrong. When running the code, execution stops right at that line, allowing you to inspect the values of your variables and understand the flow of your code. The place where it pauses is called a breakpoint. And just like with a magic show or movie that you're watching, when you're done with inspecting, you can press Play again and the code will continue to execute. You can also continue step by step and move from one line of code to the next, but that's something that we'll discuss later. Let's first talk about lines of code. When we talk about a line of code, we're simply talking about a single instruction in your code. This could be anything from declaring a variable, calling a function, or starting an if statement. Typically, anything that should end with a semicolon or a curly bracket followed by a new line is a line of code. The reason I'm saying shoot is because JavaScript is rather forgiving and you could miss semicolons or you could just put everything on the same line. But for example, the start of an if statement doesn't end with a semicolon, but it ends with an opening curly bracket. And we can step through all that line by line. We have three options for stepping through the code. We have step over, meaning that we just step to the next line of code. So when we're on line 19, we step to line 20. We also have step into. So imagine we're still on line 19. If that line requires calling a function, with step into, we actually step inside of that function. And then in that function, we can step over again and go to the next line inside that function. At the end of the function, the next line would be line 20 because that comes after line 19. We can also step out if we want to step out of the function we stepped into. There's just one more concept I want to talk about in this video, and that is that breakpoints can get even cooler. How you may wonder? Well, we have conditional breakpoints. Imagine you're watching the same video to learn a magic trick over and over again, but you're only interested when a specific action is happening, for example when the aces are visible. Conditional breakpoints are like saying, hey, I only want to stop if these variables equals those values. This way, you can ignore all the images of the video that you're not interested in and pause at the juicy parts where the magic happens in the magic trick case. This helps you to not break unnecessarily. And this way, you can focus on the interesting parts and only inspect it when the situation you're looking for occurs. All right, that wraps up our introduction to breakpoints. It's going great, so let's keep this momentum going and move on to understanding expressions and exceptions.

Understanding Expressions and Exceptions
Let's tackle watching expressions and handling exceptions. Let's start with watching expressions. Let's continue on this video a movie analogy. I'm not super into magic, but I love a good magic show. And at least for me, when I'm watching a magic show, I always try to figure out in my head how it's working. And I typically have an idea of how I think it is working, and there's typically some suspicious move that you want to look at. That's what watching expressions is like in debugging. It lets you keep an eye on specific variables or expressions and shows you how their values change as the code runs. It is super helpful for bugs that change behavior as the program executes. At the same time, a little bit like the magicians, your own code can deceive you sometimes, and you were watching the wrong thing while the actual problem was happening elsewhere. But that's the story for another day. For now, let's assume that we will know what expressions to watch. All right, onto another concept that sounds the same, but it is very different, exceptions. In the coding world, exceptions occur when something goes wrong. They are unexpected and undesired plot twists that disrupt your code's flow. Not all of them are equally unexpected though. Some of them might be known to possibly occur, but they're on the unhappy path. But exceptions occur when something goes wrong while the program is running, like trying to divide a number by zero or connecting to a database that's not turned on, and there's many more examples of when exceptions occur. Exceptions when they not handled can cause your program to crash and stop. This is why handling exceptions is very important for creating resilient applications because, of course, we don't want our application to crash when something unexpected happens. Having said that, not all exceptions are equally unexpected. You don't want all exceptions to stop your program. Some exceptions are simply things that can occur and they need to be handled, such as not being able to connect to an external source. That happens part of life, give good user feedback, and move on. But some of them should not occur. And in order to achieve this, the code should be updated. There is typically some general handling for those to keep the program from stopping. That's it for watching expressions and exceptions. We'll see enough of both any later modules. All right, one more video with basic debugging concepts after this one. We'll read stack traces and talk about navigating through the code while debugging. I'll see you there.

Tracing Errors and Navigation
Let's deal with two more things on a theoretical level, tracing errors and navigation while debugging. In the previous video, I talked about exceptions. When an exception is thrown, it contains the stack trace. A stack trace is the list of methods that were called before the exception was thrown. When exceptions happen during development, you can see the text in the output console. A stack trace is like the route your code took. It shows you the exact path your code took method by method right up to the point where the error occurred. Reading a stack trace is like reading a map that leads you straight to the problem, and it gets you closer to your bug. All right, here's an example of a stack trace. Let's break it down. On top it says TypeError: Cannot read property name of undefined. This is the error message. It's saying that the code tried to access the property name of something that was undefined. Then, we see it happened at getUserName, and it shows the file and the line number. It's line number 22, column 19, meaning the 19th position on line 22. This tells us the error occurred in the getUserName function, specifically in the file user.js at line 22 and column 19. Then, we see at getUserInfo. This is the function that's called getUserName. The call to getUserName in this function happened at line 10 and on column 13. Lastly, we'll see at main. This is the initial function that started this chain of function calls. The main function in index.js at line 5 and column 1 is the one that called getUserInfo. This is a very short stack trace. Typically, navigating to the top of the stack trace gives you the details. In this example, it might be the case that getUserName was called with an argument with the value of undefined. This could indicate that the getUserInfo function didn't receive or didn't correctly handle user information. To start, we should probably look at the code in these places, line 22 in the user.js file and line 10 in the user.js file, to figure out why the undefined value was passed around. Let's explore the case that we're going to be working with throughout the course in the next video.

Demo: Our Case
So we're having an application skills app, and this application is used to add skills to certain users. I'm going to show you the user interface. I'm going to show you the code, but I'll start with how to run the app so that you can run the app yourself while following along with this course and follow along with the examples if you like. All right, so here's the skills app. You can see there's three folders, a data folder, a public folder, and a server folder. In the data folder, there's just a file nextId.json and users.json. These sort of serve as fake databases so that you can use this application without having to set up a database. Clearly, a real‑life application is not very likely to use this setup because it's a poor practice. Then, we have the public folder. In the public folder, we have everything for our front end. We have our HTML files, we have our JavaScript files, and we have a CSS file. Then we have our server, and on the server is the Node.js back end. This server is dealing with all the requests of the front ends and is reading from the data folder and writing to data folder. Let me show you how to start this application. I'm going to be opening up a terminal. And in the terminal, I'm going to say npm install, and this is going to install all the modules that are specified in the package.json. As you can see, it's done. Next, I'm going to start the application, and I'm going to do so with the command npm start. And as you can see, server is running on localhost port 3000. There's just one thing you need to know, and that's that if we need to navigate to port 3000/main.html. Let me open up a browser and show you. All right, here I am, and I navigated to localhost:3000/main.html. And you can see I need to log in. I will first log in as a regular user. There we go. And now I am logged in. You can see my skills here. There's six skills in this list. And I can also navigate to the Add Skill and then go ahead and add a certain skill in here, for example talking. Now it says Skill added successfully. And when I navigate back to view my skills, I can see it was added. All right, let's log out and now log in as an admin. You can see I have one more button. I have some skills in here. I could still add a skill, and I could still log out, but I also have an admin page available. And on this admin page, I can see all the users that are available. I can also go ahead and add a user with a certain password. And I can also select a certain user and add skills to that specific user from this view. This is the application that we'll be using a lot throughout the code to demonstrate all sorts of debugging examples. All right, and that's it for this first module. Let's move on to the module summary to see the main takeaways.

Module Summary
All right, so we're done with the first module. Let's take a moment to pause and recap everything we learned in this module. We began by understanding what debugging is and why it's essential in our daily coding routine. We learn that bugs are errors or faults in our code that lead to unexpected or incorrect results. Debugging is how we track down and fix these bugs. Debugging is part of software development, so for testing and maintenance. Then, we moved on to the basic debugging concepts. We explored breakpoints, and we've seen the step over, step into, and step out to navigate through the code while debugging. We've also had a look at watching expressions, we've seen what exceptions are, and we've seen how to roughly read stack traces. Then, I moved on and I demoed you the case that we're going to be using throughout this course. And now that you're familiar with these basic concepts, we're going to be taking a step forward in the next module. We'll be applying what we've learned to debug a real application back end using Node.js in Visual Studio Code. We'll be encountering bugs, trace them down using the concept that we've just discussed, and we will use our coding skills to fix them. This is where theory meets practice and the debug fun really begins. I hope you're as excited as I am, so let's go.

Debugging Backend JS with VS Code
Module Intro: Debugging Backend JS with VS Code
Welcome. In this module, we'll start the actual fun part. We're going to explore how to debug the back end with Visual Studio Code. Our back end is a Node.js application. You can see it here in Visual Studio Code. It uses the Express framework and doesn't connect to an actual database but writes to a JSON file instead. Why? This way, it is easier for you to follow along. What you are looking at right now is a working version. Throughout this course, I'll sometimes check out a specific branch, and I'm going to show you a video on how to debug it. This branch will have a broken version, so this way we actually have something to debug. You can clone the repository and follow along if you'd like. This module focuses on demonstrating the basics of debugging the back end. We'll learn how to get VS Code ready, set breakpoints, step through our code, inspect our data, and uselog points. Lastly, we'll also see auto attach. And of course, we'll end with a summary. But first things first, let's get started by getting VS Code ready.

Get VS Code Ready
Before we start debugging, let's get Visual Studio Code prepared. So step 0 would be to get VS Code if you don't have it. I'm going to assume that you do have Visual Studio Code installed. Next, we'll need to make sure that we have Node.js installed. You can verify that you have Node installed by typing node ‑‑version in your terminal. And then when it shows you a version, you know that you have Node installed. If not and it says that Node is not recognized or something along these lines, you don't have it installed. If you don't have Node installed, you can download it from this website. It's time for me to show you how to get VS Code ready. Before I'm going to show you the elaborate way of getting VS Code ready, I want to show you a very simple single file to debug in VS Code. We're going to go to the run and debug view in VS Code, and we're going to run the script in debug mode. All right, so here is a very simple JavaScript file, but it's not working as we expect it should work. When I run it, it says x is 10, whereas I did not set x to be 10 so that's confusing. Maybe you see it already, but let's assume you don't. I'm going to put a breakpoint on line 1 and navigate to the Run and Debug view. Then, I'm going to click Run and Debug and select Node.js for now. And as you can see, my code is pausing. There's a few things you can notice on the screen. We'll go over these in a bit more detail later. But to give you a rough overview, in the middle, you can see that our step into, step over, and step out are floating, and we can also continue to code or stop it right there. Then, on the left, we have the Variables pane where we can go ahead and inspect the values that we are having in our local scope, but also in our global scope. Here, we can add expressions to watch. And then at the bottom, you can see the call stack that's happening. So, I want to go to the next line here. So I step to the next line, and I notice in my local scope that x has changed to 6. All right, so all's going well I think, and I click on go to the next line again. Hmm, I see I do end up on line 4 even though I set x to 6. And if I look at my local scope, I can see that x is now 10. And then, I look closely at my if statement and I realize, oh shoot, I forgot to do a double equal sign and use a single equal sign instead. So instead of comparing, I'm now assigning. And then 10 ends up being a truthy value, and I end up inside my if statement. So, going through it step by step made me realize where my mistake is. I can now either continue the execution, or I could have opted to stop the code. And if I go ahead and I run this again, you'll see that it now prints nothing, which is exactly what I would expect because x is not equal to 10. Let's look at a slightly more complicated setup, and we're going to get VS Code ready for debugging our back end in Node.js. Again, we're going to go to the Run and Debug view, but this time, we're going to add a launch.json file. So here I am in my Run and Debug view. And as I mentioned, I am going to add a launch.json file. As you could see before, it was working without. And strictly speaking, we don't need anything else. We could just start debugging. But in many cases, it's beneficial to create a special config file. This way, we can save our debugging setup and config details. So we'll create this new launch configuration. Now I'm going to click on Node.js. And as you can see, this added a launch.json file. It is in the .vscode folder, which is containing our VS Code settings at the root of our project. So you can now see this file being added in our workspace. The launch.json file is controlling the configuration of our debugging sessions. So here's an example of what a simple launch.json configuration looks like out of the box. And with this configuration, we're telling VS Code to start our app.js when we start debugging. Please mind, in order to add the launch config, we need to have our project folder opened. And there are quite a few options for how to configure it exactly, and they will differ depending on your needs. This one is fine for our JavaScript back end. And that means we're now ready for some debugging. Let's move to the next video to set some breakpoints.

Pausing the Execution
Let's start by seeing how we can pause our application. This can be done by adding breakpoints. Breakpoints are the most basic and essential feature in debugging. With a breakpoint, we pause our code at critical moments and expect it. It allows us to walk through the next line of execution step by step. We'll demo how to add a breakpoint and how to pause at this breakpoint by running the app in debug mode. Here's our user.js. And as soon as the user is logged in, we go through this function. To add a breakpoint, I can simply click in the left gutter, and a red dot will appear. Now, our code will pause as soon as it hits line 9. Let's go to Run and Debug and use the configuration we just created to launch our app in debug mode. So, it's running. Let's move over to the browser and log in and see that our app is going to pause at this point. All right, let's log in with admin, admin again. And as you can see, nothing happens when I click the button. If I was not using this in full view mode, VS Code would blink orange from my computer. So let's move back to VS Code and see what's up. As you can see here, our app is being paused. The line where it's paused on is highlighted, and you can see the yellow arrow around or breakpoints. Now that our program is paused, it allows us to inspect our variables and the call stack. Let's see how to go from here in the next video.

Stepping through the Code
Okay, so we managed to pause our program. Now what? Well, we have multiple options. We can have a look around and we can step through. Let's talk about stepping first. We can use the debugging controls at the top of the editor to navigate. We can walk through our code step by step. That always follows the way the program would execute it. So we cannot control where the execution will go, but we can control the type of steps we're taking. We can walk through our code step by step. It always follows the way the program would execute it. So we cannot control where the execution will go, but we can control the type of steps we're taking. We have four options. We have step over, which means it's going to move to the next line. We have stepped into, which means that it's going to dive into the function call if it stumbles upon a function call. We have step out. That's the way to go out of the function call if we're no longer interested in that function call. And we have continue, meaning we're just going to continue execution as normal until we hit another breakpoint again. So, at this point, our code is paused, and we can inspect what is going on. And here we can see our local scope, for example. And as you can see, password is undefined still at this moment and so is username. As soon as I step to the next line, so we're going to step out right now, you see it's going to set a value for username, and it's going to set a value for admin password. So we step to the next line, and right now it's going to do a function call. If I just press the step over button, it's going to move to line 12. But if I press the step into, it's going to take me to the getUser function, and we can step through that function as well. So let me show you. We now move to the data.js file, and we can go ahead and step into yet another function because this is another function call. And as you can see, we're now in the readUsersData. But I feel like I step in a little bit too far, and I can now step out. So if I click step out, it first takes me back to getUser. And if I do another step out, I'm back to the login endpoint. Let's assume I'm done inspecting right now, and I can just press Continue, and it will continue the code execution. There's another cool feature that deserves to be pointed out here, and that's conditional breakpoints. We can tell the debugger to only pause when a certain condition is met. I can also go ahead and add a conditional breakpoint. Instead of just clicking in the left gutter, I'm going to click the right and say Add Conditional Breakpoint. Then, I specify the expression. In this case, I want to break when the username is equal to admin. So I type my expression and then hit Enter, and you can see this breakpoint looks a little different. So, if I'm going to go to my application and log in with user1, it should not break. But when I log in with username equal to admin, it should break. So let's give it a try. First, I'm going to log in with user1 and password1, and I'm going to log in. As you can see, I can log in. It's not pausing. Next time, I am going to log in with admin, admin. And as you can see, nothing happens. Well, it looks like nothing happens. It's actually pausing. You can see it paused on this line, and it's only pausing because the condition is met, username is equal to admin. You may have seen it already, but we could also add a logpoint. Lets have a look at that in the next video.

Logpoints and Auto Attach
We have just seen breakpoints. Let's now have a look at logpoints. Logpoints are a variant of breakpoints that do not hold the execution of the program, but instead they log a message to the console. This is similar to using console log throughout your code but without the need to modify the actual code and rerun the code every time. To set a logpoint, right‑click and simply Add Logpoint. You'll be prompted to enter the log message, as you can see, and I'm just going to say what I want to display. And in this case, I just want to display the username. I can do that like this. So everything I put between the curly brackets is going to be evaluated as JavaScript. So in this case, it's going to be the value of username. I'm going to hit Enter. So now when our execution is going to pass, line 11 is not going to pass, but it's going to log a message. Lets log in again, and you can see that this is happening. Again, I'm going to log in with user1 and then password1. And as you can see, the execution of the program is normal, but let's inspect VS Code. All right, so let's inspect our message. You could open up the terminal and then navigate to the debug console. And as you can see, it says username:user1. This is the logpoint that logged this to the console. Another option that VS code offers is auto attach. It enables a debugger to recognize Node.js processes that are launched in debug mode. And when enabled, if you run a script from the terminal using Node, the debugger will automatically attach to it. So I can enable auto attach from the command pallet. I do F1, and then I'm going to select Debug: Toggle Auto Attach. I'm going to click on it, and we're going to hit Always. Now right now, as soon as I'm going to run a Node.js program in debug mode, it's going to attach the debugger. And that's it. Let's summarize this module next.

Module Summary
So congrats. You have completed this module on debugging JavaScript with VS Code. We've learned how to set up VS Code for debugging, and we've used breakpoints. We've stepped through our code. We've inspected the data that was coming out, and we've used logpoints and auto attach. These tools are essential for efficient debugging and understanding the flow of a program in the back end. Again, this is mainly used for back end. In the next module, we'll switch gears a bit and focus on debugging front‑end JavaScript code using Chrome DevTools. So join me to that next module and learn how to use the front‑end debugger.

Debugging Frontend JS with Chrome DevTools
Module Intro: Debugging Frontend JS with Chrome DevTools
Welcome back. Now that we know how to go about debugging the back end, it's time to see how to debug the front end. We'll be debugging the front end with Chrome DevTools. In this module, we'll explore how DevTools can help us uncover and fix issues in our code, enhance the performance of our application, and even make design tweaks on the fly. There are quite a few different parts of Chrome DevTools that I'll have to show you. So let's jump right into it with an overview.

Chrome DevTools
Chrome DevTools is the basic tool that we need for debugging the front end. It helps us understand what is going on. It's a set of developer tools built directly into the Google Chrome browser. Other browsers have very similar suites, and you can use those too. We use it to get insights into the inner workings of our web applications. You can open DevTools by pressing F12 on Windows or right‑clicking the web and select Inspect. This is what shows up. You can see multiple panes and links with options. For us, we will be using this one a lot, Elements, Console, Sources, Network, and all of those. Each of these steps gives us insight into a specific part of the application, and we can interact with the application in different ways in each of those. In the next few videosm I'll be explaining what you can do in each step and give you a practical example with use of our skills app. Let's start with the first one, elements.

Elements Panel
Every tab is meant for a specific part of the app. The Elements panel is your gateway to the HTML and CSS of your application. Want to see why that div isn't showing up where it should? Want to know why the CSS isn't applied? The elements panel can help. Strictly speaking, this is not really for debugging JavaScript. But when your front‑end application is not working, you need to know what is going on. Sometimes that can be JavaScript, and sometimes there can be a problem with HTML or CSS. We need to be able to do this when debugging the front end. All right, in order to see what's going on and follow along, you need to check out m4‑elements branch, and this one has a little intentional problem with CSS. So let's start our application and inspect what is going on. As you can see, the text in our footer is now black. That's a problem. Clearly, I know what is going on, but this is just meant to show you how to figure this out. So I'm going to zoom in a little bit in here and make it a bit bigger. You can also separate it or place it at the bottom, whatever you prefer. I kind of like this here. What I'm going to do to easily find this element in my code is I'm going to click on this arrow. So I click on this arrow and then, as you can see, it pops up a blue a little bit. And now when I hover over the page, it's going to highlight the relevant HTML. For example, when I highlight over the button, you can see that the input button is highlighted in the HTML. I'm interested in the text in the footer, so I'm going to click on it. Now, I'm going to have a look at this bottom pane. And here you can see all the CSS that applies to it. And CSS is layered, so I would want it to be white, color white. But as you can see, this is strikethrough text. You can also see that this one is overruling it. It says color black, and it even says important. So if I want to see whether turning this off fixes it, I can just click on this and toggle it off. And as you can see, the text becomes white again. So you don't see the checkbox if you don't hover over it, but there are checkboxes. So removing this part of the CSS will fix my problem. Let's go ahead and make that change. Now if I refresh the page, you can see that the color is correct. But let's enter a wrong password and inspect the error message that we're getting. Hey, I thought an error message was supposed to pop up. What's going on? Well, in order to figure out what's going on, I'm going to have a look at the HTML again. So I want to highlight this button. I'm not really sure where it is exactly, so I'll just click on the button. Then I can see that my div is actually right there. It's not showing for some reason though. And when I go over it, you can see when I go over this HTML, it highlights where it is on the page. But it doesn't do so for my div, but the message is there. So, what is up? Well, as you can see in the styles, the message is actually set to display none. When I untick this box, untick the styling, you can see that it shows up. So I would have to remove that part of the CSS to make it work or alter the JavaScript to set the display to block. This element step can be used for a lot more. For example, when you dynamically generate all of your HTML, you could also see whether it looks as what you want it to look like in here. And I can even go ahead and toggle certain things in here as well. And I can also alter the HTML. For example, I can add or remove classes. I could add a class here and see what the effect is, but I could also remove the class and see what the effect is. And as you can see, when I do this, the button changes. Of course, it only changes for this look on the application. And as soon as I refresh the page, it's back to the starting point. So if I want to alter the text on this button, I can also do that. I just go here, and I click on this one, and I set a new value. Again, as soon as I refresh the page, it resets to what's in the file. So in order to fix our last problem, I would have to remove this part of the CSS and then our code would look as what we would expect it to look like. So this is the element step. Let's have a look at a console and sources step in the next video.

Console and Sources Panel
Now, we're going to be looking at where to find the problems with the JavaScript code. We start with the console panel. It is like the console in VS Code, and you could say it's our applications diary. It logs information as our code is executed. Any console log statements, errors, or warnings are output here. If your JavaScript isn't working, step 1 is always to check the console for errors. If you want to follow along, you can check out this branch m4‑console‑and‑sources. I made two intentional errors here, and they're both related to adding skills. So let's go. Let's make sure I've started the application. All right, I'm here and I'm going to want to add a skill. So let's say my skill would be testing. But I don't see the confirmation pop up, so I'm going to navigate to the console panel. And in here, you can see an error appeared. Let me zoom in a little bit. It says Uncaught ReferenceError: addSkills is not defined. It's also telling me where to look. I need to check out skills.js line 58, so let's go there. Okay, so on line 58, I'm calling addSkills. And as you can see, the function that I intend to call is in line 63. It's not called addSkills; it's called addSkill. So in order to resolve this, I need to remove the s, and I need to call addSkill. So, let's see if we get any further now. So I'll clear the console, and I can do that with this button over here. I go out and I refresh, and then I'll try to add the skill again. This time, I get the notification Skill added successfully. So I'm going to view my skills. But as you can see, something weird is happening here. It's not adding testing; it's adding object Object, but there's no errors in my console. And this is where the Sources panel comes in. In the Sources panel, we can view all files loaded by our application and set breakpoints for debugging, much like we did in VS Code. We can also step through the lines and inspect the values of the variables. So let's navigate to the Sources tab. And here you can see the files that are loaded. So you can see I have my JavaScript file in here, and it scales the JavaScript. So lets put a breakpoint on line 58 because that's where I'm calling the addSkill function. I'm going to just continue to try it again. Over here, I'm going to add as a skill Debugging. We're going to click Add Skill. And as you can see, it says now paused in debugger, and the line 58 gets highlighted. Much like in VS code, I can go ahead and see what's going on inside my application right now. Here is the local scope and the global scope, and I can see which variables are defined in here. Also, when I hover over certain elements, I can see what's going on with them. I could also add watch expressions in here, and that would be, for example, variables that I want to keep an eye on. For now, I'm just going to keep an eye on the scope and see what's happening when I'm stepping through. Again, like in VS Code, I can just continue execution. I can step over, which will bring me to the next line. But in this case, I want to step into. And that brings me to the add skills. As you can see, my local scope just got updated. MessageDiv is undefined. That's going to change as soon as I step over to the next line. You can see that messageDiv right now is a div with the ID message, and it's an HTML object holding the files I would expect. So let's step to the next line and see what's my skill name because that's where it's going wrong. And as you can see, skillName is the input skill‑name. So this is not a string yet. It's actually a whole HTML object, and that's where it's going wrong because it's passing in the skill name on line 74 as part of my body. And instead of passing in a valid user type, I'm sending the full box over. So in order to fix this, I now realize, oh, wait a second. I need to grab the .value there. For stepping through and carefully inspecting what's happening throughout the steps what the values of the variables are, I realized I forgot to do .value on this one. So using the Sources tab can help me to step through the code much like we have practiced in VS Code. Many mistakes can be found this way. Let's see how we can debug any connection and with external APIs in our Network tab next.

Network Panel
Are certain elements not loading or is your application slow to load? The Network panel can provide insights. It logs all the network activity, showing the time each resource took to load and the order in which they loaded. You can view headers, responses, and cookies for each request. For instance, if our skills app was loading slowly, we could check the Network panel to identify bottlenecks. Also, if some requested the back‑end field, we can see it here. If you want to follow along, you can check out the m4‑network branch. All right, lets start the application, and lets try to add a skill. All right, so I want to add the skill Debugging, but nothing is happening. Let's do step 1. Let's check the console. In the console, we can already find some hints as it failed to load resources, and we get the error Not Found. All right, let's move over to the Network tab and see what happens here as soon as we click Add Skill. As you can see, we get status 404. So typically, any in 400 means that we did something wrong. We could have made a Bad Request 400, which could be because we send in the wrong parameters. But a 404 means that we cannot find the endpoint that we are calling. So if you want to get more details, I can click on skill here, and I can see what the request URL was it called exactly. I could see it was a type POST, and I could see the reply I got was a 404 Not Found. If I go to Payload, I can also see what it sent along, and I can see it was sending the skill Debugging so that all looks fine. But then as soon as I go check out the response, you can see it says cannot post to this endpoint. So let's check our server and see why that would be the case. So if I go here and I go to the post endpoint for skills, I can identify the problem because as I can see on line 38, it's skills and not skill. So, I'm calling the wrong endpoint, and that's why the error occurs. So as soon as I start calling the right endpoint again, I make sure to refresh before I give it another try, you'll see that it starts to work. It says the key was added. And as soon as I checked the list at the bottom, you can see Debugging was added now. Also, in the Network tab, you can see that now I got a 200 status, meaning it was successful. Looking at the status code tells you a lot. So anything in a 200 is successful, 400 is typically a problem with how you're calling it from the front end, and anything in a 500 is typically a problem on the back end. When you see a 500 error, your first step is to go back to VS Code, check the console in there, see if any errors occurred. So that's the place where your debugging calls to the back end. For debugging speed and efficiency, we can find more details in the Performance and Memory panels.

Performance and Memory Panel
Performance and Memory panels offer more granular insight into your app's speed and efficiency. The Performance panel helps us identify runtime performance issues such as slow JavaScript execution. The Memory panel is great for spotting memory leaks that can slow down or even crash your application. Memory leaks can occur when our code accidentally holds onto memory that it no longer needs, causing the browser to slow down or even crash. For example, if our skills app was slow to respond when loading the skills, we could use these panels to identify and diagnose the issue. In order to follow along, you can check out branch m4‑performance‑and‑memory. All right, let's start it. As you can see, when it renders the skills page, it takes a second there before it shows the skills. Let's see if we can figure out what is wrong. We navigate to the Performance tab. And as it mentions, click the Record button to start a new recording. So I'm going to do just that. And now I'm going to refresh the page. I'm going to stop the recording. And now we have a bunch of graphs. So, in the summary, I can already see a lot that's going on. The scripting is taking really a lot of milliseconds. Of course, that's not even a second, but that's pretty slow for a JavaScript script. So in order to find out what's going on, we need to inspect this more. Here we have some graphs that give us some ideas. And as you can see, this is quite a big chunk. So if I open it up, you can see what was happening here. It's an anonymous function. But luckily, it also mentions the line this is on. It's on skills.js 109. That function is taking really long apparently. So in order to figure out why our application is loading so slow, we need to go right there. And yes, there it is. It's an anonymous function that starts on line 109. And as you can see, there is a very useless loop that's calculating the square root of lots of numbers inside another loop. There's actually a little bit more that you can see in the Performance tab. What's very useful is the feature that shows the screenshots. I can hover over here and I can see what was happening on the screen at the time that it was happening. As you can see right now, not a lot is happening. With all the things that happened, you can click on them and then see what was happening exactly at that very moment and how long it was taking and why. You can also see the timelines of the Network tab here. For example, you could see that skillList.html was loaded, but also that the api/user/skills was being called and that the style sheet was loaded. All the things that happened can be found here too. For this one, the bottleneck is very clear. It's this function call. In the Memory panel, we can take a snapshot of the heap to analyze memory usage. A heap snapshot provides a snapshot at a point in time of the memory that the JavaScript engine is using. If we take a heap snapshot before and after loading the skills page, we can compare these snapshots to see if memory usage increases significantly. In our example, thats not going to be the case because the memory that we using online 113 up to 116 is going to be released by the time we load the page. So lets take a first snapshot. And as you can see, we're currently having 1 MB roughly. When I take a second one, you can see it's a little bit bigger, but it's still very similar. And then if I take another one right now, you can see it's exactly the same. If I were to move this outside of this loop, that would change things a little bit. I'm just going to paste this at the bottom of our script so that needs to hold on to these values. So if I load the page again now and then take another snapshot, you can see it grew massively. If I want to know what object is to blame, I could go ahead here and sort them by size, and I could see that this one here is my problem. I am suspecting this is too big for me to open up. But the smaller ones I can open up and go ahead and inspect. If I want to get a different overview, I could also move on, for example, to the statistics one over here. And you can see that the JavaScript array is really, really big over here. If I want to know whether is a problem on just this page or it's also appearing on other pages, I could head back here and then take another snapshot. So these panels, they're not silver bullets. They're tools to help us narrow down potential issues, and their effectiveness depends on the complexity of the code base and the specifics of the issue. But with practice, you get the hang of how to use them to diagnose and address performance issues in your application. In the next video, we're going to have a look at the last panel, the Application panel.

Application Panel
Time to discuss the last panel, Application. The Application panel is your one‑stop shop for inspecting all data related to your web app. You can inspect and modify IndexedDatabase or Web SQL databases, local and session storage, cookies, cache storage, and more. I'm actually back on the main branch right now, and let's start our application. Let's inspect the Application panel and see what we can do there. So let's navigate to the Application tab. And as you can see, I have all sorts of options here. Currently, I'm in the Local Storage panel. And if I go ahead and I log in, you'll see some values up there right here. You can see that the current user is stored and so is the session ID. Of course, it's not a good practice to store the password. But for this demo example, we can use the current user on the front end to, for example, save certain settings. We also have the session storage that's going on, but in our case, it's empty. We're also not using the IndexedDB or the Web SQL one, but we could edit this on the fly as well. So something that you would want to do here rather often in between tests is go ahead and clear the storage of the website. So you can go ahead here and say Clear site data. And then, if I navigate to Local Storage, you'll see that it's now empty. And that's going to be a problem because as soon as I want to add the skill, it redirects me to the home page because I'm not a logged‑in user anymore and there's no value for session ID for me. And that's it. Those are all the different parts of Chrome DevTools that we'll be using for debugging our Node.js and our JavaScript front‑end applications. Let's wrap up this module in the next video.

Module Summary
We're quite a step further for debugging JavaScript in the front end. We've now explored the main tool, Chrome DevTools. We've seen all the panels we'll need to debug JavaScript and understand the problems they solve and how to use them in practice. We've been inspecting HTML and CSS elements in the Elements panel, debugging JavaScript with the use of the console and Sources panel, analyzing network activity with the Network panel, and we've been checking performance and memory usage and inspecting the application data. You might realize it at this point, Chrome DevTools is going to be your go‑to on a daily basis when spotting what's up in your application. In the next module, we're going to use Chrome DevTools and see VS Code breakpoints a lot. We're going to have a look at common errors and how to identify and fix them.

Finding Common Bugs
Module Intro: Finding Common Bugs
Welcome to the module Finding Common Bugs. In this module, we'll be focusing on common problems that can occur in our app. And there's a lot of common problems that could occur. We'll see some examples of some common bugs. We'll see reference and type errors, logical problems, undefined behavior, browser compatibility, performance, page loading, and timing issues, failed requests to the back end, failed imports, problems with UI events, callbacks, promises, and async/await issues. In order to do all this, we'll be using mainly Chrome DevTools and some VS code for debugging our skills app. Debugging can often be scary and hard when you're just starting, but let's jump in together, and I'll show you some clues of where to look for the most common bugs.

Reference and Type Errors
Let's start with the most common ones. In the process of coding, especially when you're new to it, one common issue is the reference and type errors. Reference errors occur when we try to use a variable or object that hasn't been defined yet. Type errors occur when we misuse a certain data type. Let's see how to fix the type error. You can check out branch m5‑type‑error to follow along. We're going to be checking the console and then solving the problem. Let's start by checking out the branch. And now lets start our app. When we navigate to the admin page, we'll see that the user list is not populating. As always, the first step is to check the console. And as you can see, we're having a type error in here, and this type error is leading us directly to the problem. To be more specific, we actually have two type errors, one in the admin.js file on line 11 and the other one on line 58. Both of them seem to resolve around userSelect. So on line 58, userSelect.appendChild gave a type error. If we scroll up a little bit, we can see the userSelect was passed into the populateUserList. So when we scroll to line 11, that's where we can see the other type error. And we call the populateUserList on line 7. So, it's likely that something went wrong with the userSelect on line 3, and we're not allowed to call appenChild on this, for example. Also not allowed to call addEventListener. Why would it be? Well, not very often it has the comment with the exact error on top of it. But as you can see, we accidentally called the .value on here. So once we remove the .value and then go back to our application, we now actually have an HTML object again, and we can do all these things we tried to do such as addEventListener and appendChild. So now I'll refresh the page, and you can see our user drop‑down is populated, and the type error is gone. All right, let's move on to another common problem, reference errors. We're going to be fixing a reference error. And again, our approach is going to be similar. We're going to check the console and then fix the problem. We're going to check out branch m5‑reference‑error. And imagine we're trying to work on the list of users in the Admin panel. First I log in, and then I navigate to the admin page. And as you can see, it's not working again. The drop‑down list is not being populated. So, let's start with checking the console again. And this time, we see the error ReferenceError: usersLit is not defined, and this occurs at line admin.js:45 so let's go there. And as you can see, we accidentally typed usersLit instead of usersList. So let's go ahead and fix that. If we now refresh the page, you can see that the list is populating and our console error is gone. These errors can also be more sneaky. If you use JavaScript in non strict mode, you can use variables that you didn't declare explicitly. And then, a typo might cause a whole different problem. Here we see an example of where we're not using strict mode. But in line 8, it is something that should be a little problematic, also on line 3. So, we specify a total without the let keyword and we return the total. We store this in result on line 7. And then in line 8, we try to log total that's out of scope because it's defined inside the function. Since we're not using strict mode, this will actually work. As you can see, it prints 30, which is the value of total. But let's say that we were calling this function again, and then we store a different value in total. Then the console is going to print something fully different so that's definitely a problem that we want to see. Otherwise, we get some sort of logical error that we don't get instead of a reference error that we would want to get. So as you can see, when we enable strict mode, you see that it says total is not defined on line 3. So, let's start by adding let here and run it again. Again, you will see the total is not defined, but this time on line 8. And this is where we make the actual hiccup we should have resolved here. And then if we run it right now, now it works just fine. And you can see that the value is 30 again. And that's one of the reasons why you want to use JavaScript in strict mode because getting a reference error or a type error is actually quite helpful. Without those, we could get a logical problem, and those require a different approach. And that's exactly what we going to have a look at next. We; see logical problems and how to tackle them in the next video.

Logical Errors, Undefined Behavior, and Browser Compatibility
Logical errors often don't cause any console errors that point you in the right direction. All you see is that the output is not what you would expect. These types of errors are typically caused by incorrect logic or wrong assumptions in your code. We're going to see a logical error, and we're going to need an approach for solving it. This error is not going to stop our code from running, and it's not going to show anything in the console. We're going to set breakpoints in the Sources panel of Chrome DevTools, and we can then inspect the code's flow and state at each step. Finding the incorrect logic, we can then correct it in our code. We're going to check out m5‑logical‑error. Let's start the application. We're going to log in as a regular user so we don't have any admin rights. But we see a problem occur. The admin page is showing up in the navbar. And even worse, I can even navigate there. As you can see, in our console, there's no error showing up. So instead, we're going to move to our Sources tab. What you can also see is the admin page is not visible here. So I'm going to go back to My Skills, and this is where the admin page is visible. I'm going to be opening up the JavaScript, and I'm going to set a breakpoint at the function that should be showing or hiding the element in the navbar. There we have it. So, let's refresh this page and see if we even get stuck on this line, and we do. So we can now go ahead and inspect what's going on. So we have our local scope right here, and I'm going to step over to the next line. As you can see, in the user, it now stored our values. So let's go ahead and see what's going on inside the user. And as you can see, isAdmin is set to false. Clearly, normally, you would not have your password right here, but this just returned the full user object and we stored it in our local storage for demonstration purposes. But as you can see, isAdmin is false, so that's not a problem. Okay, so let's go ahead and let's move to the next step. We select the navbar. So this if statement should be false because in this if statement, we are appending the admin page. Once we step over, we can actually see we end up inside this if statement. So this is where it's going wrong. Inside this if statement, the logic is a problem. And indeed it is because we're saying if the user or user is admin. So user is going to make it a truthy object because it's not undefined or null or something. There's actually a user object in there set to true. So, true or false comes down to true, and that's a problem. Those should be ampersands and not the pipes. Now that we found our problem, we can go ahead and fix it in our code. Move back to the browser and render the page again. As you can see, again, we get stuck on this endpoint. But this time, we actually don't get into the if statement, and the admin page is not showing up in the navbar. Undefined behavior happens when the code's outcome is unpredictable due to gaps in the code's logic. One typical scenario is forgetting to define a particular event or action in our application. We're going to have a look at a simple demo. We're going to click a button that's not going to be working. And our approach to solving is going to be similar to what we just did. This time, we start in the Elements panel because we want to see if any event listeners are attached. We have the Sources panel as a backup plan, and we end up fixing our code. All right, so we need to check out the branch m5‑undefined‑behavior. I already have it checked out. So in this branch, we try to add a Delete button to every skill. Let's see how that's going for us. Let's log in as user1 again. And as you can see, every skill now has a Delete button. But when I click it, nothing is happening. So the first step would be to check out the Elements tab. I'm going to select one of the buttons, and I'm going to navigate to the event listeners. And as you can see, nothing seems to be connected here. So that's already a really good clue that this is not working. Sometimes, however, it can be a bit vague to see what's really going on. And now we still have the Sources tab as a backup. So in here, at the very bottom, we have a deleteSkill function. So I'm going put a breakpoint on here, click those buttons, and as I can see, nothing is happening. So that should be a clue for me, hmm, I should have a look at where I added that event handler. So let's have a look at that. Where did we add that event handler? Well, it turns out we didn't. So, let's make sure that we add the event handler to the click so that now the Delete button is actually connected to the deleteSkill function. And then now when we refresh, you can see that we can actually end up in this function. And if you step through it, the elements get deleted. So let me repeat without a breakpoint. When I click on this, you can see it gets deleted So what's not implemented yet is that it's also deleted on the back end. So when I refresh it again, all my skills are back. So this was a very easy fix. We did not add it all together. But it's also possible that you, for example, misspelled the ID or that to actually execute the function when you assign it. So now you might think that I'm assigning the deleteSkill function to the onclick, but I'm actually specifying the return result of deleteSkill. So what happens when I call deleteSkill? That should be defined or to click, and that is undefined because the deleteSkill does not returning anything. So make sure that you don't need parentheses in the back. And if you do need them in order to set, for example, some parameters in, make sure that you put it inside an arrow function so that you can actually not trigger the function upon assigning it as an event listener because that's not working. Let's talk about another common bug that you can get reported, but then doesn't seem to occur on your computer and you cannot reproduce altogether. It's quite likely that, as a developer, you don't have an old browser on your computer. But your end users will have all sorts of browsers. So consider a scenario where you've used somewhat newer syntax. I vividly remember that at some point I used the ES6 syntax array includes, but then we got reports from users that reports that the app was not functioning properly, and we couldn't reproduce the problems. So, we ended up screen sharing with one of the persons that reported the problem. And by looking at the console logs and DevTools, we saw that there was an error regarding an unsupported method. So at that time, we replaced the array includes with the more compatible array indexOf. So here you have the array includes. And if you scroll to the very bottom of this, you can see the browser compatibility. At this time, it's very much all right, and there's no problems. With anything that you use, you can check the browser compatibility to make sure that it's supported. Here's another great website, caniuse.com. So let's say we still are at the array includes. And as you can see, most browsers support this, but definitely not all of them. So always make sure that you get the browser of the reporting person, and don't beat yourself up if you forget this. It's happened to me and actually more than once. But I ask for it a whole lot sooner now, and I'm happy if it's a standard part of the bug report because it can really help you to find the problem sooner if the browser version is included in the bug report. Let's talk about a very different topic in the next video, performance.

Performance Issues
Performance issues in our application can occur for a variety of reasons. Sometimes it's due to inefficient code that doesn't execute as quickly as it should. Other times, it's unnecessary computations that are slowing things down. One particularly tricky cause of performance issues is a memory leak. A memory leak happens when a program continues to hold on to memory that it no longer needs. In JavaScript, this often happens because an object still has a reachable reference, preventing a garbage collector from reclaiming the memory. So, what is this garbage collector you may wonder? The garbage collector is an algorithm that runs and cleans up objects in JavaScript that are no longer used. And they can tell it's no longer used if there are no references to this object. In JavaScript, memory is automatically allocated when things are created, like objects or variables, but it does not automatically get deallocated when it's no longer needed. This is what a garbage collector does. When an object or a variable is no longer reachable, meaning that there is no way for the rest of the code to access or use it, it's considered garbage. So, this garbage on the memory is removed by the garbage collector. It's its job to periodically check for this garbage and deallocate the memory that was used to store it. This prevents memory leaks and helps ensure the efficient use of memory in our applications. So, when references are held unnecessary, over time, these leaks can cause the app to slow down and eventually crash as they accumulate and consume more and more memory. And that's simply because the garbage collector cannot remove it when there is an unnecessary reference to it. Let's consider an example of a memory inefficient snippet. This code has generating a large amount of data that's being stored in the data array. It's a big array of big arrays. If this data isn't being used later on, it should be cleared like so, data = null. This removes the reference to the data object on the memory and allows the garage collected to free up the memory that was being used to store the data. However, if we forget to do this or if something in our code is unintentionally keeping a reference to data, we've got a memory leak. Let's demo how to spot them. We're going to assume a problem with our app. It's running slower than expected, and we suspect a memory leak or an inefficient function. This is where the Performance and Memory panels come into play. All right, let's start by checking out the correct branch, and that would be m5‑memory‑leak. And as you can see, some things changed in admin.js, and that's that I added an array that will be causing a memory leak. Again, this is way more subtle and difficult in real life. But this will demonstrate an example of a memory leak. It's a very small one though. So we create this element array, and every time where we create an HTML element, we push it to the array, for example here. But we never clear this array. So the more we use our application, the more and more elements will be living on our array. Let's start the application and see how we could notice this. I'm on the admin page. And as you can see, I'm in the Memory tab. So I'm going to start by creating a snapshot of the heap. And in this snapshot, there's a lot of information available. For example, we see all the elements that are alive in our application, but we can also check the statistics. And as you can see, in this pie chart, there are certain things that are being represented. So we have the code, we have strings, we have JavaScript arrays, which is a very small part. We have typed arrays, and we have system objects. Again, I'm not going to create a memory leak that's going to slow down the application notably, but I'm going to show you how you could find it. So let's go back to the summary, and let's use this application a little bit. Every time I select something from this drop‑down, all the list items get added to the elements array and they never get cleared up. So that elements array is only getting bigger and bigger and bigger. So I'm just going to click on this a few more times, and then I'm going to take another snapshot. It's going to be the same size because this is only very small data, but I'm going to show you what we can do here. So again, we could look at the statistics. And you can see, the JavaScript arrays is still very, very small, but there is one more option right now, and that's comparison. And that's great usage here. And what you can see is that in the comparison, we can see the difference between snapshot 6 and snapshot 7. So what we see right here is that, for example, we have a lot of detached li elements, meaning elements that are not longer connected to the DOM but that we do have in our heap. These are all the drop‑down list items that I created, and this is giving me a clue that something is wrong here. It's a memory leak. Even though we would not notice this in terms of performance, it definitely is one. So when your application is slowing down, you could also go here and create a snapshot, use your application for a little bit, and then create another snapshot. So if I go back to Summary here and then instead of all objects, I just want to see the new ones, I could do that too, and here I could see what's being added. And that's a great way of seeing what is causing the memory leak and what's going on in your code. Again, at this point, you probably wouldn't even start to debug because you don't notice that there's a problem. The Memory tab and the Applications tab can be very hard to use, but they're essential for keeping our apps running smoothly and efficiently. So, remember, the best way to get comfortable with them is through practice. Don't hesitate to dive in and see what you can find. Just use them in your projects and you will get better at it.

Loading and Timing Issues
Page loading and timing issues can drastically affect the user experience. If a website or application is slow to respond, users may become frustrated and leave. This problem often arises because of resource‑heavy applications where loading large files like images or videos can cause significant slowdowns. These issues often arise from heavy resources, server delays, or inefficient load order. We can use the Network tab to inspect the load times of different resources. Finding that a large image is slowing down the page load, we could opt to compress the image. Or if we need it in its size, load it asynchronously to enhance the page load speed. Let's check out a new branch that demonstrates this problem. There's going to be a sudden increase of the loading time. We updated the login page to contain a nice picture, but this resulted in an increase of the loading time of our skills app. In order to debug this issue, we used a Network tab in Chrome DevTools. First, we need to reproduce the problem, so we start by loading our application. Make sure the Disable cache option is checked to ensure we're not loading files from the cache. As the page loads, we can see all the network requests that are made by our application. We'll notice that the specific image is taking a significantly longer time to load than other resources. To solve this problem, we could opt to compress the image. Compressing the image will reduce its file size, which in turn reduces the load time. Once the image is compressed, we can replace the original image with the compressed one and reload the page. All right, in order to follow along with this demo, please take out branch m5‑loading‑time. So as you can see, I've added an image to our home page, and it looks quite good. The image is showing. And if you look at the Network tab, you don't see any issues with the loading time. If I refresh, you can see it doesn't take long to load. But cache is enabled right now. I'm going to tick the box Disable cache and reload the page again. And as you can see, the image now showed up a little later, and it's taking a lot longer for the image to load. Still, it's not too pressing, which you can imagine if you have many images like these or even videos, this could definitely be a problem. So whenever you check the Network tab, please make sure to always disable cache. So there's one other tab where we actually also can get some insights, and that's the Performance insights tab. In here, I'm now going to record and then refresh the page and stop the recording. And you can see that in the insights, it is showing some problems. So the render blocking request, this is about loading my styles.css and my login.js. I could make that async to solve it. But here's an actual problem. It says long task. And if you click on it, it's a little vague. But based on the insights from the other tab, I know it's my picture. So what am I going to do right now? You can see that the total time is 0.44 seconds at this point. Well, my image is unnecessarily big. So what I'm going to do, I'm going to add the compressed here because I have an other image ready, which is the same image a little bit smaller. And now with the compressed image, I'm going to press Record again, refresh the page, and press Stop. And you can see that now it's done in 0.03 seconds. What a major improvement. And you can also see that the long task that it rendering is now gone. So that's how to deal with long loading times, inspect them, and see if you can make it either async or use a smaller resource. This last one is actually very easy to fix ,and it gets you a major improvement. So let's see how we can use the Network tab in another way, namely to identify a failed request.

Failed Requests
In today's web applications, we often need to make requests to a back‑end server to retrieve or update data. This communication between the clients, the front end, and the server, the back end, is typically done with APIs, the application programming interfaces. However, sometimes it doesn't go quite as planned, and we encounter a failed request. So a failed request can occur for a variety of reasons, including network issues, incorrect API endpoints, server errors, or misconfigured requests. We encounter a failed request in the m5‑failed‑request branch. To debug this issue, we can use the Chrome DevTools and we start with the console. Then, if that doesn't help us enough, we navigate to the Network panel. We inspect the failed request, and then that should give us clues to fix the problem. So let's check out a failed request branch and start the application. I'm going to log in to the website. As you can see, it doesn't let me. So let's inspect the console first. And as you can see, there are some serious problems in our console. It says Failed to load resource with a 500 status. If we'd like to see more information about the call that was made, etc., I can go here and inspect the message. So you can see it gives a 500 message. And here I can actually also see the endpoint that I'm using. It's the api/user/login. Since it is a 500 error, it means that it's going wrong on the server side of things. So let's inspect VS Code to get more information. So I always like to scroll up to the top of the stack trace first. And here you can see it says SyntaxError: Unexpected token : in JSON at position 30. And you can see, I'm using that line from the readUsersData function, which is in the server.js at line 14. So let's first go there, see what we're doing there. So I go to my data.js and then scroll up to line 14. And as you can see, on line 14, I'm parsing JSON. And apparently something's going wrong with parsing the JSON file. What path is it was the users file path. And in order to figure out which one that is, I scroll up a little bit. And at line 5, you can see that it's users.json. So we go to users.json, and you can see something is wrong here by the syntax highlighting. So what's going wrong? Well, I have an object. And in that object, I have a key value pair. The key is an array, and it's an array of objects. If I scroll down a little bit, you can see that the syntax highlighting is going well here, but it's having a problem right there. And that's because I forgot to have a opening curly bracket right there. So that's fixed, and you can see that the colors go back to normal. Normally, when I need to make a change to my server, I need to restart. This time I've only changed JSON, so it doesn't need to reload anything. I can go back here and try to log in again. And as you can see, this time I'm successful and I can log in. Let's talk about something else that can fail, namely the imports.

Failed Imports
JavaScript development often involves splitting code into separate modules to keep it organized and maintainable. These modules can then be imported where we need them using import statements. You can also use external libraries with these import statements. However, sometimes these imports can fail, leading to errors. This failed imports often occur due to incorrect or broken import paths or when the module or the exported value do not exist. This can happen because you still need to install all the dependencies, for example, with npm install. Another possible cause is when there are syntax errors in the module that's being imported. In the branch m5‑failed‑import, we added a new module. But after importing the module, our application is broken. Here's how we're going to solve that. As always, we're first going to check the console, and that should give us enough information to check the import in our code. We'll check if the module is available, and then we'll fix the problem. So I've checked out the branch m5‑failed‑imports. And if I now want to start my application, you see that it runs into a problem. It says module is not found. So I'm going to scroll up a little bit to get some more details. And you can see that a module newFeature, but then spelled in a very original way, is not found. To debug this issue, we now open our app.js, and I scroll up to where I'm importing that new feature. And as you can see, I do have a new feature module, but it's spelled in a different way. So if I fix this spelling and then try again, you'll see that this time it will work, and it won't have a broken import. Let's debug a very different problem. Let's see how we can debug the handling of UI events.

Problems with UI Events
In any web application, user interactions, like clicking a button, typing text into a text field, hovering over an element, or submitting a form, are managed by what we call UI events, user interface events. These events are very important to create responsive user interfaces. JavaScript listens for these events and executes code when they occur using what we call event handlers. Sometimes, however, these event handlers can be a source of problems. They might not be set up correctly, or the code to execute could be faulty, causing some unexpected behavior in your application. Let's debug the problem that a button is not working, and here's how we're going to solve that. First, we're going to see the event listeners in the Element panel to see if it's even connected. Additionally, of course, we'll check the console and Sources tab for debugging. We'll then identify the problem and solve it. Let's start by checking out the right branch, and that will be m5‑ui‑events. Let's start the application. Let's log in. I'm going to log in as admin right here, and here are my skills. I want to add some skills. So I'll start by adding debugging. Next, I will add testing followed by Java. And finally, I'll add coffee drinking to the list. I then go to View Skills, and I notice something that's a little off. You can see debugging that went quite all right. This was added once. Testing was added twice for some reason. Java was added four times, but I do love Java a lot. And then coffee drinking was added eight times, which admittedly, I really like a lot too. But that's not what I intended to do. What's going on here and why? Well, in order to debug this, I'm first going to check out the Elements tab. I'm going to go to Add Skill over here, and I'm going to click on my add skill. I then want to see what event listeners are assigned. So I navigate to the Event Listeners tab. You can see there's one submit right here. So, well let's just add one more for testing purposes. Rephrase, so let's add one more skill for testing purposes. And let's then after that add one more. And you can see that the submit event here has been added. So that seems to go quite all right. So then what's going on? Well, in order to get more information, we're going to navigate to these Sources tab, and we're going to find that submit event. And I'm going to put a breakpoint right here, and I will also put a breakpoint in my add skill function. Then I go ahead and I add yet another value. Let's add C# to our list of things we can do. And you can see that it goes to the handleSubmit. And in the handleSubmit, it's going to trigger the addSkill. So I'll step to the next line, and that seems to go quite as planed. So I continue, and that brings me inside my addSkill functionality. So let's walk through this. We're adding the skill, and that seems to go all well. So I just seem to continue here. So you can see that then I end up in the handleSubmit yet again, and that's a little weird. Why am I ending up in this handleSubmits multiple times? So I'll just continue, brings me to the addSkill, and then I end up in there again. So that seems to be inline with what we are seeing in our pages added multiple times. Apparently, the handleSubmit event is triggered very often. Why would that be? Well, in order to figure it out, let's debug this a little further. So I'm going to use the step into for this. So adding my skill, sure, getting the message of the skills name, fetching the details. And then in here, I'm again inside this handle. So I'm just going to keep on stepping through until I'm done to see if anything special occurs. And as you can see, nothing notably special is occurring right here. But I do have a really good clue at this point, and that is that I'm adding the event listener, for some reason, multiple times. So where am I adding the event listener? Well, I'm adding the event listener here, so let's put a breakpoint on this line. So then let's go at yet another skill. So let's add Python to our list. I'm going to remove those breakpoints because I'm not too interested in those anymore. And I'm going to continue. You can see that I go here. I end up on this addSkillsForm.addEventListener, but why? Well, in order to figure that out, I want to see my call stack. And you can see that the handle page gets called in the handleSubmit on line 65, and that's correct. On line 65, I'm triggering the handle page. And in my handle page, I'm not only reloading my page, but I'm also adding the event listener again. So that is what is going wrong. So how to solve that? Well, if I need this for refreshing purposes, I need to make sure that I'm not adding the event listener in the exact same function. So I'd have to split up my function better. In this case, I don't even need this for refreshing purposes, so I can just go ahead and comment it out to solve a problem. So in this very specific situation, what's going wrong is a very common problem, and that's that you're adding an event listener multiple times. And this will fix it because now I'm not adding event listeners upon every add skill. That it is not going to double the amount of event listeners connected to my form every time I submit it. All right, it's time to spice things up a bit. The next two problems are slightly more challenging, and we'll be dealing with asynchronous code. If you're a beginner, please do not worry if you don't understand this fully yet. That's not meant as a discouragement by the way. But I just want to let you know that it's totally normal to not be there just yet. But just let's go, and if this is new to you, at least you've taken your first steps. So what are we going to do? We're going to have a look at debugging callbacks, promises, and state.

Problems with Callbacks, Promises, and State
So as JavaScript developers, we often deal with asynchronous operations such as fetching data from an API or even setting timeouts. Asynchronous code means that JavaScript fires the operation but then continues executing other lines of code. It's not going to just sit and wait for the result. When the asynchronous operation is done, this is handled using callbacks, promises, or the async/await syntax. Callbacks are functions passed as arguments to be executed later, while promises represent a future value. They will not be explained further here, but there's a lot of courses that deal with those. So these asynchronous techniques along with managing application state allow us to create interactive and responsive applications. However, they are a common source of bugs and also a common source of confusion due to their async nature. Debugging those is really something different because you cannot assume a certain value is there yet. And the order of the lines of code becomes unpredictable too. So let's have a look at an example. We're going to be fetching skills and assume a value in the then block gets set. And this is our approach to solving. We're first going to check the panels and then identify the problem and fix it. All right, let's go ahead and check out the m5‑async‑order branch. And lets start our application. Okay, I'm going to log in first, and I'm going to add a skill. And in the console it will print whether I added the skill or not. So I'm going to add testing as one of my skills. And you can see, it says Was the skill added? false. However, if I navigate back to my skills, you can see it was added. So what's going on here? Well, let's move to the Sources tab and put a breakpoint where I'm adding my skill. So I'm going to put a breakpoint here where I'm saying skillAdded is true. And I'm going to put a breakpoint here when I'm printing this message. Let's just add another skill, debugging. You can see the first thing it pauses at is at Was the skill added? And if I then continue, it then actually ends up in the skillAdded is true. Why is this happening? Well, the then block is not executed before the line 93, even though the line number 93 comes after 84 where we said skill added to true. Why? Well, this is async. So the first thing it's going to do is going to send out a post request. Then when that is done, it's going to execute the first then block, which returns a new promise. And when that is done, it's going to execute the second then block. Well, by then, it has already printed there was a skill added. So outside of the then block, you cannot assume that the skill added was already set. This is a very common problem. Also, when you try to get back an array to populate your page, always do so from within the then block because that's the place where you are sure that it has been set. Of course, you can split this up in functions and then call a function from the then block. It doesn't need to be a very bulky long then block. Again, if you find this too complicated, go ahead and watch a section of a course or watch a course on how JavaScript async code is working. We're going to continue with another async problem. In the next video, we're going to have a look at the problem with the async/await syntax.

Async/Await Issues
So in JavaScript, the async/await syntax is a special syntax to work with promises in a more comfortable fashion. The coding style becomes more intuitive. It's relatively new but becoming widely adopted, and it essentially allows us to write asynchronous code that looks like synchronous code. However, despite its benefits, using async/await can sometimes lead to subtle bugs or issues, especially when not handled properly. Common issues include unhanded rejections, unresolved promises, or even issues with asynchronous code surrounding the async/await. They can be quite dreadful to debug to be honest, but we're going to give it a try. Let's check out the m5‑async‑await issue branch, and that's going to show us a scenario in our skills app when we are using async/await to handle post data to our API skills endpoints. But we've noticed that adding our skills is not working as it should. So how are we going to solve this? Well, our number 1 should always be to check the console panel. After that, if that doesn't provide any insight or not enough, we use the source panel and set some breakpoints to see what's going on. Once the breakpoints are set, we're going to reload, and it will pause the execution at those breakpoints. That allows us to step through, and we can inspect our variables and, in this way, identify and solve the problem. All right, let's start by checking out m5‑async‑await‑issue. You can see we've made our function call async. So let's go ahead and see what happens when we try to add a skill. So here are my skills. I'm going to try and add one here. Let's add Python to our list. You can see we get a console error. It says there was an error with adding the skill, and it happened at skills.js at line 79. So let's go ahead and have a look here in our skills.js at line 79. This is where it shows our error. But most commonly, you do not have to comment with what the exact bug is above. So let's go ahead and debug this. Let's set a breakpoint at the line where I'm doing the fetch, and there's something that I'm noticing and that's that I forgot to use the await keyword here. So, as a result, our response will be a promise object and not the actual response object. So when we try to access the response.ok on line 77, we're attempting to access the properties on a promise object and not on the actual response object itself. And that's going to lead to bugs. So the data variable will also be a promise and not the actual data object. So checking the data status and accessing data message will not work as expected. So let me show you what happens. I'm going to click Add Skill again. And you can see I end up right here. You can see the response is now undefined. But when I step to the next line, you can see it's a promise object, and it's still pending. The promise object does not have the okay, and that's why we end up in our error. So how to fix this? I need to use the await keyword when I'm calling the fetch, and I need to use the await keyword for the response.json because response.json is also going to return a promise and not the actual object. This ensures that we wait for the async operations to complete before proceeding. So now when we've added these changes and I go back, I'm going to remove my breakpoints and then reload the page again. Now if I try to add a skill, you can see that this skill was added successfully and that there are no console errors. So after making these changes, it is working again, and this shows how we can debug async/await with Chrome DevTools. Again, this is a very basic problem with async and await, and more difficult problems are more difficult to spot, but the approach will be the same. You set to breakpoints, and they'll help you to see what is going on.

Module Summary
And that brings us to the end of this module. We have covered a lot of bugs and issues that can keep us busy for quite a while. We've seen how to use the Chrome DevTools for debugging our app. Chrome DevTools works for front ends. So whenever we have a back‑end problem, I have to use VS code. Please mind that debugging happens through the entire software cycle from starting the code until maintenance. Improving your debugging skills will funnily enough often result in improving your coding skills as well, and being good at debugging will save you a lot of time. You're ready for the last module now. Here we'll go over some final points and best practices.

Final Points
Module Intro: Final Points
Welcome to the final module of our course. In this final module, I'm going to address some important final points. We'll briefly compare VS Code and Chrome DevTools, explore when to use each for the most effective debugging, and wrap up with some debugging best practices. So let's get started. You're almost there.

Comparison: VS Code and Chrome DevTools for Debugging
So far, we've spent a fair amount of time delving into the debugging capabilities of both VS Code and Chrome DevTools separately. Now it's time to put them head to head. VS Code is a versatile tool great for debugging server‑side code and navigating larger code bases. It offers an integrated debugging experience within your editor. And its seamless connection with your code base means you have easy access to IntelliSense, quick navigation, and code refactoring even while debugging. On the flip side, VS Code is no good for the front‑end stuff, and this is where Chrome DevTools comes in. It provides a distinctively different set of capabilities. It really shines when it comes to debugging client‑side JavaScript and analyzing performance issues in the browser. It offers a real‑time debugging environment where you can interact with the live DOM, analyze network requests, monitor performance metrics, and much more. So, which one you'll need depends on what you need to do. Typically, when you need to debug the client side, you'll find yourself using Chrome DevTools. And when you need to debug the back end, you can use VS Code. I couldn't miss either of them. They really complete each other. Let's see some best practices for debugging in the next video.

Best Practices for Debugging
As we're almost at the end of our course, let's touch upon some best practices for debugging that will help you to be more effective and efficient and maybe even eliminate the appearance of some bugs at all. First of all, creating and updating documentation. This might seem unrelated to debugging, but a well‑documented code base makes it much easier to understand functionality, making the debugging process a lot smoother. Next, adding comments to your code where it makes sense. Commenting helps future you and other developers understand what your code is supposed to do and why you made certain choices. This can be very helpful when you're trying to debug it. And very, very, very important, write test cases and unit tests. This is a proactive approach that can help you catch bugs before your code even reaches the production stage. Tests will fail, and that's when you won't push to production. First, you'll fix the problems, and this prevents the bug from occurring in production. Another in the test space would be code profiling. Profiling your code can help you identify performance issues and memory leaks that could be causing bugs or slowing down your application. And lastly, commonly, you work in a team. Utilize the power of the team and collaborate with others for debugging. When you're stuck on a bug, a fresh perspective can often help you see things that you might have missed. If you don't have a team and the code is not protected by company regulations and you don't mind it being public, you could also ask a tool such as ChatGPT for input. Sticking to these best practices can go a long way in making your debugging process a lot smoother and more productive. It even helps you to have fewer bugs end up in a debugging process.

Module Summary
All right and that's it. We've covered the debugging capabilities of VS Code and Chrome DevTools and some best practices for debugging in this final module. The main takeaway of this course should be an understanding of the significance of debugging in the software development process and knowing how to work with tools like VS Code and Chrome DevTools to debug your JavaScript. Bugs can be annoying, very annoying even. But at the same time, each bug you face is a chance to improve your skills and become a better developer. Very cheesy, I know, but it's true. You might even learn some unplanned and unexpected things in the process. And having said that, keep calm and happy debugging.