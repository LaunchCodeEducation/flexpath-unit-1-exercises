Now that we have a good understanding of functions, we can dive into another critical area of JavaScript, asynchronous programming. Let me explain that term if it's new for you. Some code executes the instant it runs. For example, think about defining a variable. Now other code may need to go and perform some other tasks and then report back when it's done. Now the first approach we would call synchronous and the latter we would call asynchronous. Within JavaScript you may use asynchronous logic for doing things like asking for user input, and this is where we've used asynchronous logic already, calling an API. Let's imagine that we were building a weather app and we wanted to go fetch the current temperature in Dubai using a publicly‑available service. We can use it for reading and writing files to the local filesystem, uploading and downloading files, interacting with a database, and interacting with an external service. You'll find that most every JavaScript application does one or more of these things, so you will need to understand how to work with asynchronous code. Now there are three primary ways that you can deal with asynchronous code in JavaScript, callbacks, promises, and async/await. Now while we have gained new ways of dealing with this as JavaScript has matured, there are still situations where you will need to use each of these, so we will be covering them all in this module, and I'll be providing a brief introduction to these different approaches here within this clip. Now I'll be using the Node.js module for interacting with the filesystem here. If any of these imports seem confusing to you, don't worry, we'll be doing a deep dive on modules very soon. First, we will be looking at the callback approach. In theory this is pretty simple. We create a function that we want to be called when the file has been written. We can assign this function to a variable using a function expression, and we'll come back to this function in a bit. Now next, we need to specify a file that we want to write to, and then we can pass in the data we want to write. We can then pass this function in as the third parameter, and it will be executed once the file has been written. If we were to execute this, we would see that it successfully writes the file and then outputs the log message. It may seem like callbacks are perfect. Why would you ever need anything else? Well, there are some difficulties that come with callbacks, especially when you need to perform multiple asynchronous tasks in a row. Well, we define the function as a function expression and then saved it to a variable, I could also have written it this way. So if I wanted to do another asynchronous task and then another, we quickly end up with something called callback hell, or the pyramid of doom. Your code becomes less readable and it can be very difficult to determine where errors are happening within these asynchronous tasks. Next up, we have promises. Now the Promise object represents the eventual completion, or failure, of an asynchronous operation and its resulting value. When working with promises, you can write logic that gets executed when the promise is fulfilled or rejected. Now rejection would happen if there was an error during the asynchronous execution. Now we aren't going to talk about errors a lot in this clip, but it is coming up really soon. So you might look at this and say that looks a lot like callbacks, and in some ways you would be right. One of the advantages is that you can chain promises together. Node.js allows us to work with promises as well for writing files. In this way, we can specify the logic that gets executed in the then method of the promise. This will execute unless there is an error. Now there is a different way that we will handle this error, but I'll cover that in the next clip. If we have another file that we need to write, we can include that in our result function. Now, we can chain these together as long as we are returning the promise. We can even simplify this code by leveraging single‑line arrow functions. Now, we can see this simplified a great deal over using callbacks nested inside of other callbacks. Finally, we have a third option, and this is the one that has become the default for modern JavaScript, and that is async/await. Now it's important to note that this isn't a different approach, it actually uses promises behind the scenes. It is really just a different syntax for working with promises, and it is a bit closer to how we work with synchronous code. Let's take a look at a simplified example of what we covered with promises. So here you can see that we are writing a file to the filesystem and then we are logging something to the console. We can rewrite this using async/await like this. In this way, the await keyword waits for the promise to resolve and then proceeds to the next line of code. If we wanted to write multiple files, we could do it like this. Just as simple as adding another line. The reason we call this async/await is that these await statements generally need to exist within a function that is designated as an async function. This means that the function returns a promise. We have been able to use await prior to this because we have been taking advantage of the capability in our version of Node.js called top‑level await. Now we have just barely covered the basics when it comes to working asynchronously in JavaScript. Over the course of this module we'll be exploring all these different approaches in much more depth. Up next, we need to cover something. Now we have made an assumption that our code all works and nothing really goes wrong, but stuff always goes wrong, and for that reason, we need to take a look at error handling.
Okay, I have to break something to you, things don't always work perfectly in your code. I know, it's difficult to accept, but it's true, and up to this point, we've only considered the happy path. This just means the path through the code where everything goes right. In any programming language, you also need to account for the things that can go wrong. What if you try to parse a JSON object that isn't correctly formatted? What if you try to write a file that you don't have permissions to modify? What if we request data from a server that is currently down? There are so many situations that could occur that would result in us having to handle something going wrong. So I want to look at two different ways that we can deal with errors, using try catch, as well as handling errors with promises. Now, while we often need to deal with error handling in synchronous code, we absolutely need to deal with it in asynchronous code because we're generally interacting with something else we don't have full control over, such as the file system or an API endpoint. First up, let's look at two new keywords, try and catch. Earlier in this course, we talked about JSON. If we pair together our ability to read and write files with the ability to parse JSON using the parse method of the JSON object, we can store and retrieve data on the local filesystem. Now using some of our asynchronous programming knowledge from the previous clip, that could look a bit like this. Let's think of what could go wrong here. First, the file might not exist. Second, the file might not be valid JSON. Even if it has a JSON extension, there is nothing preventing the file from having something completely different in it. It's also possible that the JSON might be malformed because someone chose to write it by hand, and if that's the case, our application will throw an error when we try to parse the JSON. So, how do we handle that? Well, we could handle this using a try catch block. We wrap the code that we want to try inside of the try block. Now, immediately after this block, we write another block. This block will be used to catch the error if it happens within the try block. This block has an argument, and that will be the error object that was thrown. Now we haven't talked about the error object yet. This error object has three different properties that we can use to determine what went on to cause the error, and we have name and message, along with stack. Now that last one probably isn't super useful to you yet, but the first two will be vital in determining what led to this error. So let's jump back into the code and see how we could get more information about our error. So here within our catch block, we can add some log statements to better understand the error. When we output the name and message, we can see that parsing the JSON was indeed the issue that led to the error that we have received. At this point, you could choose to do something different. Maybe you need to tell the user that you can't load the file or have the application exit. One of the great things about async await is that you could use this exact same syntax to catch the errors in your asynchronous code too. So if we had an error in reading the file, that would also get caught in the catch block. Promises work a bit differently. With promises, just like we have a then method to go in and add what action should be executed when the promise resolves, we also have a catch method that should be used and executed when the promise is rejected, meaning that there was an error somewhere in the process. Let's take a look at that one too. So I've rewritten the same logic without using async await. If I want to catch the same errors, I could add a function in the catch method of the promise object. The error object will be the argument into this function, so I can still access the name and message. I could add in my logging statements here to see why this error occurred. There is a lot more to error handling, so much in fact, that there is a whole course in this learning path to dive into the specifics. We can use the basic information I have covered in this clip to add in some basic error handling in our application to handle any unexpected scenarios that may arise.
So now that you have an overview of asynchronous programming and you're familiar with concepts like callbacks and error handling, we're actually going to get a chance to work in the code with these concepts today. And this will play an important role because we're going to add in some new capabilities here within this module to the directory application that we've been building. But the first thing we need to do is I need to introduce you to another JavaScript keyword that we haven't covered yet, and that is throw. So the throw statement throws a user‑defined exception, and execution of the current function will stop. The statements after throw won't be executed, and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the program will terminate. Now, you would use this in situations where your application simply cannot proceed. So let's say, for example, that your application stores all of its day data in a file. Well, if it can't read that file when the application is starting up, it may need to just throw an error, and that would actually stop execution of the program. It would exit, and it would report back on what that error was. And we'll be using this here as a part of our error handling when looking at callbacks. Now the next thing I need to talk about is that we're going to be using a Node.js API. So here we have the documentation for our current version of Node, which is Node 18, which is the LTS version. Now, I'm specifically looking at the API for interacting with the File system. Now the File system has two different APIs. You can see here the Promises API, but we have the original callback API as well. So if I scroll down through all of these options, you can see that I end up on the Callback API. We're specifically going to be looking at the readFile function. So here, if I scroll down to readFile, you can see that here's the function that we're going to be executing, and we're able to pass in a path, some additional options, and a callback to read a file from the local file system. So now that you understand what we're going to be doing in terms of what API we're going to be working with, you understand the throw statement, let's dive in and take a look at working with callbacks in code. So I'm here within VS Code, and the first thing I'm going to do is to create a new file. Now here within this file, the first thing we're going to need to do is we're going to need to pull in that Node.js module that I just showed you the documentation for, and that is the file system module and more specifically the callback version of the filesystem module, which, again, was the original API for the filesystem module. Now, the next thing we'll need to do is we'll need to call our function for fs.readFile. Now we need to pass three different parameters into this function. Now before we do that, I want to show you that I have a JSON file here. It actually has some employee data similar to what we've been dealing with so far, and this is contained just within a JSON file. Now this is valid JSON currently in this file. And so what we should be able to do is to read this in from the local file system and then parse it as JSON, and then we can verify that that data is correct. So that's what we're going to be doing here within this clip. Now to make that work, I'll need to pass in the file name. Now in this case, the file name, we're just going to say it's in the current directory, it's data.json. And then we have the ability here to pass in some options, and we can either pass in a string or an object here. But if we just pass in a string, it's going to be the encoding of the file that we're trying to read. And that's what we're going to do here. We're going to say that this is a utf8 file, and this is going to then pull this data back as a string. If I didn't include this value, it's actually going to return the binary data as a buffer, and in some cases, we would want that. If we were maybe working with an image, for example, and we wanted to do some manipulation on an image. But when we're dealing with a text file, like a JSON file, we want to pull this in as utf8. Now, the next thing here is that we need to pass in our callback function. Now this particular callback function is expected to have two different parameters. The first parameter is an error parameter. So if anything goes wrong in attempting to read the file from the file system, we will see that this value comes back. Now, if we don't have anything that goes wrong, we can expect that this value will be undefined. And this is pretty much the standard practice when dealing with callback functions is the first parameter is going to be an error. So you can check that when the callback function is executed. And then the next parameter is the result. In this case, that's going to be the string data coming out of the file that has been read from the local file system. Okay, so to make this work, we're going to need to check for that error. So here, I'm going to go ahead and check to see if the error is defined, and if it is, I'll log something out saying that we can't read the file. And then we're going to use the keyword that I introduced earlier, throw. Now what this will do here because we can't read the file, it will throw this error, so we'll see that logged out on the console, and it also will stop the execution of our application. And we'll test this out here in just a bit. But let's say that everything does go well. Well, what do we do next? Well, I'm going to go ahead and define a new variable, and I'll parse out the JSON. And then I'll go through and log that out, and then I'll say, hey, we've completed, we've done everything we intended to do within this application. Now, some of you might be looking at this and saying wait a minute, we haven't accounted for the fact that it might not be able to parse the JSON data. You are correct, and we'll be getting to that in just a minute. But for now, if I go ahead and run the application by hitting F5, we can see that it does pull the data back. Now you can see there's 65 different objects that are included in this array from the JSON data, so it doesn't log everything out here, but we can see that it does pull it back. And then we get our log statement saying that it is complete. But let's look at an error scenario here. Let's say that instead of data.json, let's say we were trying to do maybe x.json. Well, we know that this file doesn't exist. You can look over there in the EXPLORER in the left pane and see that it's not included. So we should get an error when this happens. So let's test that out by pressing F5, and we can see we do indeed get an error. We can see it says Error reading the file, and then we get an Uncaught Error, it says no such file or directory. And that's exactly what we would expect. But you'll notice here that it didn't attempt to parse the JSON after this. It didn't log out complete or anything. It truly stopped at that throw statement because we couldn't proceed beyond this point. Now, as I mentioned earlier, there is another scenario that we need to account for, and that is going to be the situation where we actually have a file that gets read in, but it can't properly be parsed as JSON. Well, in this case, we're going to need to create a try catch block. So instead of this code that you see here, instead, I'm going to replace this with a try block, and we're going to include all of that logic that I had previously inside of this try block. And then we're going to add in our catch block, and we're going to do something very similar to what we did if we had the earlier error. So here we'll log out and say that we cannot parse the JSON from the file, and then we'll go ahead and throw that error. So we can test this out as well. Now, first of all, this should work perfectly if I leave everything the way it is right now, and we can verify that by pressing F5. And indeed, everything does work properly. But let's say I were to go into this file and instead of it's starting here with an array, let's say I just added in some random symbols. Well, we know this is no longer valid JSON. So now if I go back and I were to execute this again, what we would see is we actually get another error that's thrown specifying that we cannot parse JSON from the file. Now, this is a good example of working with callbacks in general. We're able to go out and get something asynchronously, in this case, reading a file and then execute a callback function when that's completed. But as I mentioned to you in one of the earlier clips in this module, there are times when nesting a lot of callbacks together can become confusing, and that's one of the many factors that led to a more modern approach for dealing with asynchronous code, and that is promises. And that's what we're going to be covering in the next clip.
So next we're going to dive into working with another asynchronous programming concept in JavaScript, and this time it's going to be promises. And promises are an essential element of modern JavaScript development. So let's not waste any time. Let's jump right over to VS Code. So here within VS Code, I'll first create a new file. Now, within this file, the first thing we're going to do is we're going to bring in the Node.js module for working with the file system, but this time it's going to be the version that utilizes promises, as opposed to callback functions. Now, since we have this in place, we'll start the process of reading the file. And as I started out here, you might be tempted to think, wow, this looks exactly like what we were doing in the last clip. And trust me, it's going to change here pretty quickly. But the first two arguments that we're going to pass are identical to what we used in the previous clip. We'll give the file name, and we'll specify that it's going to be utf8 encoding, but here's where things start to change. We don't pass in a callback function. Instead here, we're going to specify the logic that needs to be executed once the file has been read. But instead of a callback function, we're going to enclose this inside of the then function. So here, we're going to specify that this will be executed once that file has been read. But you'll notice here, we only have one argument to our arrow function that we defined here and that is data. Whereas, when we're dealing with callback functions, we would have both a potential error and whatever the result was from our asynchronous action. But don't worry about that because we will handle errors here in just a minute. But for now here within this particular function that we've created, I need to add in the logic for parsing out the JSON and logging out all of our details to the console. Now, once this is in place, I should be able to run this, and assuming that that file is present on the file system and assuming that it is valid JSON, we should see these values logged out to the console. And indeed, that's exactly what happens. But we do need to take care of the situation where either the file isn't present or it isn't valid JSON. So for here, instead of adding another .then, we're going to add in a .catch. And this will catch any of the areas that happen in the entire promise chain. And I'll go ahead and give you a heads up; in a bit, we'll be adding even more asynchronous logic to this, and we'll see that any errors that happen would end up in this particular function. So here, within this particular function that we've created, we can add in the logic for logging out the fact that there's an error and then throwing that error so that it will end execution of the application. Okay, now we could test this out too by doing what we did previously in changing the file name. I'll just add an x on to the end. We know that that file isn't present, so when I hit F5, we can see that indeed we do get our log statement stating that we couldn't complete loading and parsing, and then we can see what the error was, which in this case was no such file or direct. Perfect. So that's working exactly as we would hope. Now, here's another scenario though and probably when you haven't thought of yet. What if you're dealing with some type of an SDK or API where you don't have access to an API that supports promises and it only supports callbacks? And trust me, you're going to run into this situation. Well, you can actually create your own promises. So I want to show you how that works here in this case. So what we're going to do now is we're going to go through and create a custom promise. And in this case, it's going to use the callback version of the API that we used in the last clip. Now, I want to go ahead and call out here that we're going to create a function in a slightly different way, and that is we're going to create our first async function. So here I'm going to specify that we're creating an arrow function. Again, this should look pretty familiar to us because we've done this kind of thing before. But in this case, what we're going to do is we're going to use the async keyword here to specify that this function returns a promise. Now you might be saying, well, how can we return a promise if we don't have an API that supports that? Well, in this case, a promise is just an object. So what we can do is we can actually go in and specify that we're going to create a new promise. Now a promise takes a function as its argument, and this function has two different parameters that are passed to it, resolve and reject. Now these are two functions that we will call when we're ready to either resolve the promise or reject the promise, meaning that there was an error that happened within the execution. So to get the logic for this going, let's go back to the top here and underneath where we're bringing in our promises API, let's bring in the API that we used previously. So here we'll bring in the node file system module for the version that uses callbacks instead of promises. And you'll notice here, we're going to call this one fsc, so we'll just distinguish that for file system callbacks. Since I have that in place, let's now go inside of the arrow function that we created as we're creating our new promise. Now in here, we're going to call fsc.readFile and this should look identical to what we did within the last clip. We'll specify if there's an error we need to do something and then if there's not, then we'll need to do something else. Now within this particular conditional where we're checking for the error, we can say that we're going to reject based on the error. And then in the situation where there's not an error, we can actually call resolve. And here, this will enable us to resolve it so anything that's waiting on this promise to be completed, we'll get this data back, assuming again there are no errors that happen in the execution. Now it becomes pretty easy for us to integrate this into the logic that we currently have. So here, I can actually go in and before the catch, I can actually add in some additional asynchronous logic. So in this case, we'll say that we're going to read that file again, and then after that, we'll log that data out to the console. So now I'll go ahead and save this file, and now we'll run it. And you'll notice here that it did actually output the entire JSON file after our complete statement. So we can see that we've been able to integrate this chain of promises with a custom promise that we created, utilizing the callback version of the API.
So next we're going to explore how to use promises in a different way by using async and await. Now according to the MDN Web Docs, the async function declaration declares an async function where the await keyword is permitted within the function body, and the async and await keywords enable asynchronous promise‑based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains. Use of async and await enables the use of ordinary try catch blocks around asynchronous code. Now, all of those concepts are things that I introduced at the beginning of this module, but now I want to show it to you in code. So let's waste no time. Let's jump into VS Code. So here within VS Code, I'll create a new file. And here within this file, the first thing we're going to do is to pull in that promise‑based API from Node.js for working with the file system. Now as I mentioned in the definition slide previously, to utilize async and await, we need to have an async function. So here, I'm going to define an async function called loadData. Now most of the logic in here is going to be similar to what you've seen, but to start off with, I'm going to use the await keyword. So here I'm going to say that data = await and then fs.readFile, and then we'll pass in the same arguments that we used previously. So let me explain what's going on here behind the scenes. We're still using the promise‑based API, so we're still working with promises. The await keyword specifies that the promise will need to complete, and then after that, it will execute the next steps that are listed in your code. This makes it work in many ways similar to how we work with synchronous code, and we'll see that's true on multiple fronts here within this clip. So that's our first step. And the next step here is just the plain stuff we've been doing in all of the last several clips, and that is we're going to parse this out to be an actual data object by parsing the JSON, and then we'll actually log some stuff out to the console. So now that we have that in place, we should be able to execute this function, and that should give us our data. So what are we going to do here? Well, at the end, I'm just going to go ahead and call loadData, and then I'll include a final logging statement that says that that promise has completed. But here it's async, and you might say well, I thought in the last clip you said that async had to return a promise. Well, in this case, using await is basically doing that for us behind the scenes so we don't have to do it manually. So now I should be able to save the file and hit F5, and you can see that it does bring back the data. It does log out and say that it's complete, and we see that final log message stating that the promise is completed. Okay, now that's great, but just as we've dealt with before, we need to be able to handle situations where errors may occur. Now the difference here is we're going to go back to what we were using with synchronous code to be able to do this, and that is going to be a try catch block. So here, I'm going to specify our try block, and I'll go ahead and adjust the indentation here. And then we need to add in our logic for our catch block. And again, this is going to be very similar to what you've seen before. We'll actually log out a message and then we will throw the error. Okay, so now this should work exactly as it did before. So here if I go up and change so that we have a file that doesn't exist and then I hit F5, we'll see that it utilizes promises, but we still get the ability to see the error displayed here, just as we would have done in using a catch function after our promise chain. So here, we're going to do this inline utilizing a try catch block. Okay, now that's perfect. And this all works the way that we would want it to, but I want to show you some of the power here because we can go through and do some additional things. Like let's say I don't want to just do one asynchronous thing, let's say that I want to do several. And I'm going to add in some logging statements here so we can actually see that this plays out in the order that we would intend. So here, we're just going to go through and read the same file several times, and this will just help to illustrate the way that async and await works behind the scenes. So here in this case, I'm going to go ahead and have several additional reads of the file. So after we read the file the first time, it will say File Read 1, and then it'll go through and do the same thing for 2 and 3. Now if this works the way that we want it to, we should see that we're going to see this come out in order, and all of these statements will be logged in the order that you see them here in the code. So now, I'll hit F5, and we can see that indeed we actually see File Read 1, 2, and 3 happening before we get to the point where we're logging out the data and then finally, before we're actually listing that the promise has been completed. Now, I've shown you all this and I read you a definition earlier that said that await needed to exist within async functions, but now I want to introduce you to one additional concept and that is top‑level await. So here, according to the ECMAScript proposal for top‑level await, this enables modules to act as big async functions. With top‑level await, ECMAScript modules can await resources, causing other modules to import them to wait before they start evaluating their body. Now, I realize this probably doesn't make a ton of sense yet because we haven't covered ECMAScript modules and modules in general yet, which we will be doing very soon. But let me show you how that changes potentially how we can write our code. So I'm going to jump back over to VS Code. So first, I want to point out if we go under our package.json file, here we're listed as type of module. So this is being treated as a module with ECMAScript modules, so in this case because we're using Node 18, we can take advantage of top‑level await. So here, what I'm going to do is I'm actually going to take this entire block inside of our function and I'm going to copy it. And I'm going to go down here below where we executed that promise, and then I'll paste it. And now I'm going to go to everything that we've included previously and I'm just going to comment this out. And so now this is all we have to execute. Now, I want to show you that this works outside of the async function because of top‑level of await. So if I run this now, we can see the exact same result that we had before. Which means if you are using a module, you do have the ability to utilize await outside of an asynchronous function in some cases, and that's why we can use it here.
So now, we're going to be taking these asynchronous programming concepts that we've been covering in this module and we're going to be integrating them into the sample application that we've been building. So here in this demo, we're first going to be loading data using a file on the local file system, and then we'll be utilizing asynchronous logic with promises and async/await. And then finally, we will be persisting data beyond a single execution of the application, so let's dive in. So here within VS Code, I'm first going to run npm install to install the dependencies that I have for the application. Now, I want to show you in the data.json file we have some new fields. We're getting a salary in U.S. dollars, as well as a local currency for each of the employees, and we'll be covering that in the upcoming clips. Now, also note here, we have a lot more employees than we did before. We currently have 60 different employees that are listed, and so we're going to be working with these employees throughout the course of this clip. So, let's jump over into the index.js file. So here within this file, the first thing I'm going to do is I'm going to change how we're actually loading in data. We're going to be using something that should be pretty familiar to you at this point, and that is the promises version of the node file system API. Now, the next thing we're going to do is we're going to have some global variables. The main one is going to be employees. Now we previously got that from loading in the JSON using the import statement, but here we're going to create an empty array, and the plan will be that we'll read in the data from the data.json file and populate this array on startup of the application. But to do that, we'll need to write some files to actually handle loading data, as well as writing data back to that JSON file, but once this is in place, the cool thing is is that our application will actually be working. When we add an employee, they'll actually get to stay in the directory even after we close the application and restart it. So our first function here is going to be for loading in the data, and this should look very familiar to you. We're going to have a try block, we're going to use the fs.readFile function, we'll pass in that it's data.json, and then we're going to go through and parse that JSON. We'll have a catch block to catch any issues that may arise, and we'll say that we cannot load employees if that happens, and then we'll throw the error. Okay, that's our first function. Now the second one is going to be very similar. It's also going to be an async function for writing data, so what this will do is it will take our current array of employees and it will write that data back out to the JSON file. So we'll use fs.writeFile, and you'll notice here that we do pass in the file name, as well as the content, which in this case is going to be a string that's generated by JSON.stringify, and we'll add in our catch block in case anything unexpected happens. Okay, so this is a good first step. We've added in a lot of additional information here on how to load in data from the JSON file and write it back out. Our next step will be we're going to wrap some of our logic around Application execution into a new function. The reason is, is we want to actually have a startup process where the data is loaded before anything else happens. So here I'm going to go in and create a new function called main, and I'm going to specify that this is going to be an async function, and again, when you're doing an arrow function, this actually goes right before the parameters. Okay, so now we have that and I'm going to actually take and cut everything that we have here under Application execution, and I'm going to paste that inside of this function. And we can format the document to be sure everything has the correct indentation. Okay, great, so we're getting close, but now we need to actually specify what happens when the application starts, and here's where we're going to utilize some of the promise chaining that we learned about in a previous clip. So we'll say that loading data is the first step, and then we'll run our main function, and then we'll add a catch to catch any errors that happen within the overall startup process. So, great, we've included that in place, and we could now run the application, and we should see that it would work just as it had before. So what I'm going to do is I'm going to pull the terminal up, and here I'm going to run node index.js, and we'll say list. And you'll notice here that, indeed, it does work just as it did before. So now that we have that in place, the next thing we need to do is we need to handle a situation that's currently happening when we add in a new employee. Now I'm going to show you here that when we're adding in an employee, we're not specifying an ID anywhere. And if you go and look in our JSON file, you'll notice that here in this file there are numeric IDs, and they go in order. Now we could certainly just create some sort of random ID for each employee, but in this case I want to follow the same concept that has been put in place with this sample data. So we need to create a function that will help us know what the next ID is for a new employee. So I'm going to scroll up here, I'm going to go under where we're actually defining our getInput function, and we're going to create a new function here, and I'm going to show you some new concepts as a part of creating this function. So this function is going to be called, getNextEmployeeID. Now, this doesn't need to be an async function, this is going to happen synchronously, but here's what it's trying to do. It's going to go through and figure out what the biggest ID in terms of the max value of the number for IDs across all employees is. So here, there's a function I want to tell you about on the array object called map. So let me show you what this is, and I'm going to tell you, this doesn't actually solve our problem yet, but it's the first step. So we're going to call map on our employees, and what this does is it enables us to return a value from each item in the array. In this case, we're going to return the id of each item. Now, it will create a new array, so imagine this new array that has all of the different IDs from 0 to 1, 2, so on, and so forth. It has all the values for each of the employees in our array. The problem is, Math.max is not designed to take an array. Math.max is expecting that we're going to list a bunch of values as parameters. So in this case, if we passed in Math.max and we did 1, 2, 3, it would return 3, because in that case, that is the maximum value. Well, we can do this here utilizing something called spread syntax. So I quickly want to go over to the documentation. So here, for the MDN Web Docs, the spread syntax allows an iterable object such as an array or string to be expanded in places where 0 or more arguments for function calls or elements for array literals are expected. So, this is what we're going to utilize here to basically change it out from an array into something that our Math.max function can actually use. So here, what I want to do is I want to utilize spread syntax at the very beginning. So I'm simply going to add in three dots, and it will convert that into a list of parameters for the Math.max function, which should give us our maximum ID, and then we'll simply return 1. Now the way that we'll integrate this into our application is simply after we create our new employee, we will go in and add in the ID. Perfect. Now, there's one more thing we're going to do here. We no longer need to just output the Employee JSON. That actually seems to be not that useful. Instead, we want to do something else. First, we want to add this employee to the array of employees and then we want to write the data back out, and this will ensure that that new employee will remain in our list when we start the application again. Now you'll notice here that we have an error. Well, the reason is is because this isn't currently listed as an async function. So we're going to go ahead and specify here that this is an async function. And then when we go down to use this function, we're going to also specify here that we want to use await. Okay, now we've added a lot into this application, and you might think, well, let's test out adding in a new employee, but we're purposely going to wait, because we haven't yet added in the ability to add in those two new fields that we've added, and we'll be doing that over the upcoming clips.
So now we're going to use our asynchronous programming logic to do something that I think is pretty cool and that's to make HTTP requests. And this opens up a whole host of ways that we can build exciting experiences by leveraging publicly available APIs, and that's exactly what we're going to start doing here within this clip. So first of all, we're going to be reviewing a public API for currency conversion, and eventually, we're looking to integrate this into our employee application. We're then going to be signing up for a free API key for that API. We'll then be testing out that API with Postman and then implementing that API within JavaScript utilizing fetch. So let's dive in. So we're going to be using the exchangerates API. So within our directory application, we're going to set US dollar as being the base currency, so we're going to store all of our employees salaries in that currency. But then we want to be able to convert it in an accurate conversion over to whatever their local currency is to display in the application. And we can do that here with the exchangerates API. But like most APIs, you need to have an API key. So here, you can actually click to get a free API key. And you can go ahead and select the Free option, and you'll have up to 250 requests totally for free every month, and it says free here for a lifetime. So I've actually already done this, and I already have an API key. So we're going to go ahead and move forward past this part. Now I'll note here the API key that I have, I will be deleting at the end of recording this course so don't go through and try to use the key that I'm using. So now we're going to jump over to an application that we haven't used yet in this course, and that is Postman. So Postman is a great way for us to test out publicly available APIs or anything really that we can hit with an HTTP request. We're going to use this here to verify that our API key works before we move over and start integrating it into our application. So first, we need to know the request URL. Now I know for the request that we're doing, we're going to be utilizing this particular URL, which is going to give us the latest currency conversion data. Now we do need to specify some parameters, so in this case, we need to specify that our base is going to be in US Dollars, so we'll say base is USD. Now the next thing we need to do is we need to add in a header, and this header is going to be the API key, so I'm going to specify API key. And now I'm going to enter in the value that I got by creating that free account. Now as a reminder, as I said earlier, I will be deleting this API key so don't try to reuse this one. Now that I have that in place, we're now able to actually execute this. So I'm going to hit the Send button. Now we'll see that we get the data returned. Now, here you can see that we have rates. Now this is all in comparison to the US dollar, so here you can see what we actually would need to multiply values by to get the actual conversion over to whatever the currency is. So for example, if we scroll down to GDP, which is going to be Great Britain pounds, we can see that that's 0.832005. Okay, so now that we have this in place, how do we integrate this into our application? Well, Postman has a feature that can be helpful in getting started, and that is the cogeneration feature. So here you can see for JavaScript it actually has some code. Now I'm going to go ahead and tell you, I wouldn't recommend using this code without making some edits to it, but this just shows you how you can utilize fetch. And I know we haven't yet talked about fetch, so let's take a quick trip over to the documentation. So here in the MDN Web Docs, it tells us about the Fetch API, and this provides an interface for fetching resources, including those across the network. Now, with this being said, this is only recently available in Node.js. And with it being available in Node.js, we now have an API for making HTTP request that is the same both on the server and in the browser. So let's go ahead and dive in and actually utilize the Fetch API. Now, before we integrate this into the application, I simply want to test it out. So I'm going to go ahead and create a new file, and we'll call this fetch. Now here within this file, we're going to bring over a lot of the concepts that were covered inside of Postman. So first of all, we're going to create a new headers object, and we're going to specify our API key as one of the headers. It simply won't work without this. If we made the request, we would get back a status code indicating that we weren't authorized to make the request. Now the next thing that we need to do after this is we need to actually set our request options. So here, we'll go ahead and specify those. This will include some different values including the method, as well as those custom headers that we just created. So once we have this in place, now we can actually look at integrating in and using fetch. But since it's asynchronous code and since we're going to be using async and await, we're going to go ahead and wrap this in a try catch block. I'll go ahead and set that up. And then within our try block, we can now enter in the code to interact with fetch. So first of all, I'll say that the result here is going to be awaiting fetch, and then for fetch, I'll specify first that URL. And this includes that base parameter that we have included and then our request options variable. Now after this, we're going to go through and say that we want to get back the JSON results. Now that also requires that I use await. Now that we have this in place, we could execute it, but I also want to give us some logic here in our catch block in case something goes wrong. And it's important to note here anytime you're calling a publicly available API, especially if you have a free API key and you're not actually under an SLA, there's a good chance it might not work properly the first time or it might not work well on occasion. So you absolutely need to integrate error handling in. In some cases, you might even want to integrate the ability to retry an API call if it fails the first time. But for now, we'll go ahead and save this, and I'll hit F5 to run it. And here you can see it has returned the same data that we saw in Postman. We get all of the different currency conversion rates that were included for that API endpoint. So now that we understand how to work with a publicly available API, now that we understand that we have a service that we can call to get this data, in the next clip, we can work on integrating this into our application.
So now we're going to take the information that we've learned about asynchronous programming and especially the information we've learned about making HTTP requests in the previous clip, and we're going to apply that to the application that we've been building. So here over this clip, we're first going to be integrating the currency data from the public API, and that was what I demonstrated in the last clip. And then, we'll be adding additional prompts for salary fields, displaying formatted currency fields, and verifying our data persistence. So, this is pretty exciting. Let's head over to VS Code. So here within the application, the first thing we need to do is to create another global variable to hold our currency data, and this will be what we populate once we go and fetch that data. So now, we need to actually go and fetch it. And I'm not going to spend a ton of time on this because we did cover this extensively in the last clip, but I will point out a few changes to what we included previously. So we'll create our new async function called getCurrencyConversionData. Within this function, we'll go through and first create our headers object, and we'll go through and add our API key. Again, if you don't have an API key yet, go back and check the previous clip. Now the next thing we need to do is to create our options object, and I will show you one thing with this. So you'll notice here that we're creating a property on this options object called headers and we're using the variable headers for the value. Well, if you ever have to do that, you can actually just write it this way. Perfect. Now the next thing we need to do is actually get the data. And then we need to check something here, and we didn't do this in the previous clip. So here, we need to check that the response is ok. Now that's going to mean it's got a 200 or 200 level status code. Now, that's important because that means that the request completed successfully. Now the server that's sending us the data is what sets that status code. So if we get back a status code of 500, meaning that there was a server error, for example, on the server that was supposed to be sending us the data, then it's not going to throw an error here. However, we want it to throw an error, so that's why we check to see if the response is ok. Now, I also want to show you here, we're creating our own error. We're not using one that was passed to us. We can do that by utilizing the constructor here and saying new Error and then passing in the message for the error, which in this case is Cannot fetch currency data. Once we have that, we can go through the process of actually setting the value on our currencyData object by parsing out that JSON. Okay, so now that we have this in place, the next step that we need to take is we need to add in a validator function. If you remember, we have prompts for all the data that's going to be included in the directory, and for each of those prompts, we need to have a function that validates if the user's input is correct. And we have two additional fields. Now I'll show you this here on the data.json file. We have both a salary in USD, which is just an integer, and we know how to validate that. We've already done that. However, we also have a localCurrency, which utilizes a three letter currency code. Now we're getting those back with the API call, and we need to be sure that what the user enters is actually a value that we have included in those results. So let's create a validator function to handle that use case. So here, we're going to create a new function. We're going to call, this isCurrencyCodeValid. Now, we're going to pass in that code; that's how any validator function works. But in this case, we're going to go through and get the keys for our rates object on our currency data. So that will be all of those three letter codes like USD, and GBP, and ZWL, and so on and so forth. So what we're going to do is we're going to check to see if the code that the user supplied is included in that array, and we're going to do that with the index of method on the array. Now with this, if it is not found, it will return ‑1. However, if it is found, it will be 0 or higher. So here, we're just going to add in a single conditional to say if the index of is > ‑1. If that's the case, it will return true indicating that the currency code is valid; otherwise, it will return false. Okay, now that we have that in place, we're going to go back up and add another function underneath where we are getting our currency conversion data. Now you might say this file is getting pretty long and a little bit confusing. Well, you would be right, and that's why we often split our applications up into multiple files, which we will be covering in the next course module around modules, but you'll have to hold on just a bit for that. Okay, now let's go ahead and add in another function here called getSalary. And here, we'll pass in both the amount in USD, as well as the currency code that we want to have it displayed in. And we'll both do the conversion and handle the formatting here within this function. So the first thing we need to do is to do the conversion. So here, we'll add in a new variable called amount, and it's going to take the currency that gets passed in. And if it's USD, it's just going to return the amount because in this case, we know that we don't need to convert USD because that's what it's already in. However, if it's anything else, we want it to multiply that amount by the currency conversion rate that we got from the API. Perfect. Now the next thing we need to do is handle formatting because we know that each currency is displayed a little bit differently. And from an earlier clip in this course, you know that we can utilize the number format to handle currency formatting. In this case, we'll format that based on the currency code that gets passed in. Perfect. Okay, we're getting closer here to having this fully implemented. The next thing we need to do though is we need to add in our prompts for the user. So I'm going to scroll down to my addEmployee function. And after we ask is the employee active, we're now going to add in two additional prompts. The first one will be for that salary in USD. In this case, we're going to utilize the validator that we included previously, and we'll say anything between 10,000 and a million is sufficient. Then, we'll add in our local currency prompt for that three letter code. And in this case, we'll use the function we just created, isCurrencyCodeValid. Okay, let's look at one more function that we have, and that is our logEmployee function. So here, we're simply logging out every single property. But in this case, we don't want to do that because we want special logic for the salary USD and that local currency code field, so here's how we're going to handle that. We're going to go through and create a conditional and say, hey, if this is salaryUSD or if this is the localCurrency code, we're not going to log it out. However, for anything else, we will log it out in exactly the same way. Now the last thing we want to do here is that we'll want to go after our Object.entries here where we're going through each of the values included in the object, and we're going to want to log out especially both the USD salary, as well as the localCurrency salary. Now to do this, you'll notice that we're using that getSalary function that we just created. Okay, we're almost ready to test this out. But what we need to do is we need to modify the startup process so that we can go fetch our currency data before we execute our main function. In this case, I'll go through and enter in another function in the promise chain, and that will go and fetch our currency conversion data. Perfect. Now we should be ready to test this out. So I'll open up the terminal. So here, we'll execute the Add command on our application. So let's enter in a first name. We'll say William. Last Name: Rogers. We'll go ahead and set the Start Year. In this case, we'll say 2000, and then we'll set the month to be 2, the day to be 3, and we'll say that the employee is active. Now, we get to enter in an Annual salary. Well, we know it should be at least 10,000, so if I enter in 100 it will say invalid input. So let's put in, it's going to be 100,000, and then we need to enter in a local currency. In this case, I'll say GBP for Great Britain pound. Let's pretend that William is working out of our London office. Now it actually has written those values out to the JSON file. So if we go in and look under our JSON file and I scroll all the way to the end, we'll see that William Rogers is indeed included. Now, the next thing we need to do is we'll go search for William to verify that we can display the currency correctly. So I'm going to go ahead and load the application. And in this case, we'll search by ID. Now it's going to ask for the ID, and we'll say 60. And here, you can see we have William's listing in the directory. We get a US salary listed as 100,000, and you can see that we have a properly converted and formatted Local Salary displayed as well.
So, up to this point, we have made the assumption that when we are running an asynchronous operation, we want one operation to complete before we start another one. But we don't have to do that, and the global Promise object supports some different ways of handling concurrent promises. So let's jump over to the documentation. So I'm here on the MDN Web Docs looking at the global Promise object, and I want to point out there are four different methods on the global Promise object that deal with handling concurrent promises. We have Promise.all, Promise.allSettled, Promise.any, and Promise.race. Now, I specifically want to talk about Promise.all, and we'll be integrating this into our application. So here we can pass Promise.all an array of promises. Now what it will do is it will return a single promise, and that single promise will fulfill when all of those promises that we've passed into it fulfill themselves. Now if any one of those promises that we have passed in fail, then that single promise it returns will fail as well. Now by doing this, we can do multiple asynchronous processes at the same time. So let's take a look in our application at how we can implement this to change how our startup process works. So here in VS Code, in our application, we're loading that JSON file completely before we start the process of fetching the CurrencyConversionData. Now, to be honest, in our use case, loading that JSON file, because it's a local file, is really quick, but let's pretend that both of them existed on a server. Well, we might want to go ahead and have them both operate at the same time, so that's exactly what we're going to do here. So I'm going to utilize the global Promise object, and we'll say Promise.all. Now inside of this object, we're going to pass an array of promises. So in some cases, we can just copy and paste. So I will include loadData, because it returns a Promise, and then we'll take getCurrencyConversionData and I will put this here as well and execute it so that it returns a Promise. Now if you remember what it said is that it's going to return a Promise, so we can utilize our .then immediately after this Promise.all, and now our application will start up once both loadData and getCurrencyConversionData have completed. Now if either of them fail, then it will go to our catch block here, which will then log out that we cannot complete the startup process and then throw the respective error. Okay, so now, let's test this out. So here, I'm going to run the application using the search‑by‑id command, and we can see now that it has completed loading both the employees, as well as our CurrencyConversionData. And you can see that, because if I log out employee number 60, which is William Rogers that we added in the previous clip, you can see that not only do we get the listing showing that we have received the JSON data from the local file, but we also get the properly formatted currency data, meaning that we have been able to successfully fetch the currency conversion data from our public API endpoint.
So I would be remiss if I didn't cover one additional concept since we're talking about asynchronous programming, and that is event handling. Now, events are things that happen in the system you're programming in, and the system produces or fires, in this case, a signal of some kind when an event occurs, and it provides a mechanism by which an action can be automatically taken, that is, some code running when the event occurs. Now, let me give you some examples to help you understand how this plays out. Maybe you want to respond to some type of system events. So in the case of our application, let's say we wanted to do some cleanup as our application was exiting. So we would need to listen for some event that would let us know that our application was about to close. But one of the most common use cases of event handling in JavaScript is when you're looking in the browser to handle things like mouse clicks because you'll want to know if a user clicks on a button, for example, and so you need to have some code that executes when that happens. But until then, you don't want that code to execute. Or also things like key presses. And we're even listening for some of that within our application inside of the third‑party module we're using to get user input. But there also are other things such as async progress events. Let's say that you're uploading a large file, and that large file, maybe it's 100 MB, and you want to be able to get notifications so that you can let the end user know the progress of that upload. Well, you'll need to have some custom code that executes every time there is an update from that overall async process. Now I want to show you how you can leverage the event emitter that is included as a part of Node.js, but just know that really a majority of your event handling use cases are going to happen when you start working in the browser. But let's go ahead and jump over to VS Code. So here in VS Code, I'm going to create a new file. Now here within this file, the first thing we're going to do is to bring in the Node.js EventEmitter, and this is what allows us to both listen for events, as well as emit our own custom events. Now, the next thing I'm going to do is I'm going to create an emitter, and I use the constructor pattern on this EventEmitter object. Perfect. So now that I have that, the next thing I want to do is actually want to add in an event listener. So in this case, we have a string identifier for the particular event, and we'll call this one hello. And then we can add in a function that will execute whenever we receive that event. So in this case, I want to add in an arrow function, and it will receive a message. Now that's going to come into play here in just a minute. Perfect. So now we need to actually emit this event and verify that we can receive it. Now to do that, I'm going to utilize a function, a global function in JavaScript that we haven't talked about yet, and that is setTimeout. Now setTimeout takes two arguments. You can pass in a function and then a number of milliseconds that it will wait before it fires that function. And so here, we want to emit this event after we wait for 3 seconds. So I'm going to start off by calling setTimeout. We'll create our arrow function, and then we'll say that we want to wait for 3 seconds, which, again, is 3000 ms. Okay, now we need to add in the logic to actually fire this event or emit the event. So in this case, we'll say emitter.emit, and we'll give it the name hello. This is the same string that we referenced earlier. That's how it's going to know what listeners should fire for this event. And then we're going to pass in the custom data, which in this case is just going to be a string called message. Now, if everything works when we run this file, we should see that after 3 seconds, we get a message stating that the event has been handled, and then we display the message that was sent out through the event that was emitted. Okay, let's give this a test. And indeed, we can see that we did receive that event. The event has been handled. And so this illustrates, at a basic level, how we can listen for and emit our own custom events.
