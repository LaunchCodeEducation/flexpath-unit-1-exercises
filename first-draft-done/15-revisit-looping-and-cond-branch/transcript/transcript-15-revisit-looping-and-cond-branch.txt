Course Overview
Course Overview
Hi everyone. My name is Andrejs Doronins, and welcome to my course, Looping and Branching in JavaScript. Looping and branching are fundamental constructs in any program, no matter how complex. This course will walk you through all the ways you can iterate and branch in depth, as well as the pitfalls you may encounter along the way. Some of the major topics that we will cover include basic and advanced looping constructs, and branching constructs, including if‑else, switch, the ternary expression, and other. By the end of this course, you will gain the ability to achieve a variety of useful tasks with looping and branching. Before beginning this course, you should have some professional experience with any programming language in any IDE such as VS Code. I hope you'll join me on this journey to writing professional code with the course, Looping and Branching in JavaScript.

Understanding Iteration Thoroughly
Introduction and Course Overview
Hello. My name is Andrejs Doronins, and welcome to my course, Looping and Branching in JavaScript. As I'm sure you know, looping and branching are the basic building blocks of any software, and in this course, you'll take a deep dive into these concepts in JavaScript. A quick note on the version used in this course. This course was created using the latest ECMAScript available at the time of recording. This means that this course is 100% applicable to JavaScript code written using the new features up until now and into the future, but the vast majority of content in this course applies to older projects. As you may be aware, you can't download and use a particular version of the language, you just write whatever JavaScript code, and then it depends on the executing engine if it already supports the latest features or not. For example, the V8 engine for Google Chrome, Microsoft Edge, and Node.js, or the SpiderMonkey engine that powers Firefox. The developers of these major engines are usually quick to add support to the new features. There are a few loose prerequisites for this course. You should be familiar with general programming concepts; variables and their types such as strings, numbers, and Booleans; declaring and invoking functions or methods. I need you to be able to write such simple code in any language. That's the bare minimum. Bonus points if you have HTML basics, because some of the demos will be in the context of a browser app, and you're comfortable with a professional code editor. I'm on a Windows machine, but that shouldn't matter, and I'll be using the popular VS Code IDE throughout the course. Finally, it will be convenient if you have Node.js installed to run standalone JavaScript files, but if you don't, I'll show you alternative ways how to do that in just a moment. Here's a super brief overview of the course. We'll first go over all the possible ways to loop over iterables, the classic for loop, for‑of, forEach, while, and do‑while. It might feel odd that there are so many ways, and one reason is that the language has evolved, but older syntax can't be removed for backwards compatibility, but it's also true that some loops have advantages over others. You'll see. We'll then dive into advanced looping concepts including the for‑in loop, asynchronous looping, and performance considerations of iterating in general. Finally, we'll switch over to branching and its various pitfalls. Some might surprise you. One of the highlights related to branching is the so‑called nullish coalescing operator recently added to the language and it allows us to write much more concise ternary expressions.

Project Setup
You can of course just watch the course, but I encourage you to code along. All you need to do is download this HTML file and code between the script tags with me. You can go to my GitHub page and clone the corresponding starter repo. The repository is small and simple. HTML pages with a bit of CSS, empty JS files to write code in, and a basic package.json file to run JS files with Node. You can use this button here to clone the repo from the command line or download the ZIP file, unzip it, and then open it in your code editor. Alternatively, you can download the same files from the Exercise files tab on the home page of this course. So pause the video and get the files if you want to. I already have the project on my local machine and open in my IDE. Here's the HTML file, and if I open it up in the browser, here it is, a simple table with stocks and information about them. If you're curious, I copied the data from the Stock Analysis website. It's pretty good if you're interested in investing. But back to our table with static data. We have the company name; we have the symbol, or ticker, that is used on stock exchanges to identify the companies; the industry it belongs to, I simplified this column a little bit; the number of shares publicly traded for that company, if you buy one share, then you own a tiny fraction of the company, if you own all shares, then you own the whole company; the current price of the stock; and the beta. Beta measures volatility, or in other words, how much the price jumps up and down. One means average market volatility, smaller values mean prices don't move as much and are thus attractive to conservative investors, and bigger values mean prices jump up and down quite a lot, and it is thus suitable for investors with a bigger risk appetite and stronger nerves. It's pretty common to use JavaScript to scrape data from HTML, and that's what we are going to do. I hit F12 and open Chrome DevTools, and I can say document.getElementById, because the table has an ID, getElementsByTagName, and we choose table row, and this gets us all the rows with the data. And I can access any element in the collection with the standard syntax and get the innerText. There! We get the stock details separated by the tab special character. This will be useful to us when we start writing our loops. Here's how things will work throughout most of the course. I will show and explain some code inside a separate JS file, then I will right‑click and choose Run Code. This runs the code inside Node.js. This is why we need the package.json in the project. It allows us to run Node commands. You can also open up the Terminal, or the native command line of your operating system, and inside the right folder, where the file is, type node, some JavaScript file, and run that. The file should get executed. This is all you need for the full experience. Once we learn the basic concepts, we will switch to the HTML file and apply it inside the script tags, and that will show up in the browser console. If you don't have Node.js, then you can write all of the code inside the script tags. As a last alternative, you can use JSFiddle or a similar online JavaScript editor to write code. You can paste any HTML code here, write your JavaScript code here, click Run, and see the result.

The Classic for Loop
You've probably seen some sort of a loop in another language. It has the initialization section, here we set up one or more variables for the loop; the condition, and it is checked before each loop iteration. If it is falsy, the loop stops. And finally, the post iteration action. This code is executed after each loop iteration. Typically, we move the index by one. Here's what it looks like. We start with index 0, we say we want to finish at some value, and after the iteration we up the index by one, typically with the ++ operator. Even if you're used to this, it is still the most verbose and complex syntax of all for loops, but it also gives you the most power and flexibility. If you like, you can start with the max value and iterate backwards, just subtract from the index instead. You can also fully control every section. If you want to iterate only up to the middle of an array, you can do that in the condition section. Do you want to work on every second or third element? You can do that too. Whatever exotic or nonlinear iteration logic you may have, the classic for loop is likely to have you covered. Let's run the code. And see here, the first loop going forward, the second loop going backwards, and finally, the last loop where we hop over every other element. Let's apply this to our stock table. I'm inside the html file inside the script tag. So here we get the table and all the rows. We want to collect the data into this empty array. So we say for, index 0, go through all the rows, and go one row at a time, and we will push the value inside our array. We access the row element by the index, we get its innerText, and we split by the \t, the tab character. We've seen this in the previous clip. And let's print the output. Go back to our page with DevTools open, refresh, and see here an array of Arrays. Expand this, and it seems we got all the rows including the table headers. If we don't want those, go back to our code and say that we want to start not from index 0, but from index 1, thus skipping the header. Go back, refresh, and here we are. We'll get to do something useful with this data soon enough.

Frequent Looping Mistakes
The classic for loop gives you complete control over looping, but it also has drawbacks. It can be error prone. Let me highlight a few common mistakes. First one, forgetting the let keyword. See this for loop? Let's remove the let keyword. What do you think will happen? Run the code, and boom, a ReferenceError. If you see this kind of error, check that the keyword let is present. The next mistake is probably the most frequent one. Look at this loop and tell me what it will print. It should print every letter, a, b, c, d, right? Let's run the code, and it does that, except that we have an extra line with the undefined. This is a classic off‑by‑one error, because arrays start with 0, not 1. With the less or equal operator, we accidentally go outside the array boundary. In other languages such as Java, where arrays are not dynamic or resizable, we would get a runtime ArrayIndexOutOfBoundsException, but in JavaScript we can go outside the array boundaries, we just get undefined because there's nothing there. The off‑by‑one error typically happens in either the first or second section, so please test your loops thoroughly. The next mistake happens in the post condition section. Suppose you want to hop over elements and get every second or third element, so you might want to replace i++ with i + 2, like this. What's going to happen now? Run the code, and we get into an infinite loop and every iteration prints the same thing. I will force stop the code execution. And this happens because i++ is a unique shorthand where we reassign the + 1 value to the index, like so. And so with any other update, we need to write it explicitly like this. Last, but not least, and this is common for all loops, initializing certain variables inside the loop and not outside. Suppose you want to concatenate strings or aggregate numbers, so when we loop over this array, we want to get the final sum of 18. So you declare the total inside the loop, and I'm using the old var keyword here on purpose, and log the final result outside the loop. What do you think this will print? Pause and think about it for a moment. Run the code, and it prints 3. This is because with every iteration we reset the total to 0, and so in the final iteration we get 0 + 3, and so we get 3. This shouldn't even be possible because this variable should be visible only within the for loop, but that's the negative effect of using the var keyword, where all variables first get hoisted to the top. If I change this to let and run the code again, we get a ReferenceError: total is not defined, which is much easier to notice early and troubleshoot. We must move the variable out of the loop, and this will now work fine. Run the code, and now we get the correct result. The moral of the story, remember to declare the right variables outside of the loop and always use let or const, never var, for better code and easier troubleshooting in case of a bug.

Using the for-of Loop
Next is the for‑of loop, not the for‑in, that's a different one, and we'll cover it, but with arrays, you should use the for‑of. As you can see, the syntax is simpler. There is no index management. It's a simple loop with a simple trade‑off. You get simpler syntax, but you give up some control over the index, which is totally fine in many, many situations when you just want to iterate the entire array one by one. You might say, but I want to know the index position of every element. Not manipulate it, just know it. And that's possible. Simply invoke the entries on the array and then use the square brackets to get the index, value pair. This is what the method entries returns, a special object that contains the key, value pairs. There is nothing else that you can deconstruct with these square brackets. Let me show you. Copy this for loop and try to get the third value out of it, like so. Okay, let's run the code and see what we get for all three loops. And see here, just the values, then the values with their indices as pairs, and again, the index, value pairs followed by undefined. This is the third value that we tried to get, but it doesn't actually exist. One minor difference to the previous loop, with the for‑of loop, you can declare the element either as let or as const, as a constant. And if you do declare it as a constant, then naturally you can manipulate it, but you can't re‑assign anything to it. This is different from the classic for loop, where the header typically contains the index, not the element of an array, and it doesn't make sense to declare the index as a constant because we update it here, and that will produce a runtime error. So this will work, but this will not. Run the code, and see here, the for‑of worked without problems, but the classic loop produced an error. You can't assign to a constant variable. Let's iterate over the table again, but with the for‑of loop. Here's another empty array, and we will fill it with data. So, for row of rows push the innerText and split it. As you can see, the syntax is simpler, no mention of the index. Open up the page and refresh, and this works. But, again, we have the table headers and we don't want them. Okay, we can invoke the entries, like so. Get the index and the row value, and say if the index is 0, then skip the iteration. Suddenly this is more verbose than the classic for loop, right? But this is unique to our situation. Most of the time you don't need to skip the first element. Refresh, and boom, we get an error. Things are not looking good. Here's the reason, the for‑of loop works on anything that is iterable. An array is iterable, but the HTML rows are not an array. We are dealing with an HTMLCollection, a special DOM object that is given to us by getElementsByTagName. They are both iterables, so for‑of works, but the entries method is a method that works on arrays only. And that's not a problem. We can simply invoke the Array.from method and this converts an iterable to a true array, and then we could invoke the entries method on it. We go ahead and fix the code, refresh, and now this works. Good, but I think we can make this cleaner. Let's extract the array, and since we're now dealing with a true array, we can use slice and slice off the first row, and save that to a variable with a meaningful name and use that in our loop. And now we don't care about the index, so remove all the extra code, and we're back to a simple solution. Refresh, and this still works. That's always good. Let's do something useful. Suppose some API wants to receive just the symbol of the stock and the current price to decide between buying or selling. They are at positions 2 and 5. So let's get those fields. Loop over our newly filled array, for stock of stockData, get the symbol at the second position, and the price at position 6 offset by 1, so we pass in 5. And we use simple concatenation and a template literal, like so. And if it were a function, we would return the output, but now we'll just print it. Refresh again, and the result looks correct.

Looping Over Other Iterables
In the last clip, we discovered that for loops can iterate over anything that is iterable, which means a traversable data structure. Typically, it's an array; and if you're working with HTML, then HTMLCollection also pops up frequently; but a string is also an iterable, and you loop over it character by character; also Sets, collections that allow only unique values; and Maps with their key‑value pairs. If you're coming from another programming language, then these should feel familiar. Here's a string, and we use the for of loop to say for letter of string, do something with each letter. Here's a Set, and we loop over it just like other iterables. Simple! Maps are more interesting. Every key‑value pair is called an entry, and we have the choice to iterate either over each entry or just the keys or just the values. For the entries you don't have to do anything special, just write the for of loop as you normally would. If you want to access the key and the value separately, then simply access them either with the square bracket syntax or the at method, like so. This gets the key, at the first position, and this gets the value. If you only care about the keys, then invoke the Keys method, like so. And similarly, if you only want the values, then invoke the Values method. Okay, run the code. And feel free to pause the video, but I hope the output is what you expected. Here's what we get with whole entries, here are just the Keys, and just the Values. Let's calculate the market capitalization of each company. We need to take the number of shares and multiply it by the price. Should be simple enough. Let's create a Map. The key will be the company name, and the value will be the market cap. So we loop over the stockData array from the previous clips, get the name of the company at index 0, now get the number of shares. This gets us a string, but since we will be doing a mathematical operation, we want to wrap it into the Number constructor. We want to be explicit about this. And do the same with the price value. Okay! And we multiply them and save the results to a variable. And finally, we set these variables as key‑value pairs. Let's print the result, refresh, and now we get a Map of entries. Now, imagine we are supposed to collect only large‑cap companies. Some investors prefer to invest only in large, well‑known companies, as they perceive them as less risky. Let's create an empty array to store the companies that match our criteria, and let's assume the limit for such companies is 200 billion. So now we should iterate over the Map and say, if the company's market cap, stored as a value, is greater or equal to our specified limit, then we want to get its name, and now print the array, like so. Now, let's refresh again. And indeed, we see a list of large and well‑known companies and it excludes some of these smaller companies at the bottom of the table.

The forEach Loop
The next looping option is the forEach method. It's not just another for loop. The for and the for of loops are constructs of the language itself, whereas the forEach is a method on the Array, Map, and Set objects, and you invoke the forEach on the iterable. I'll be showing demos using Arrays, but you can do the same on Sets and Maps as well. Here's an array, and I can invoke forEach, and I can write a function, using the more modern arrow syntax, I'll just say given x, print it. The variable name can be anything, x, e, or a word with a meaningful name. You can also get the index of every value by specifying the second parameter, like so. Run the code, and see here just the values and values with their respective indices. For any non‑trivial operation you may want to extract it to a separate function. Define a function, implement it, and then invoke it, without braces. Run the code again, and this works. The forEach loop is nearly, but not entirely, identical to the other loops. It skips absent values. Let me show you. Suppose you have an array with absent values, so we have null and undefined. Let me print those values with a for of loop and with the forEach loop, run the code, and we compare the results, there's no difference. So, what am I talking about? JavaScript has this concept of sparse arrays. There are arrays with empty slots, not nulls, not undefined, but empty slots. For arrays that's the third concept of an absent value. You can create a sparse array with a literal and specify nothing between the commas, you can modify the length property and all new slots will be empty, you can set a value to some far away index and the slots between the previous and new value will be empty, or you can delete a specific element. Let's make an array sparse and set a value at a far away index. If we print this, this is what we'll get. And now let's use the two loops again. Okay. And run the code again. And now there's a difference. Normal loops treat empty slots as undefined, whereas the forEach loop skips them altogether. If this makes you think, right, so I should use forEach to write faster and more optimized code, then no. In practice, most JavaScript arrays you will work with will not be sparse. And if you do have to work with a sparse array, your code will probably, not certainly, but probably treat it just as it would treat a non‑sparse array with undefined elements. Nevertheless, it's good to be aware of this little feature. Let's use the forEach to print the beta of each stock. For this, we create a function, it's the last column in the HTML table, and print it. Okay, now we simply invoke the forEach on our stockData array and pass in the function. Now, refresh the page, and we printed the numbers. Notice here one value is missing in our table. This is on purpose. And we see that the forEach did process it, but nothing is printed. It's because an empty table cell is treated as an empty string, so we want to coerce it to a number, like so. And if I refresh, we see here we get 0. Of course, we could implement different logic. If the value is absent, print no data or something. One disadvantage of the forEach loop is that you can't use break or continue keywords. As a quick reminder, continue finishes the current iteration and makes the loop move on to the next iteration. So the loop keeps going if the exit condition hasn't been met. Whereas break exits the loop entirely. So break allows you to exit iteration early if, for example, you achieved what you wanted and you don't need to work through the rest of the array. So you lose some control over the loop and can't terminate early. But first of all, you don't need to do this that frequently, and if you do, it can be partially or sometimes fully replaced by functional methods. And that's the topic of the next clip.

Applying filter and map
There is one frequent thing that you want to do while iterating, to filter out some values. Suppose you have some numbers and you only want those larger than 100. You can of course write a for of loop and inside say if the value is greater than 100, then push to another array that we collect to, or you can invoke the filter method and pass in a Boolean‑returning expression. Using the arrow syntax, we can say given every price, or number, get those that are greater than 100, and then chain a forEach method, and then do something with the filtered values, or save the results to a variable. This iterates, filters, and returns a new array. Hard to argue with such a clean one‑line solution, right? I'd like to offer you a small challenge. Using the filter method, collect low beta stocks, meaning the beta value has to be less than 1. You only need to fill in the code inside the filter method. Pause the video now and try it out, and I will provide the solution in 3 seconds. Okay, since we are filtering rows of stocks, we use the arrow syntax and say given every stock, get the stock's beta value and compare it to 1. That's it. This is the solution. Let's see if this works. And it seems to work. Here are the companies with low beta, or low price volatility, but we got an array of arrays. What if somebody wanted just the company name and the beta value itself? For that we have the map method, which helps us with another very frequent need, to convert or transform a value. If we take the same array of numbers, we can invoke the map method and say given every price that we iterate over, do whatever, divide and then round and convert to a string and concatenate with a word. I mean, you can do anything here, any operation, manipulate the elements however you need. Again, I would argue that this code is shorter and cleaner if you compare it to the code doing the same thing inside a classic for loop. Let's run the code, and this is the result. So, back to the low beta stocks. If we need to extract just the name and the beta value, then we need to use the map method. At this point we are dealing with arrays, and we say given every stock array, convert it to a template string literal, and inside that string, place the name of the stock and the beta value, like so. Furthermore, we can make the code cleaner. Define simple functions, name and beta, that take the stock and extract the relevant values out of it. And now invoke these functions inside the template literal, like so. And now we can do the same in the filter method too. If you're not familiar with template literals, you can watch my other course on JavaScript strings, here at Pluralsight. You can also find it on my author's profile. Back to the task now. To repeat what we're doing here, taking stockData, an array of arrays, filtering out some of them using some criteria, and converting those arrays to another type, a string, although it could be an array of custom objects or anything we can think of. But ultimately, both filter and map collect everything back to an array. Okay, refresh, and this is what we get. Looks good. There are more useful methods that you might want to explore, namely, find, every, and some. I won't cover them as this goes a bit beyond the scope of the course, but you can read up on them on Mozilla JavaScript reference guide. They provide a wealth of examples.

Using while and do-while Loops
JavaScript also has the while and do‑while loops. You can achieve the same things with them as with the classic for loop, and I'm covering them for completeness' sake. So here's a classic for loop and it iterates over array elements. Here's how you can do the same thing with a while loop. Declare the index variable before the loop starts and say, while the index is less than the length of the array, then update the index and do the thing. That's it. Run the code, and oops, we have a bug. We didn't get the first element, 20, and we have undefined at the end. Why? Because we update the index too early. We should do it after we perform the necessary operation. Move it to the bottom, run again, and now this works as expected. As you can see, the while loop can also be rather error prone. You might be off by one if you update the index at the wrong time or you use the wrong comparison operator. Also, careful not to write a condition that is always true. This would produce an infinite loop. And finally, the do‑while loop. It's simple enough. Do something while some condition is true. But this loop has a fundamental difference. Because the condition is checked at the end here, the loop will run at least once. Let me show you. Here's a while loop, and it will never execute because the condition is always false. The length of the array is never greater than 10. The array length is 4, right? And here's the do‑while loop with the same condition. It's also always false, but it will still execute once. Run the code, and see here, no iterations for the while loop and one iteration for the do‑while loop. In my experience, though, do‑while loops are rarely used. Hope you're enjoying the course so far. We covered a lot of different loops: for, for‑of, forEach, while, and do‑while. But that's still not everything. Up next, Grasping Advanced Iteration Concepts.

Grasping Advanced Iteration Concepts
Introduction
Hello, and welcome to the next module. The last module was all about standard and frequent looping operations. In this module, we will look into some concepts that are needed less frequently, but it's important to understand them. First is the for‑in loop, and how it's different from the other loops. Next, we'll talk about the for‑await‑of loop, but only briefly, because a full exploration of this loop requires deep knowledge of asynchronous programming. And finally, I will talk about the performance considerations of using different loops. It's a popular question among developers.

The for-in Loop
Here's an array. In the previous module, we used various loops to iterate over them, including the for‑of syntax. But there's also the for‑in loop. Will these two produce the same result? Let's run the code and see. And no, the results are different. The first one produces values and the second one prints indices of the values. It seems that this variable here in the for‑in loop is meant to be the index, so we're not using this properly. So let's make a copy, rename this to index, and access the array elements using it. Run again, and now the first and the last loops produce identical results. Can we now say that the for‑of and for‑in loops are identical? They are not. The for‑of syntax is newer and was created specifically for iterables; arrays, sets, maps, and the like. The for‑in syntax was there since the language was created, or around that time, and it is meant to enumerate object properties. Say you have an object with some properties and you want to get those properties and values. You can do that with the for‑in loop, and I'll show that in a moment. So the core difference is purpose and applicable use cases, but is their behavior identical? No, not always. With the for‑in loop, the order of iteration is not guaranteed. With arrays, it often is the same, but it's not guaranteed. And inherited properties are also enumerated. It's considered a bad practice, but you may be working in a code base where someone took a built‑in type, the array for example, and extended it, gave it an additional property or something. Now if I run the code again, we'll see that the for‑of loop ignored the new property. It truly only iterates over the contents of the array, whereas the for‑in loop included the newly created property. You probably don't want that, and that's a big reason not to use it to loop over arrays and other iterables. But if you have an object such as this one and you want to loop over the properties and values, then you should use for‑in. In fact, you have to. You can't use for‑of in this case. It won't even work. Let me show you. For property of the object, print the property, run the code, and boom, TypeError, the object is not iterable. Let me comment this out. But if I use the for‑in syntax, I can get access to both the property and the value. Also, if I want to skip the inherited properties, I can use the hasOwnProperty check, like so. Also, if I want to skip functions or other types, I can use the typeof check, like so. Okay, run the code, and see here, both properties and values and the declared function was skipped because of the if check. For completeness' sake, I should add that you can still replace the for‑in with the for‑of loop. All you have to do is use the Object.keys method to get the properties or Object.entries, and that gives you both keys and values. If you watched the previous module, you should be familiar with the syntax. So this is to show that for‑in isn't really irreplaceable. You can get away with using just the for‑of syntax, unless you want to get the inherited properties. Let this slide be a quick cheat sheet for you. For‑of is for arrays and other iterables. If you want to use it on objects, use the keys and entries methods. If you want to use the for‑in syntax, then use it only on objects. You can use it on the arrays, but avoid it, as you might get unexpected behavior in some cases.

The for-await-of Loop
The for‑await‑of is the last loop on our list in this course, and as you might be aware, the await keyword means that we're dealing with asynchronous code. This means that there is a prerequisite for this clip. You need to understand promises and async functions in Javascript. If not, you need to watch either an existing JavaScript Promises and Async Programming course or the newer Asynchronous Programming in JavaScript, which may not be released at the time of publishing this course. If you like reading books, then there's an awesome free e‑book at exploringjs.com with a big chapter on async programming that I can highly recommend. There are multiple ways you can write an asynchronous loop, for example, iterate over promises, like so. Or for sequential execution, use the await keyword inside the loop body, like so. And finally, write the for‑await‑of loop, like so. All these loops have different behaviors and purposes, and to explain everything would mean to make this course about async programming, and I'd like to avoid that. I want to focus on the for‑await‑of exclusively. And I will say this, the need for it arises when you're looping over an asynchronous iterator and the computation of the current iteration depends on the previous iteration, or one of the previous iterations. So you get something, you need to process a thing, and, for example, the data in that thing contains something needed for the next iteration. It was really tough to find a simple, yet real‑world example, and I must say thank you to the javascript.info website. It's an excellent resource for all things JavaScript, and they provide a great example of the asynchronous for loop. I will use their example, but with some code modified. Suppose you want to scrape GitHub and derive some stats. You fetch the main endpoint. It provides you with a bunch of links to follow, and one of them is the repository_search_url. We can use it to search for, let's say, JavaScript repositories, like so, and this gives you some results back. But since there are thousands or perhaps even millions of results, they are paginated. The first page shows just the first 30 repos. If I search for the full_name field, I will get 30 matches, so 30 per page. And after, if I open up the Network tab and hit Refresh and look at the response headers, see here, the response contains a link to the next page, the next set of data. And as we collect data, once we finished with one page, we want to follow the link to the next page. In code, this can look like this. Here's an async generator, and that's another advanced topic, but it basically generates some values for us. It could be numbers, strings, or in our case, entire JSON objects. And this code says, while the URL is not null, send a request to the specified GitHub URL. Save the response, get the JSON body of the first page of results, get the nextPage link, and set it to the URL. If we run out of links, then this will be set to null and the loop will end. But until that happens, iterate over the JSON body items and yield, or return, the repo. Every page contains 30 repos, so this for loop runs 30 times before the execution flow comes back to the top of the while loop. So this async generator can now be placed in the for‑await‑of loop, and we can do something with the results that we pull out of the generator. Here we just get the full_name of each repository. This field must match what you see in JSON, and we'll stop at 50 repos so it doesn't take too long. And since this is async code, we have it all wrapped in an anonymous async function or this will not work. Okay, run the code, and with a small delay because this code is making network requests, we have the names of the first 50 JavaScript repos. The first 30 came from page 1 and the other ones from page 2, and we had to collect the first 30 before we could follow the link and collect the others.

Considering Loop Performance
A constant source of debate regarding loop performance is which loop is faster and how to make any of them faster. In theory, there are two things you can try and do to speed things up, optimize how much work is being done per iteration and reduce the number of iterations needed. Here's a classic array written the usual way. Multiple operations happen every iteration, several in the loop's head and then whatever you put in the loop's body. A frequent piece of advice is to extract and cache the length lookup. After all, if you have 1,000 iterations, that's 1,000 small operations that add up, at least theoretically. So you can either cache it right inside the header or move it just outside the loop, like so. This advice probably became widespread after the book High Performance JavaScript was published. It claims that this makes looping faster up to a point, especially in Internet Explorer. But that book is from 2010, it's been over a decade, and so what was valid then isn't necessarily valid now. JavaScript engines evolved too. They cache, optimize, and otherwise improve their performance, and in recent years, I found no convincing evidence that shows this optimization makes any significant difference. One thing many do agree on is that before each method is 'somewhat slower', because there's an overhead of an extra method caller on each array item. But that still doesn't mean that you should completely avoid the forEach. Many times, you only need to iterate over a small dataset up to 100 or 1,000 elements, and if the forEach is what you prefer, then adding a millisecond or two to the overall execution time is probably not something you should be worried about. On the other hand, breaking out of iteration early can indeed save you time. If you need to go through the entire collection, there is little you can do about it, but if you are searching for a single match to satisfy some condition, remember to use the break keyword. Better yet, use the find and some methods when they are a logical fit. The find method returns the first element in the provided array that satisfies the provided testing function and the some method returns true as soon as it finds at least one element that passes the specified predicate, or a Boolean test. To conclude, if you can end the search early, please do so, but otherwise, don't waste time with premature optimization by trying to apply exotic hacks thinking you are significantly boosting performance. Proper performance testing is a tough skill to learn, and any optimization must be carried out after it was deterministically proven that a particular piece of code is indeed a bottleneck.

Branching and Its Pitfalls
If-else With or Without Braces
Hello, and welcome to the last module of this course on branching. If you already know how to write if‑else, switch statements, and ternary expressions, that's great, but I'm sure I can show you a few tricks that you can use and pitfalls to avoid. Let's dive right into what is arguably the simplest statement, the if‑else. Here's a simple object with data. Let's say we want to buy it if the price is equal to or below 100, so if stock price is less than or equal to 100, Buy. But did you know that you can write it without the curly braces and even on the same line, like so. JavaScript allows this. But, did you know that this is allowed only if you have exactly one statement per clause. Watch this. If I add a second executable statement inside the if clause, then visually it's still clear to us what is going on, but if I run the code, we get a SyntaxError: Unexpected token 'else'. And it's rather confusing, because we know that the else keyword is there and it makes sense and it worked just a moment ago. Well, not to JavaScript and also not to Java, which follows the same logic. Without the braces, it could avoid being confused with only one semi‑colon‑delimited statement. Anything beyond that, and you have to add the braces, like so. Run the code, and it works again. This brings us to a coding best practice. Since you must use the braces at least sometimes, you might as well always use them for code style consistency reasons. It may add a few lines of extra code, but nothing too dramatic. And remember, programming is not a competition to see who can fit the most functionality in as little screen space as possible.

The Pitfalls of switch
The switch statement is a good replacement for the if‑else when you have somewhere between 3 and 10 branches, or you know there's a limited number of values that you need to switch through. It's a good replacement because it makes the code less verbose. Let's see how we could implement this generatePortfolio function based on riskTolerance. It should return a Portfolio sample object. Low‑risk portfolios should have more bonds and high‑risk portfolios should have more stocks as a percentage of the total portfolio. Some might argue that this advice is outdated, but we're not here to discuss real‑world investment advice. So, switch on the riskTolerance and say if it's low, then return a new portfolio with more bonds than stocks. If medium, then it's another portfolio and if it's high, then yet another one. Okay, if you know switch statements, can you think of anything else? Is anything missing? The default branch is not mandatory, but almost always a good practice. We use the default keyword, and here we can either throw an error and say that the value passed in was illegal, or we can use some logic and return some value, a default portfolio with a balanced distribution, whatever the business requirements say. Okay, let's invoke this function with two values, one that exists and another that doesn't exist, and hence will lead to the default branch to be used. Run the code, and this looks correct. This is a concise and clean switch statement, but you might find alternative ways of writing it. Let's write a version 2 of this function, and now we will declare a portfolio variable just before the switch statement. And now, again, switch on the riskTolerance. If it's low, create a portfolio and assign it to the variable. Do the same thing in other cases. I'll fast‑forward the video. There, this more verbose version makes sense if you need to do some additional operations that are common to all branches and you don't want to duplicate that code in every case branch. Now, look at the code and check if everything is as it should be. There's at least one problem, but it quickly becomes evident the first time you use this function. It doesn't return the variable, and if you don't, you'll hit a runtime error related to the value being undefined. Is there anything else missing? Let's find out. Invoke it with some valid value, run the code, and no, this doesn't look right. This number should be different, and that is because I forgot the break keyword in every case clause. During the execution, the code did match the input value correctly, but because there was no break, it fell through. This is how it's called, the code falls through, meaning it keeps getting executed sequentially and so whatever value you input, it will always be overwritten by the last case or the default branch of the switch? If I add the break statement everywhere and run the code again, now we get the correct value because we left the switch right after the first match. But why didn't the code fall through in the first version? Because of the return keyword in every branch. The return keyword makes the flow jump out of statements in general, switch or other. And this is why, whenever possible, I prefer to use the return keyword. It makes the code shorter and it's less error prone because you can't forget the break. You simply don't need it. One more thing that people sometimes forget, you can collapse or group multiple case statements if they lead to the same result. So instead of writing a case clause for every month, like so, you could collapse them and make them all return the same value, like so. It makes your code even more concise, but it remains readable.

Falsy and Truthy Values
Are you aware that all values in JavaScript are either truthy or falsy. The rule is simple. The Boolean false, obviously zeros, an empty string, null, undefined, and not a number are all falsy. Everything else is truthy. This means that it is common to see code like this. If the value is Truthy, then do this, otherwise, do that. It's the short version of this code: if the value coerced to a Boolean is true, then do this. Obviously you don't need to write such verbose code yourself. This has implications, though. In fact, we could improve our code from one of the previous modules. You might remember that we collected low beta stocks for investors who don't like to risk much. As a reminder, low beta stocks are stocks with prices that don't move up and down as much. But there is at least one stock that has missing data. Missing data is typically falsy. Did we handle that? If I open up the console again and hit Refresh and expand, we'll see that we included GitLab, even though there is no data on this stock. The cell is empty. Here's our code from before, filter for stocks with low beta. But we're not considering missing data. What we can do is simply add a check to the Boolean expression, like so. I won't add this check in the other version so that we can see the difference in results. And this will evaluate if the value is truthy or falsy, and filter accordingly. Given the dataset, all of these numbers will be evaluated as truthy, and this one stock without any data, or specifically an empty string, will be falsy, and thus filtered out. Refresh the page, and see here one version without the check for truthiness keeps the GitLab stock and the other version filters it out. So checking for truthiness is quite common, but it has pitfalls that you need to be aware of. Suppose you have two stock objects. With the first one, we have the data on the dividend that the company pays. It just happens to be 0. And with the second one we don't have the data, marked as undefined, but it could be null. So the data is present in the first one, but absent in the second one, but both of these values are considered falsy, and this could lead you into a trap. Suppose you were tasked to collect stocks that don't pay any dividends, so you iterate over the stocks and say, if the stock's dividend is falsy, then print that this company does not pay a dividend and add it to the list. With our example, both stocks will be added to the list, but strictly speaking this code is at least misleading, but more likely it is buggy. It is probably more correct to make a distinction between these two stocks. Google doesn't pay a dividend, the data says so, but in the case of Microsoft, we should probably say we don't know, we're not sure. Better refresh the data one more time or add it to a separate list of stocks with missing data. I hope this provides a clear example of where treating 0 and absent values might create the wrong outcome. Here's another pitfall example. Suppose you need to calculate the so‑called dividend yield. If a company pays $1 a year for every share you own and the current share price is $100, then your dividend yield is 1%. If another company pays the same, but its share price is $50, then the yield is 2%. But you need both values, and you're in trouble if they are absent, so you could add some defensive code, like so, and throw an error with a useful message. With this, we can invoke it with valid values, and let's also invoke it with a missing value, we simply don't provide the second parameter. Run the code, and the results are what we expected. Again, this works fine until you get data from somewhere, process it, and it turns out that the dividend per share is 0. In fact, many growth companies don't pay a dividend, and 0 is a completely normal value here. In these cases, we're going to produce false positives or false alarms. In such a case, we would need to understand the business logic a bit better and implement smarter logic. In our example, the dividend per share being 0 is normal, but then we know the yield is 0. The price can't be 0 or negative, that could indicate corrupted data, and we could have a dedicated error for that too. And if the parameters pass those checks, then we can catch null and undefined in the next clause and throw another error. And finally, if we reach the bottom, then the values must be safe to use for calculations. I'm not saying this is bulletproof code, I'm only trying to show you that things often can and should be more complex than a simple check for truthiness that you might start with.

Using the Coalescing Nullish Operator
I'll assume you know the ternary operator. It's a concise alternative to an if/else statement when you need to decide between two values. If the expression is true, then get a. Otherwise, be. Simple. As usual, it often gets more complicated in real projects when you constantly have to deal with absent data. And you often want to just check if the data is present, meaning not undefined or null, then just use that data. Otherwise, use backup or fallback data. Let's see what this could look like in code. I have this function getStockData, and it pulls the same stocks from the same HTML table. But I'm doing this in a separate file. And for this to work, we need to declare it in a separate script tag below the main script tag like so. Okay, so we get the stock data, and it should be an array. But what if something goes wrong, and we get undefined or null instead? Well, one way is to write an if/else statement and say if it's not null or undefined, then do something with it. Else, getBackupStockData, which is just an array with hardcoded values. This works, but this is quite verbose. We could write the same with a ternary expression like so. But we could reduce the check like so. Notice we're using a non‑strict equality operator here. This is a widespread hack. And with this, we are checking for both null and undefined because null loosely equals to undefined. If you're not sure how this works, you can read up on equality and strict equality in JavaScript on mdn web docs. There is a complete table showing you how loose equality works when comparing different types. And we can see here that null loosely equals to undefined. All right, so this is an improvement. We achieved the same thing with less code, but we can do even better and use the nullish coalescing operator like so. This does the following, get the value, evaluate if it's null or undefined. If not, use it. Otherwise, get the value from the right side of the operator. Short and simple. This is a relatively new operator introduced in ECMAScript 2022, and you should already see it work in all major browsers and engines. If you need a cheat sheet, then feel free to capture this screen. These two expressions are equivalent.

Further Resources
Whenever I can, I try to mention free resources for further study that I can personally recommend. If you enjoy watching video tutorials, then Pluralsight has dozens of great JavaScript and Node.js courses that you can watch. If you like reading books, then I can recommend two of them, and I already mentioned them throughout the course. First is the javascriptinfo website. Its design is simple and elegant. The information and coding practices are kept up to date, and it even provides simple interactive knowledge checks. The second website is exploringjs, and it also gives you free e‑books, covering both beginner and advanced topics with lots of examples. I would like to thank you for taking the time and watching the course. Feel free to give it a rating. And if you have any feedback for me, please leave a comment. I hope you enjoyed watching it as much as I enjoyed creating it. Thank you for watching and happy coding.