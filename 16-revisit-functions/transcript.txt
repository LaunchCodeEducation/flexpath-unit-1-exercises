Course Overview
Course Overview
Hi everyone, and welcome to my course, Functions in JavaScript. My name is Dan Geabunea, and I'm a Passionate Software Developer with over a decade of experience building web applications. You can find me on Twitter at @romaniancoder. Functions are the fundamental pillar of every programming language. In fact, our programs would achieve very little if functions did not exist. This course will teach you the ins and outs of JavaScript functions, which are essential for developing complex web applications using this language. Some of the major topics that we'll cover include defining and invoking functions, passing data to function parameters, using methods, getters, and setters in JavaScript classes, understanding lexical scope and closures, and learning how to deal with asynchronous code. By the end of this course, we'll have all the skills and knowledge needed to effectively use functions, which is essential to developing complex back end or front end applications in JavaScript or TypeScript. Before beginning this course, you should be somewhat familiar with Javascript as a programming language and with some of the newest ECMAScript developments. I hope you'll join me on this journey to learn how to effectively use functions in JavaScript with the Functions in JavaScript course at Pluralsight.

Defining Functions
Intro
Hi everyone, and welcome to the Functions in JavaScript course on Pluralsight. My name is Dan Geabunea, and I have been working with JavaScript as a full stack developer for the past 10 years. Therefore, I am grateful and excited to be your instructor for this course, mainly because functions are such an essential part to JavaScript programming. This course uses the latest JavaScript language specification, ECMAScript 2022. However, the concepts taught in this course are core aspects of JavaScript that don't tend to change much over time. In fact, the vast majority of what I will demonstrate should be supported by all major engines and browsers. Functions are essential to computer programming as a whole, and that's because without functions computer programs are basically useless. They can't do anything. Programs without functions are like a factory where all the workers and assembly robots don't exist. You may have the information required to do a particular job and the resources you need, but without the entities that actually do stuff, you will not build something of value. This course recognizes the importance of functions in JavaScript programming and is intended to be a deep dive into functions. You'll start by learning how to declare and call functions. Then you'll see how to use parameters and pass data to functions. After that, we will look at methods, which are functions in the context of an object or class. I will also cover getters and setters and show you how to use them to increase encapsulation. Then, we'll take things up a notch and understand what scope and closure mean in the context of a function. Next, I will try to demystify the "this" keyword and show you what it means in different scenarios. And finally, we will talk about asynchronous functions, and I will show you various ways to deal with them. By the end of this course, I'm confident you will learn how to use JavaScript functions effectively in your own projects. Obviously, this will help you become a better JavaScript developer because you will understand how to leverage the full power of JavaScript functions. At the same time, you'll also become a better TypeScript developer. At its core, TypeScript is still JavaScript, so you can use what you learn in this course and apply it to TypeScript applications. But that's not all. JavaScript functions are framework agnostic. You can apply the skills you learn in this course in Node projects, Angular applications, React applications, or legacy web applications that use jQuery or Vanilla JS. Now, if you want to get the most out of this course, I highly encourage you to try the demos. You can code along with me or download the source code and try them out separately. When it comes to programming, practice is essential. Speaking of source code, you can find it on GitHub or as course assets. The code for each module is located in its own dedicated folder. To make things easier, I added two subfolders for each module. The first one is called before, and you can use it to code with me. The second one is called complete, and it contains the working solution. To try out the demos, you will need a text editor. I'll be using WebStorm, and that's because it's my favorite IDE, but feel free to use any editor that makes you happy. VS Code and Sublime are also excellent choices. And if you don't want to install anything, there is StackBlitz, which is a fantastic online JavaScript IDE. You can create an account there and use it for free to prototype JavaScript applications.

Defining Functions
All right, it's time to kick off this course. In this module, we'll start by understanding the building blocks of a function in JavaScript. Then, I will show you four distinct ways to declare functions. And, yes, you heard correctly, JavaScript gives us many possibilities to create functions. We have function declarations, function expressions, arrow functions, and the function constructor. Last but not least, you'll learn how to call functions and create functions that invoke themselves, also known as IIFEs, or immediately invoked function expressions. So, simply speaking, a function can be viewed as a block of code that executes a specific task. A function is a code construct that executes stuff. Functions in JavaScript have a similar structure to functions in other programming languages. Functions can have a name, they can have a list of parameters, they must have a body where all the magic happens, and they may have a return statement if the function needs to output the result back to the caller. You may wonder why I used a green checkmark icon for the body, and that's because the body is the only mandatory component that you need to declare a function in JavaScript, everything else is optional, and you will see that in a moment. As I mentioned earlier, JavaScript is a very flexible language. We have four different ways to declare functions. You can choose a function declaration, which is kind of the standard way of declaring functions, especially if you come from an object‑oriented programming background. But then we can use a function expression, where we assign a function to a variable. We can also use arrow functions to define a function. And finally, we can use a function constructor to create functions dynamically. Let's go ahead and check them out in detail.

Function Declaration
Let's start with using the function declaration. I think the best way to understand it is with an example. To define a function using this approach, you need to start by using the function keyword. Then, you need to type the name of the function, in this case, convertToLiters. If you have any parameters you need to provide, you can pass them between parentheses. In this example, there is just one. After that, there is the body, which is enclosed in curly braces, and it contains the logic of the function. In our case, it converts gallons to liters. And then if you need to return result, you can use the return statement, like we're doing in this example. An essential thing to mention up front is that functions are not executed when defined. This code does not do anything. To use this function, we need to invoke it, we need to call it. And in the case of function declarations, we achieve that by using the function name followed by parentheses, in which we provide the arguments, if any. But functions don't need all these elements. Let's take a look at a different example. This function, which is called printTime, has no parameters and no return statement. We still need the function keyword, the name, and the body. That being said, let's try this out in a code editor.

Demo: Function Declaration
All right, it's time to write some code. Let's see how to create a function using the function declaration syntax. Before we write any code, I would like to present the general approach that all the demos will follow. I usually work up with two files, an index.html and a main.js. The index.html file really contains the title for the demo, and it loads the main.js script. And, as you can see, all the magic is happening within the script. So, unless I specify anything differently at the beginning of the demo, this is what is actually going to execute all the code that I write in main.js. And that being said, let's get down to business. I want to create a new function that converts gallons to liters, and I want to use a function declaration syntax for that. So, let's go ahead. We'll start by using the function keyword followed by the function name, which is convertToLiters, and I want to provide a parameter named gallons. We'll open and close curly braces and then add the body of the function inside the curly braces. All right, inside the body, I'm returning the converted result to the calling code. And as you probably know, functions by themselves don't do anything. If you look at the Console tab, you'll notice that we get no result, and that's because we did not call the function, we did not invoke it. So, let's go ahead and do that. Hit Save, and now we're getting the result displayed on the console, and that's correct. That's it. That's how easy it is to get started with JavaScript functions.

Function Expression
Another way to define functions in JavaScript is to use a function expression. Let's look closely at this code and compare it to a function declaration. First, we can see why this style is called the function expression. We are assigning a function to a variable. In this case, we are assigning the conversion function to a variable called convertToLiters. Most of the time, a function defined in this way is anonymous. Notice that there is no name after the function keyword. We could add the name after the function keyword, which is usually helpful if you want to implement recursion, but typically that is not the case. All right, so if the function is anonymous, how can we call it? And that's where the variable comes to the rescue. We can use the variable to execute the function. In our example, to get the result, we can call convertToLiters and pass a number, let's say 10, as an argument. Okay, we know how to define functions using expressions and how to use function declarations. But are these styles identical? Do we get the same result? Well, not really. A significant difference between function declarations and expressions is that function declarations are hoisted. Hoisting is the capability of JavaScript to use variables before they are declared and to call functions before they are declared. Take a look at this code. We are calling convertToLiters before we actually declare the function. Surprisingly, this will work, and will yield the correct result. This happens because internally JavaScript moves the function declaration to the top of the file, and that's the reason why we get no error when we try to run this code. However, even though this code works, it's not really a best practice, and I certainly do not encourage you to write code like this. But it's good to know that this style of writing code works in JavaScript. Now, what happens when we try to call the same function, but when it is defined using a function expression? This time, we actually get an error. That is because function expressions are not hoisted. In this case, the function definition is not moved to the top of the file. Thus, the runtime has no way of knowing what convertToLiter actually means. All right, so knowing all of this, you may be wondering which definition style should you prefer? And like all things in programming, it really depends. If you want to eliminate hoisting and its associated errors, I would say function expressions are probably a better choice. On the other hand, if you are a disciplined developer who declares functions before invoking them, I don't see much harm in using function declarations. In fact, sometimes I prefer function declarations because they seem more natural to me. And I also use a Linter like ESLint, which can help me ensure that I never use a function before I actually define it. There are rules in Linters, like no use before define, that prevent these kinds of errors from happening.

Demo: Function Expression
In this demo, you will learn how to define functions using a function expression. As a matter of fact, let's go ahead and refactor this function declaration into a function expression. First of all, I'm going to get rid of the function name. Now I will create a new variable and assign it to the function. I name this variable convertToLiters so that the code below executes. And that's it, this is a function expression, and if we save the program and take a look at the output, we'll notice that it still works as expected. Awesome! Now let's see what hoisting is all about. I will go ahead and move the function invocation before its definition. After I save, you'll notice that we get an error, Cannot access convertToLiters before initialization, and that makes perfect sense, because convertToLiters is a function expression and function expressions are not hoisted, so convertToLiters doesn't exist at the time we invoke it. Now let's see what would happen if we change our function back to a function declaration. I hit Save, and now we get back the correct result, and that's because function declarations are hoisted, which means, behind the scenes, our function is placed at the top of the script file, and that enables the console.log line here to function properly. Now, obviously, as I mentioned before, it's not really a good practice to call functions before you declare them, so you can either be careful, you can choose a linter that will warn you when you make these types of errors, or you can choose no function expressions or other type of definitions to make sure that your declarations are never hoisted.

Arrow Function
It's time to move on to the third way of defining functions, which is the arrow function syntax. Arrow functions might be confusing, so let me start with a brief definition. An arrow function in JavaScript is a compact alternative to a function expression, but with some limitations. An arrow function is compact, meaning it takes less code to write, and it has limitations, meaning there are scenarios where they are not the best choice, so let's go ahead and elaborate on that. I know a piece of code is worth 100 words, so let's start with a quick comparison. This definition uses a function expression. It is a function that does not have a return type and it just counts two numbers and displays them on the console. Now, as I said earlier, arrow functions are more compact, so in our example we can eliminate the function keyword and introduce an arrow between the parameters and the body. And the result is this, we have the same function. The parameters are in parentheses just like before, then we have the arrow, which gives this declaration style's name, and then we have the body in curly braces. Cool, but this is not that much more compact. Looking at the two functions, there is hardly a difference, and that is correct. The good news is that we can make them even more compact if the function has a return type and if the function is a one‑liner. So let's take a look at another example. This function converts gallons to liters. It is a one‑line function with a return type. Now let's try to convert this one to an arrow function. Step one, we remove the function keyword and we introduce the arrow. Because we have a single parameter, we can remove the parentheses around the input parameters, so we can rewrite the function like this. Cool, this is starting to look better. And now, because the function returns a value and is a one‑line function, we can delete the return keyword and the curly braces. And voila! This is an arrow function in all of its glory. And yeah, it's definitely more compact and easier to read. So, does this mean we should forget about the other definition styles and use arrow functions throughout our code? Well, not so fast. Arrow functions have some limitations and characteristics which do not make them suitable in all scenarios. Just like function expressions, arrow functions are not hoisted, they cannot be used before they are declared, and that is a positive trait, so kudos to arrow functions. Now, unlike function declarations and function expressions, arrow functions cannot be used as constructor functions. Also, they cannot access the arguments object, unlike their siblings. But the most important thing to consider when using arrow functions is that they do not have their own "this" binding. This means you should not use them as methods or when handling browser events. Now don't worry, we'll talk more about it in a future module, however, I do want to discuss the other limitations I mentioned here right now. I said that arrow functions cannot be used as constructor functions. So if you define an Aircraft like this and decide to create a new object out of it, bam, you'll get an error, Aircraft is not a constructor. And the fix is quite simple, just use a function expression or a function declaration style, and you'll be just fine. The other limitation has to do with the arguments object. Now, in JavaScript, functions can access an object called arguments, which contains all the arguments passed to the function. In this example, when you call sum of 1, 2, and 3, the arguments object should contain the values 1, 2, and 3. However, because the sum was defined as an arrow function, we will get an error when trying to access and read the arguments object. This code will not work as expected. And, again, the solution is quite simple, change the definition style and use function expressions or function declarations.

Demo: Arrow Function
It's time to write some code and see arrow functions in action. I will use the same approach and try to convert this function expression into an arrow function. Let's see just how compact functions can get. I will start by removing the function keyword, and then I will add the arrow before the body. All right, we now have an arrow function, but I think we can shrink it even more. First of all, we can remove the parentheses surrounding the parameter since we are dealing with a single parameter in this case. And, because this is a one‑line function which is returning a value, we can actually get rid of the curly braces and the return statement. Awesome, and we end up with this nice one‑line function that is very, very expressive. I'll save the project, and down here in the console we can see that we end up with the correct result.

Function Constructor
In this chapter, we will look at a final method for creating functions, the function constructor. You can use a function constructor to create a new function object from a list of arguments and a body provided as a string. This definition might seem a little odd, so let me show you an example, and you'll see that it will make perfect sense. I will create a new variable called convertToLiters that will hold our new function, and then I will create a new function object, and I'm going to pass in the parameters, in this case a parameter named gallons, and then the function body as a string. All right, now I know this looks very bizarre, but trust me, it works quite fine. And this is equivalent to this arrow function. Notice the bodies are the same and the parameters are the same too. It's worth mentioning that you can also omit the new keyword and create a function in a more abbreviated syntax, something like this. We still have the Function object, where we need to pass in the parameters and the body, but we can omit the new keyword for brevity. You're probably wondering why in God's name would you ever use such a strange way to create a function, and that's a pretty good question, but it turns out there are some use cases for it. One reason you might want to take this approach is if you plan to create functions dynamically, on the fly. You can build functions based on your runtime context, and I think this is probably the only situation when you would use function constructors, and that's because using this approach comes with some serious drawbacks. First of all, your code will become much more error prone. After all, you're creating functions in strings, which is not really the best of ideas. And then there's also security issues. It's not very safe to use this approach, but you might find it in legacy code or in some limited occasions, so I thought it was worth mentioning.

Demo: Function Constructor
In this demonstration, you'll see the most bizarre way of declaring a function, using the function constructor. Let's rewrite our arrow function using a function constructor. I will start by deleting the arrow function, and I'll just keep the constant called convertToLiters. In order to create a new function using the function constructor, we need to create a new object of type Function. We need to provide the parameters. So the first arguments to the Function object are the parameters of the convertToLiters function, in this case, one parameter called gallons. And now we need to provide the body of the function as a string. All right, if we want more brevity, we can probably remove the new keyword. And if I save the program, notice that it works and we get back the correct result. And while this code works, I don't encourage you to start creating functions using this approach. Creating functions using strings is a terrible idea, and you'll end up with a lot of bugs and potential security issues.

Recursion
As in all programming languages, functions in JavaScript can call themselves. This is called recursion, and it's a technique that you can use to solve various problems more easily. In this section, I want to show you how to implement recursion in JavaScript, so let's take a look at an example. I created a function called decrementAltitude, which should gently decrease the altitude of an aircraft until it lands. We can accomplish this using a loop, for example, but let's get out of our comfort zone and use recursion. First of all, we log the current altitude or do something with it. Then, if the altitude is greater than 0, we can call the same function, passing an altitude smaller than the current one by 100 feet. So, if we invoke this function with 500 feet as an argument, the function will print 500 feet and then call itself with 400 as an argument. This will then print 400 feet to the console, and then the function will call itself with 300 feet, and the process goes on until the condition evaluates to false and the aircraft safely lands. So, intuitively, I think you already spotted the two main elements that make up a recursive function. A function must call itself, and, more importantly, you need to have a stop condition. You need a way to stop recursion, otherwise, the function will call itself indefinitely and thus cause your program to break. Looking back at our example, we can easily spot these elements. We are calling the same function on this line, and we have the stop condition on the line above it. If we remove the stop condition, for example, the function will look like this, and if we rerun the function, you will end up in an infinite loop until eventually the program will crash with the Maximum call stack size exceeded. That's not something that you want to experience, so when using recursion, please pay attention and make sure you always include a valid stop condition that will break the recursive chain.

IIFE (Immediately Invoked Function Expression)
You now know four distinct methods to create functions in JavaScript. You can go ahead and impress your colleagues with your new JavaScript skills. But before you do that, I want to talk a little bit about IIFEs. Now, IIFE stands for Immediately Invoked Function Expression. So, what on earth are these? Let's find out. And IIFE is a function, a plain old JavaScript function, that executes immediately after its declaration. You don't have to invoke it yourself afterwards, it kind of self‑executes. And that is very useful, especially in scenarios where you need to initialize something or execute some code immediately. Creating an immediately invoked function expression is relatively easy. You start by declaring the normal function, then you wrap it in parentheses, and finally, you invoke it by appending an open and closed parentheses after that. Let's see an example. On the left, I created a normal function that prints a date. This code doesn't do anything, we just declare the function, so to execute it, we actually need to call it like this. Now, let's try to convert this function into an Immediately Invoked Function Expression, following the above mentioned steps. We start from our initial function and then we wrap it in parentheses. And then, we need to open and close parenthesis after that in order to invoke it. And that's it. This function will now be executed immediately after it's declared. I would also like to point out that you can create IIFEs using any function syntax. You can use function declaration syntax as I did here, but you can also use function expressions or arrow functions, it doesn't really matter.

Demo: IIFE (Immediately Invoked Function Expression)
It's time to see an immediately invoked function expression in action, so let's go ahead and write some code. For this demo, we will start from scratch. I want to create a new function that displays the current DateTime in a local format and put that value in the main header. Basically, I want to get rid of the static header and display the current date and time. Obviously, an immediately invoked function expression is well suited for this task, so let's go ahead and create one. Step number 1, we need to define the actual function. This function is pretty straightforward. I'm storing the current date in a local format in a variable called current, and then I'm using that variable to populate the h1 element in our HTML document. Okay, so this function is easy, but it doesn't do anything. If we want it to work, we have to manually invoke it, but that's not exactly the purpose of this demo. I don't want to manually invoke this function, I want this to be executed as soon as it is declared. So, step number 2, I will surround this function in parentheses, and step number 3, we can invoke it by opening and closing parentheses. I'll hit Save, and you can see that the function immediately executes after its declaration because we now get an updated header value, so this function works correctly. One last thing that we could do is remove the function name. We don't need to manually invoke the function, so there is no need to give this function a name. It can be an anonymous function.

Recap
At this point, I'm pretty sure you have a clear picture when it comes to declaring and invoking functions. In this module, you learned why functions are the building blocks of any programming language, and that's because they allow programs to do stuff in order to achieve a particular goal. JavaScript is highly flexible and allows multiple ways to define functions. You have the classic way of using function declarations, then you can use function expressions, arrow functions, and the function constructor. You must be careful which style you choose as it will impact what you can and cannot do with the function. For example, functions created using a function declaration syntax are hoisted, while the others are not. Also, arrow functions do not have their own this binding and should not be used as methods Functions are not executed until they are cold, which is the case for most programming languages. However, JavaScript gives us a way to immediately invoke a function after we define it, and that is by using an Immediately Invoked Function Expression. Now it's time to take our discussion further, so, in the next module, we'll discuss parameters and cover parameter scope using default parameters and the arguments object.

Passing Data to Functions
Function Parameters
In this module, we will make functions more valuable and flexible by using parameters. We'll start by understanding parameters and arguments, including the difference between these two concepts. Then, you'll learn how arguments are transmitted into functions by using pass‑by‑value or pass‑by‑reference methods. After that, I will explain how and when to use default parameters. You'll learn how to pass an indefinite number of arguments to functions by using rest parameters. Next, we'll take a closer look at the arguments object. And finally, you'll discover how to pass functions as arguments to other functions. As you can see from this overview, passing data into functions is quite an exciting JavaScript topic with many features awaiting you to discover. So let's start at the beginning. What are function parameters? To put it as simply as possible, they're just names given to pieces of data that the function can use internally. Notice that parameters have nothing to do with values. They are just names. Aliases, if you will. On the other hand, arguments are the actual values transmitted into a function when we call it. Inside the function, the value of arguments can be accessed by using the names in the parameter list. Let's take a simple example to understand this concept better. I created a function that converts gallons to liters. This function has a parameter named gallons, and it uses this parameter name to calculate the conversion. When we invoke the function, we can supply a value that the gallons parameter will hold. In our example,10 is the value. We say that 10 is the argument passed into the gallons parameter. Although they express different concepts, most people sometimes use these words interchangeably, and don't worry, it happens to me quite often. And usually it's not such a big deal, but I want you to be aware of the distinction. There are two crucial things for you to consider when using parameters in JavaScript. The first one is that in JavaScript functions do not have any data type information associated with parameters. The language doesn't do type checking. It's up to you to reason about that and choose meaningful names that make it easy for other developers to figure out the intended type. Then, be aware that JavaScript, unlike most languages, does not check the number of received arguments. For example, here's a function that draws a point. It has three parameters, x, y, and color. Well, it's perfectly fine from a JavaScript perspective to invoke the function with only two arguments, or with no arguments. JavaScript won't complain. The results will probably be incorrect, but you can certainly do this. You can also provide more arguments than needed, again, perfectly fine in the JavaScript universe. Now that you know the basics of parameters, let's roll up our sleeves and write some code.

Demo: Passing Data to Functions
In this demonstration, I will create an airport digital billboard that will display arriving flight information to passengers. During the demonstration, we'll see how to make functions more powerful using parameters. I created a simple HTML file containing some styles and an empty table. I added IDs to some of the HTML elements because we will need them later on to modify their content with flight information. I will not focus too much on HTML, so let's move to our main.js file. I want to start by creating a new function that will display a single flight in the arrival list. I named this function createFlightEntry. The function has three parameters, one for the flight ID, another one for the departure city, called from, and the third one to display the flight status. By using parameters, we are making this functional usable across any number of flights. Let's go ahead and implement it. Each flight will be a new row in our HTML table. So let's go ahead and create a new empty table row element. I use document.createElement function. Inside our table row, I want to create three columns and populate them with the information kept in the function's parameters. I created the flightCol where I passed the flight argument. Then, I created a fromCol and stored the departure. Finally, I created a third column that will hold the flight status. With this in place, let's add the columns to our table row element. We call the appendChild function on the table row and pass each row as an argument. Okay, now it's time to append this new row to our arrivals table. The table has an ID, which is equal to arrivalList. So, we can use that ID and grab the table, and then append our newly created flight row to it. Great. Our function is now complete. Because we have parameters, we can invoke this function multiple times with different arguments, and thus populate the arrival table. So let's go ahead and do that. All right, that was pretty easy. We just call the function and pass in the flight information. And now, if I save this, we can look at the site in the browser and we can see the billboard being populated. Cool. But wouldn't it be nice if the statuses were colored? Maybe green for flights that are on time and red for cancelled flights. We'll do that after we discuss about default parameters.

Pass by Value / Pass by Reference
You saw in the previous chapter how to pass arguments to functions, but I think it's worth taking some time to understand how these values are passed into functions at a slightly more profound level. You see, arguments are not treated the same based on their data type. Primitive types like numbers, strings or Booleans are pass by value. A new copy of that argument is created in memory, and that's what's getting inside a function. Objects, arrays, and functions are treated differently. They are pass by reference, meaning a pointer to those objects is transmitted to a function. All right, so why do we care? Well, let me show you some examples. Please pay attention to how passing various arguments can impact the original value of those arguments. I created a simple function that increments the parameter it receives. I create a new variable to hold the value 10, which is a number. I then pass that variable as an argument to the increment function and hold the result in another variable called newVal. Inside the function, we increment the argument. So, what do you think happened to our original value? If the answer is it remained untouched and is still 10, then you would be correct. Primitive types are passed by value. Under the hood, a copy of the value 10 was provided to the function, not the actual variable. This means that every change we make to the argument won't be reflected outside the function. Okay, let's look at another function called delayFlight. This one expects a flight to be passed as an argument. The function then modifies the duration property on that object and adds in the provided amount in minutes. What do you think will happen to the original flight object after we invoke the function? Objects are pass by reference. The function receives the memory address of that object, so it has access to the original object, and all the changes are propagated outside the function. The initial object duration in minutes is now 140 instead of 120. I know this sounds a little technical, but it is essential to have this in mind when changing the value of arguments inside your function. You don't want unexpected side effects to break your code.

Default Parameters
In this chapter, you'll understand what default parameters are and how to use them. In JavaScript, all parameters have an initial value of undefined. But in practice, that may not be very useful. Therefore, in JavaScript, we have a mechanism that enables us to provide an initial or default value to parameters. The best way to see why default parameters are excellent is through an example. I created a function that offsets a coordinate with the provided value. The function looks simple enough. We increment x and y with the offset. The problem arises when we forget to provide a value for the offset. In this case, offset will be undefined, and the result of the function will be a coordinate with not a number as values. Ideally, we want our code to break gracefully. If the user forgets to add the offsets, we could assume that offset is 0, for example, thus not altering the original point. In the old days, we added a check using an if statement, for example. If the argument is equal to undefined, we can reassign it to 0, but that is somewhat verbose. We can imagine this does not scale well for more complex functions. Instead, we could use a default parameter. In practice, we can assign a parameter with an initial value straight in the function's signature. Now the offset will be 0 unless you provide a different value to it, and the function's body remains clutter free. Sweet. Unlike other languages where only the last parameter in the list can be defaulted, in JavaScript, every parameter can have a default value, regardless of its position in the parameter list, and that presents some interesting problems. Let's take a look at this function. It calculates the sum of three numbers. The first and last parameters have a default value of 0. Invoking this function with no arguments will yield no number, which makes sense since we are summing up 0 undefined and 0. But what if we call the function with one argument? Well, in this case, a will be 2, b will be undefined, and c will be 0, so we still do not get an actual number. And when we provide two arguments, the result will be 2, since a is 1, b is 1, and c is zero. The main point is that default parameters don't change how arguments are assigned.

Demo: Using Default Parameters
In this demo, I'll show you how to leverage the power of default parameters in order to make your code more resilient. We'll continue where we left off in the previous demo. We have our Arrivals billboard, but all the status messages are white. I want to change the colors and highlight when a flight is on time, delayed or cancelled. One idea would be to use another parameter called color. I can now change the style of the status column and make it use our color parameter. From a coding perspective, this might look okay, but it kind of forces me to change how I invoke the createFlightEntry function throughout my entire application. I don't need to pass in a color argument everywhere. And I don't fancy this approach, because delayed or cancelled flights are quite rare. So wouldn't it be nice if I can set a default color of green and only append a color argument when a flight is delayed or cancelled. And it turns out, we can do that by using default parameters. I can actually give our color parameter a default color of light green, so let's go ahead and do that. If we look at our billboard, all the status codes are now green. Now, in the rare situation where a flight is delayed or cancelled, I can override the default color and pass in orange or red. So, let's identify the flights that are not on time and provide an additional color. Awesome! This billboard looks way better now.

The “arguments” Object
You might already know that JavaScript is a surprising and feature‑rich language, and that holds true when it comes to functions as well. All non‑arrow functions can access an array‑like object called arguments which contains all the arguments provided to that function, even when they are not declared as parameters. To truly understand this definition, there are two key expressions in it. The first one is non‑arrow functions and the second one is an array‑like object. For example, you can create a function that prints the arguments object to the console. As you can see, the function itself does not have any parameters, but you can still pass numbers to it and access their value using the arguments object. This object is like a local variable containing the values of all arguments provided to the function. I mentioned earlier that the arguments object is array like, but not an array. Printing it to the console reveals that it is more like a map. However, we can use it like an array. The arguments object has a length property, for example, and we can access elements by index. In our example, I'm iterating over the arguments object and I add the value of arguments to a sum, and rest assured, this code will work just fine. As I mentioned previously, the arguments object is not available in arrow functions. If I transform the previous function, which worked just fine, into an arrow function, our program will not work correctly. It will not sum up the arguments, because in this context this function does not have access to that arguments object. In modern JavaScript, it is a good idea to avoid using the arguments object. You can choose rest parameters as a possible replacement, and we'll discuss them shortly. The arguments object may be helpful in some instances, but it tends to lead to unintended errors and code that is not really very clean. As a general rule, all the arguments of a function should have corresponding parameters.

Demo: The “arguments” Object
As I mentioned, using the arguments object is not recommended, it's not an indication of modern JavaScript, but I want to prove this to you, and I'll use this demo as an opportunity to achieve this. Again, I will pick up from where we left off. I will change the createFlightPlan function to use the arguments object, and the first thing that I'll do is remove all the parameters from this list. I still want to call this function with the same arguments as before, but now I will use the arguments object to capture their value. Let's try to initialize the flight column using the arguments object. Remember that the arguments object is array like, so the flight ID can be retrieved at index 0, the departure can be retrieved at index 1, the status at index 2, and the color at index 3. Cool, but if we take a closer look at our browser, you notice that the flights that arrive on time are no longer colored in green, and that's because initially color was a default parameter which had green as a default value. Now, because we changed our approach, we no longer get the benefit of default parameters, so we're going to have to fix this issue using old‑fashioned programming. And now our program works as expected. The color can either be the value stored at index 3 in the arguments object if that exists, otherwise, it will default to light green. I don't particularly like this approach. I kind of took this to the extreme, but that was to better highlight some of the problems of using the arguments object. Now, first of all, it is incredibly error prone. Things will likely break if you change the order of parameters. In this example, createFlightEntry is a function with no parameters. We are basically not giving any information to the people who are actually going to use this code, so how should the developer know how to invoke it correctly? Only by looking at the internal details, which is against all modern programming best practices up to date. And last but not least, the arguments object isn't available in arrow function, and that's another limitation.

Rest Parameters
Rest parameters were introduced in ECMAScript 2015 and are extremely useful in day‑to‑day life. Rest parameters allow functions to accept an indefinite number of arguments and expose those arguments in a single array parameter. Let me demonstrate why they are such a powerful tool. Let's say we start with a function that calculates the sum of two numbers. In the future, we will probably be asked to create functions to compute the sum of three, four, or n numbers. What do we do? We don't precisely have no overloading in JavaScript. Well, it turns out that one approach would be to create multiple functions with different names for every scenario, like calculate some of the numbers, calculate some of the three numbers, etc., etc. Another approach would be to use the arguments object and access all the arguments from there. Both ideas, even though they work, are not really great, which is why rest parameters were introduced to solve these kinds of situations, to be able to provide multiple arguments that get stored under the umbrella of a single parameter. We can create a rest parameter using three full‑stop characters, or three dots, before the parameter name, as we did for the numbers parameter. This parameter is stored as an array, so we can iterate over it and calculate the sum of all the provided arguments. Therefore, all of these examples work. We can invoke calculateSum with, you know, two arguments, three arguments, or n arguments. Using rest parameter's allowed calculateSum to become a very adaptable function. Let's take a look at a couple of rules that govern how rest parameters can be used. A rest parameter is declared using three dots before the parameter name, and it is transformed internally into an array when you use it inside the function. You can use only one parameter as a rest parameter. You cannot have multiple rest parameters for a given function, and that makes sense because the JavaScript engine would have no way of knowing how to interpret the arguments and how to decide which one is which. And finally, only the last parameter in the function signature can be a rest parameter. All right, enough of the slides. Let's see them in action.

Demo: Rest Parameters
In this demonstration, we will use rest parameters to make our function able to receive an indefinite number of flights. I think we can all agree that using the arguments object was not a good idea, so I reverted this program back to its original working state. Right now, we are adding a new flight in the table by invoking the createFlightEntry function. If we need to show 10 flights in the list, we need to call the function 10 times. And this is not very elegant or easy to use, so let's wrap this logic and put it in a different function that can display an indefinite number of flights. And this is a great use case for rest parameters since they will allow us to initialize the billboard with any number of flights. The first thing that I'll do is create function skeleton that will display now an arbitrary number of flights. We can provide an array of flights as a parameter for this function, but I think this might be a little cumbersome. I don't want to force callers to wrap their flights in an array; therefore, a rest parameter might be a more elegant approach, so let's go ahead and add a rest parameter to our function. I call this parameter flights, and remember, to make it a rest parameter, you need to add three dots at the beginning of the parameter name. Rest parameters are stored internally as an array, so we can iterate each flight in our flights parameter and call createFlightEntry function from there. Let me go ahead and paste in the code. We can now remove the code below, and we can invoke our function called displayFlights, passing in an arbitrary number of flight objects. All right, we can see that our code works just fine, which is amazing, but I do want to highlight one small difference from our previous approach. The displayFlights function needs an arbitrary number of flight objects, and in order to call createFlightEntry for each of those flights, we need to deconstruct those objects and pass in the appropriate parameters to our initial createFlightEntry function.

Passing Functions as Arguments
Before we conclude this module, I would like us to look at a remarkable feature of Javascript, and that is passing functions as arguments. You might be more familiar with the term callback. A callback is a function passed as an argument to another function. They are usually used to handle something when an operation is completed. Callbacks are pretty present in Javascript code. For example, who hasn't seen or used the setTimeout function? This function has two parameters. The first is a function that will be executed when the specified time provided by the second parameter elapses. But let's understand how we (Unintelligible) this together by creating a higher‑order function from scratch. By the way, a higher‑order function is a function that accepts another function as an argument. I want to create a function that validates a flight plan object. If the flight plan is not valid, I want to let the caller decide what to do next. I want to give him the possibility to code now his own error handling. This is a good use case for callback functions because our program becomes more versatile. The handling of errors is not recorded in the initial function, but is provided when the function is invoked. I created the validateFlightPlan function. The first parameter is the flight plan we need to validate and the second parameter is a function that we will call if the flight plan is not valid. Now from a parameter point of view, there is nothing special in this function. We use normal parameters to hold functions. So let's move on. If the flight plan is not valid, then we can invoke the callback. We use the parameter that holds the function, which is called onErrorHandler, and then add open and closing parentheses. When we call the validateFlightPlan function, we can pass the flight plan and another function that will get executed when the flight plan becomes invalid. In this case, I just want to log the message error to the console, but you can recognize that. The sky is the limit over here. Each caller can decide how he or she should handle errors, and can modify how this program behaves. Passing inline functions is great for simple cases, but this is not a great approach when your callback becomes more complex. So, in the second example, we can define our callback as a regular function. I called it logValidationError. And then, we can use the function name without parentheses and provide it as an argument to the validateFlightPlan function. This code is far more readable, and I would suggest you use it more often than the first example. Now at this point, you might still be wondering when you should use callbacks, and probably the best use case for callbacks is asynchronous programming, when you are fetching some data over the wire or you are reacting to an event that arrives asynchronously. This is the scenario where callbacks really shine.

Demo: Callbacks
All right, it's time to get our hands dirty and explore how to leverage callbacks in JavaScript functions. I want to print the current time on the billboard header. That is a critical piece of information that passengers need to know. I also want to update that time periodically, let's say every second. I will start by creating a function that will print the current time in the header. Basically, I want to replace our initial title called Arrivals with the current time. (Working) This is an arrow function stored in the displayTime constant. It computes the current time in the local format and then it grabs an element with the ID of time, which is the header containing the text Arrivals, and updates its innerText to display our new current time. All right, we can now go ahead and invoke the function. I'll hit save. And in the browser we see the result, we now have the current time displayed on the billboard header; however, it is static, it does not change, we need to reload our page in order to force a change. So, if a user leaves the page and comes back 30 minutes from now, he will see a stale piece of information, and that's not good. Now, we need a way to execute this function at a given interval. This is where callbacks and the setInterval function can come in handy. SetInterval is a built‑in JavaScript higher‑order function that executes a callback at specific intervals, so we can go ahead and use it. The first argument that setInterval expects is a function to execute. In our case, that is displayTime. And remember, when we are passing callbacks, we are not using parentheses, just the function name. And now we need to pass an interval in milliseconds. I'll hit save, and now you can see that our time is live, our time updates every second.

Recap
All right, time for a quick recap. We started this module by looking at how pass by value and pass by reference work. Primitive types are passed by value, meaning a copy of their value is passed to functions, while objects are raised and function objects are passed by reference. In JavaScript, all parameters have a default value of undefined, but we can change that by using default parameters. We can specify a different initial value. In all JavaScript non‑arrow functions, the arguments object contains all the arguments passed into that function. We also discovered that rest parameters are a great way to pass an indefinite number of values to a function and how those values are stored in a single array parameter. And finally, we looked at how to pass functions as arguments. Callbacks are a pretty important part of JavaScript programming and are used extensively in asynchronous or event‑based programming. Functions that accept other functions as parameters are called higher‑order functions. In the next module, we will examine object‑oriented programming in JavaScript and how this relates 3:to functions. More precisely, we will discuss methods, getters, setters and how to use them in modern object‑oriented JavaScript code.

Using Methods, Getters, and Setters
Methods
Before we learn about some of the more advanced topics related to functions like scopes and closure, I want us to explore them from a different angle. I want us to look at functions from an object‑oriented perspective. So in this module, you will learn what methods are, as well as how to create and invoke them. Then, you'll understand how to use getters to access the internal data of an object. After that, you'll discover how to set data in an object in a safe way using setters. And finally, we'll try to implement encapsulation in JavaScript classes by making methods or fields private. Before you proceed, I would like to let you know that this course does not cover object‑oriented programming in JavaScript in detail. I want to briefly touch this topic because methods, getters, and setters are a special class of functions that are widely used in angular projects and modern JavaScript applications. But if you want to learn more about this topic or feel that some of the concepts discussed in this module are new to you, please check out the Object‑Oriented Concepts in JavaScript course by Jim Cooper on Pluralsight. That being said, I think a very brief definition of object‑oriented programming can be helpful. OOP is a programming paradigm that organizes software around objects. Our brains are wired to classify the world as a hierarchy of objects, and this makes object‑oriented programming the most natural and pragmatic way to write code. Objects are made up of data and behavior. Data is the information an object possesses like the age and name of a person. Behavior represents the actions that an object can perform using its data. In JavaScript, we store data in fields and represent actions using functions, but those functions in this context have a different name. They are called methods. A method is just a function defined within an object or class. Now let's take a look at two examples. On the left, I created an object literal representing an aircraft. It has an altitude field and a property called changeAltitude, which is a reference to a function. This function changes the aircraft's current altitude and prints it to the console. Because changeAltitude is defined within an object, we call it a method of the aircraft object. Inside object roles, we can define methods using the property name followed by a colon and then a function definition. To invoke this method, we need to use the aircraft object, dot, and then the name of the function, in this case, changeAltitude. On the right, I created an aircraft class. This class has an altitude field, which is initialized from the constructor. After that, I defined a method called changeAltitude, which modifies the altitude property of the aircraft. In this context, in the context of classes, methods are usually defined using a name, a list of parameters, and the body. If you are familiar with back‑end programming languages like Java or C#, this syntax should feel very familiar to you. And you can probably notice that within the class, the syntax for defining methods is a little different. There is no function keyword and no property to hold a function reference. To invoke this method, we first need to create an instance of an aircraft class. Then, we can use that instance, dot, and type the method's name, changeAttitude. I want to point out that both methods can access the internal data of the object using the this keyword. In the context of objects and classes, this refers to the current object on which the method is called. Now, don't worry, we'll discuss about the this binding later in the course. So far, I have shown you methods that act on actual objects, and these are called instance methods because they act on the object which invokes them. In this example, changeAltitude will modify the altitude field of the aircraftOne object. It only acts on that single instance. These are probably the methods that you will use most often in day‑to‑day programming. But JavaScript has evolved as a language, and now it fully supports static methods as well. These are methods that are defined at the class level. These are outside the scope of this course, but I wanted to briefly mention their existence. I want you to have this mental picture in your mind before we conclude this chapter. Methods are just functions defined inside objects or classes, nothing more, nothing less. So aside from a few exceptions, everything you learn about functions applies to methods as well. Methods have names. They can have 0 or many parameters. They can use _____ parameters. They can return a value or return nothing, and the list goes on.

Demo: Creating Methods
In this demonstration, I want to show you how to create and call methods defined in a JavaScript class. I have fired up IntelliJ, and I created a new class called FlightPlan. This class has a constructor which initializes free fields, callsign, departure, and destination. I want to add a new method now to print this information to the console. To create a method, we have to type its name followed by a list of parameters and the body, so let's go ahead and do that. Cool. We created a method, but how do we invoke it? Well, because print is an instance method, we first need to create an object from the FlightPlan class. I store this object in a constant called berlinToParis. And now to invoke the method, I'm going to use the object name, dot, followed by the method name, which is print. I'll hit Save. And we can see the method being invoked in the console window. Awesome.

Getters & Setters
Now that you have a clear idea of what methods are, let's look at two particular kinds of methods, getters and setters. These are special methods used to protect an object's internal data or state. Because they're methods, they operate on objects. You can define them in object literals or classes. A getter is typically used to access the data of an object, while a setter is used to mutate that data. That being said, let's take a closer look at getters using an example. I created a Passenger class with two fields of data, the firstName and the lastName. In this program, I want to use the full names of passengers, so I need a way to concatenate them. I could create the function that achieves this, but then we would end up with more boilerplate code. So instead, we get this nice syntactic sugar called a getter. This is what a getter looks like. It's a method with no arguments prefixed with the get keyword. A getter must return a value, so inside it, I build the fullName and return it. To invoke the getter, we first need an instance of the Passenger class. I stored it in a variable called John, and now, this is the cool part, I can access the full name as if it were a property of that object and not a function. Notice that I'm invoking fullName without parentheses. In most cases, this feels more natural than using standard methods. And obviously, behind the scenes, a getter is still a function, but we can call it as if it were a field. Sweet. Let's formalize what we discovered about JavaScript getters. They are plain‑old methods that must be declared using the get keyword before their name. Just like methods, they need an identifier or a name. A getter must have exactly 0 parameters. Now after all, its purpose is to retrieve information, not modify state. And when you invoke a getter, make sure to omit the parentheses use it like a regular data field. We can use getters for computed properties, just like we did in our example, just to simplify code. But more importantly, we can use getters to encapsulate the internal details of an object to limit direct access to the data of an object, and we'll see precisely how to achieve this shortly. Until then, let's take a closer look at setters. And again, we use an example as our starting point. I created a simplified version of the Passenger class with just one field, internalName. I want a way to set a valid value for this field. And again, we can use methods, but I want to avoid the same boilerplate code, so let's create a setter instead. A setter is also a plain‑old JavaScript method. To create a setter, you first need to use the set keyword. A setter has an identifier and precisely one argument. I want to use this setter to validate the input. If the input is not valid, we can throw an error. And if the input is valid, I want to modify the field called internalName with the value provided as an argument to the setter. With this in place, I want to use the setter, so I'll go ahead and create a constructor. And inside the constructor, I'm going to change the value of the internalName field by using the setter. And again, notice that a setter is a syntactic sugar. I'm using the setter as if it were a property, and I'm not using it like a method. But behind the scenes, this method is invoked, the validation is performed. And if the validation passes, then our internal field gets populated with the new value. Awesome. Now, let's go ahead and summarize what we know about setters so far. First of all, they're methods that must be prefixed with the set keyword. You need to add the set keyword before the name of the setter. A setter can have exactly one parameter, and when we invoke them, we use the identifier as a sort of variable and assign a value to it. Again, we are using it as a field and not invoking it as a method. Setters are great to validate data to ensure that we always leave objects in a correct state. After all, you don't want people to change the data of an object improperly because then they can misuse your objects and leave your program in an error state. But setters also encourage encapsulation because you can heighten objects data and only change it or modify it through setters. Now, before we conclude this chapter, I want to mention that you can pair up a getter and a setter using the same name. In our example, the Passenger class has a getter called name and a setter also called name. And while this is great, this code is not encapsulated, nothing is preventing me from bypassing our getters and setters and just modify or access the value of the internalName field. So we need a way to hide this field from external use, and this is where the private accessor comes into play.

Encapsulation
If you're somewhat familiar with object‑oriented programming, you realize just how vital encapsulation is. We can spend hours discussing encapsulation in detail, but I want to capture its essence and benefits to JavaScript applications. I believe the best way to look at encapsulation is from a safety perspective. Encapsulation allows us to restrict access to the internal state of an object. Cool, but why is this so important? To explain this better, let's take a look at an example. I created an Aircraft class, which has two fields, speed and attitude. By default, members are public in JavaScript, so nothing is preventing us from changing these values any way we see fit. If you want to gracefully and safely land an aircraft, I think we both agree that this line of code is probably not the best way to do it. As JavaScript applications grow in complexity and size, it is essential to design classes in a way that empowers others to use them safely and correctly. We must design classes with encapsulation in mind. But how can we do that in JavaScript? The first step is to hide the internal workings of a class. We can hide fields and methods that are not designed to be accessed from the outside. And at this point, you're probably surprised, you might even raise and eyebrow and ask yourself, well, that's great if we were writing code in Java or C#, but this is JavaScript, a language that was not designed to handle such use cases easily. And you would be correct if you made this statement before 2020. Because starting with ECMAScript 2020, we can make fields and methods private by adding a # sign to their name. JavaScript will ensure those members cannot be accessed outside a class scope. So let's revisit our code and make the aircraft field private. To make a field private, simply start its name with a # sign. In this case, #speed and #altitude are now private. They are still accessible from within the class, and you can see we are initializing them from the constructor. But if you want to invoke them outside the class, then you will get an error, which is exactly what we wanted. All right, so how can we land an aircraft? And that's where step number two comes into play. We can hide internal details and expose only meaningful actions to the outside world using public methods, getters, and setters. For example, if you want to land an aircraft, we can create a special method that encapsulates the internal logic or maybe we need to read the altitude in another unit of measure. Well, in this case, we can create a getter and expose what is truly necessary outside while protecting the inner workings of our aircraft class. There is really no excuse for not considering encapsulation in modern JavaScript programs. I also want to mention that you can make methods private as well. There are lots of situations where logic does not have to be accessible from the outside. In our example, the public land method now uses a private method to determine the best landing speed. Users don't need to use the private method outside. They are just interested in landing the aircraft, so it makes perfect sense to hide that logic in our class and not expose it publicly.

Demo: Encapsulating JS Code Using Private Modifier
In this demo, I will show you how to encapsulate JavaScript code using private members, getters, and setters. We'll continue from where we left off in the previous demo. Some aspects of a flight plan, like the departure time, are not known in advance, since they're subject to change; therefore, in this demonstration, I want to be able to read and update this property in a way that takes encapsulation into consideration. So the first thing that I'll do is add a property, a field, to hold the departure time. This is public by default, so let's add a hash sign to its name and make it a private field. If we want to read the departure time, we probably need to do that in a local friendly manner, so let's go ahead and use a getter and expose this time in a way that makes sense for users. In the getter, we are reading the #internalDepartureTime and we are converting this to a local string. Notice that the getter declaration starts with the get keyword and that the departureTime function has no parameters. With this in place, let's also enable users to change the departure time. We need to validate the provided date and ensure it is not null, for example. I created the new setter using the set keyword followed by an identifier. In this case, we'll also name it departureTime for consistency. The setter has one parameter which represents the date that we're trying to update our object with. Inside the setter, I want to add some validation logic. I want to ensure that the date is not null. If it is, we can raise an error. Then, I also want to verify that the date is not in the past. If the data is in the past, we can throw another error. Otherwise, if it is valid, we can assign it to the internalDepartureDate field. With this behavior in place, let's go ahead and see how our code behaves. I'm updating the departureTime with a time that is in the future. And if you see my program, you can see that it works as expected. But what happens if I change the date and put it sometime in the past? For example, in 2022. Let me go ahead and modify this year. I'll hit save, and now we see a validation error. So our setter works as expected. I'm going to change back our code, and now, let me show you what happens if you try to modify the internal date directly. And we can see we get an error, Private field '#internalDateTime' must be declared in an enclosing class. Basically, we cannot access this field, #internalDateTime is a private field and cannot be accessed outside of its class. After this demonstration, I hope you see encapsulation's benefits, and I hope you'll take full advantage of JavaScript's features to enforce it in your applications.

Recap
In this module, we took a very brief look at JavaScript functions in the context of object‑oriented programming. Object‑oriented programming is not the focus of this course, but if you're working with _____ applications or modern JavaScript code, you will surely bump into methods, getters, and setters. A method is just a regular JavaScript function defined in a class or object. Getters are a special kind of method with no parameters which is used to access an object's data safely. Setters are another particular kind of method with a single parameter, which is used to mutate the state of objects safely. JavaScript has evolved and supports encapsulation using the dash modifier. This makes members private to the enclosing class. To make a member private, start its name with a # sign. You are now ready to take things to the next level. In the next module, we'll start discussing more subtle and sometimes misunderstood aspects of JavaScript functions, function scope and closure.

Understanding Function Scope and Closure
Function Scope
Scopes and closure are a topic that kind‑of scares developers off, but you'll see that they will make complete sense if you take things slow. Therefore, in this module, we'll start by defining what scope is. Then, we will walk through the various JavaScript scopes and how they are different from one another. And finally, we will demystify closures. Simply put, a scope is a place or execution context where variables and expressions are visible or, in other words, can be referenced. To put it in simpler terms, scope determines the accessibility of variables. In JavaScript, you will usually have to deal with three kinds of scopes. You have global scope, then there is function or local scope, and then there is block scope. Because this course is focused on functions, we'll look closely at function scope, but I want to mention the others to give you a clearer picture. When you define a variable outside a function or a block, that variable lives in the global scope. As its name suggests, such a variable can be accessed from everywhere inside your application, including from different JavaScript files that are loaded by your web page. Best practice and common sense dictate that you avoid adding too many variables in the scope. Block scope, on the other hand, is a relatively new addition to JavaScript introduced in ECMAScript 6. This scope only applies to variables declared using let or const inside the block, which is usually denoted with opening and closing braces. For example, aircraftModel has a block scope, and it is only accessible as a variable within this block. If you try to reference or access this variable from outside the block, you will get an error. AircraftModel is not defined. In the second example, the variable i is used to iterate from 0 to 10, and it also has a block scope, the scope of the for statement. You can use it inside the statement. But again, if you try to access the variable outside its block, you will again get an error that i is not defined. Notice that both variables are declared using const or let. And now, let's explore function scope in more detail. In JavaScript, each new function creates its own isolated scope. Variables declared inside the function are not visible outside the function, they can only be accessed in the function in which they were declared. But a function can still access the variables defined in its outer scope. So in a function, you can safely use variables declared inside the same function, and all the other variables declared in the outer scope of that function. Now, let's take a look at this from a more graphical perspective. You can imagine scopes as layers. You have global scope, which is shared across your entire program. Variables declared here can be accessed from everywhere. Then, each function has its own isolated scope. And if you create functions inside those functions, they will also get their scope. As for variable accessibility, it usually goes from bottom to top, but not from top to bottom. For example, inside the blue Child function, you can access variables defined within it, plus the variables defined in function 1, plus the variables defined in the global scope. Let's take an example. I declared a constant called airportAltitude, which has global scope because it is declared outside any function. Then, I defined the land function. Inside this function, I defined a new variable named currentAltitude. This valuable has local scope, so it is only accessible within the boundaries of the land function. We can see if we compute the difference between the currentAltitude and the airportAltitude because global variables can be referenced everywhere. However, we cannot access currentAltitude outside its defining function, we'll get an error specifying that currentAltitude is not defined. Before we jump to the demo, it's worth pointing out that it does not matter how you declare variables in a function. In this example, all the variables have function scope and our local to the land function, even though one is declared using var, the other using let, and the third one using const.

Demo: Understanding Function Scope
In this demo, I want us to understand how function scope works. I created a global variable to hold the maximum altitude that an aircraft can have. Now, I want to create a function that will change the altitude of an aircraft and make sure it does not exceed safety boundaries. Let me go ahead and paste in the code. This function has a parameter that holds the desired altitude. Before we use the provided altitude, we need to check that it is within reasonable bounds. It must be greater than the minAltitudeMeters variable and less than the max altitude in meters variable. If you look at the two variables I just mentioned, you will see that they have different scopes. So, is this function correct, will this function work? Min altitude in meters is defined inside the function, so it has function scope. That means we can use it in our if statement. Max altitude in meters, on the other hand, is a global variable. Because it's global, it's shared by every other part of this program. So, it is also accessible in our changeAltitude function, and I can prove that by invoking our function. Now I'll hit save. The function works perfectly, but what if I try to access the variable called minAltitudeMeters? Now, we get an error. The variable is only accessible within the scope of its enclosing function and hidden outside that context. The idea that I want you to take with you after this demo is that variables declared inside a function can only be accessed within that function, but a function can also use variables defined in its outer scope. That's the essence of scope.

Closure
In my experience, closures are the most misunderstood topic in JavaScript programming. They seem very abstract and are usually confused with scope. So in this module, I will try to demystify this topic. If you look at the formal definition, you'll find out that a closure is the combination of a function and the lexical environment where it was declared. For somebody new to this concept, I don't feel that this definition makes it easy to understand what a closure really is, so let me try and rephrase it. When we talk about closure, you should always imagine you have an inner function defined inside an outer function. That's the premise. Now, two things need to happen to identify a closure. First, a closure is a JavaScript feature in which the inner function has access to the outer function's variables. Now, as you probably noticed, this is scope. This is what we discussed about in one of the previous chapters. A function can access variables defined within its own boundaries and variables defined in the function that encloses it. So, nothing special here, but there is one more essential aspect to closure, and that is the fact that the inner function can access variables defined in the outer function even when the outer function has returned or has exited, so even when the outer function is no longer alive or active. Let's keep this definition in mind and look at an example. I created a function called parent. Inside this function, I defined a variable called name. Inside the same function, I also defined a new function and I called it child, which logs the variable defined in its outer function, so it logs name. If you recall how scoping works, this is perfectly fine. The child function can access variables defined in its outer scope and that outer scope, in this case, is the parent function. Now, let's make the parent function return a reference to the child function. So, at this point, if we invoke the parent function, what we get is a reference to the child function, and we can store that reference in a variable. The child function was not executed up until this point, we only have a reference to it. At this point, the parent function is finished, it has exited, it is no longer alive. What do you think will happen if we invoke the child function, the other variable that we created earlier? Now, intuitively, you might say that the child function will print undefined, but that's not the case. The outcome is actually John Doe. And this is the beauty of closures. When you declare the child function, a closure was created for it, and that execution context captures all the variables that the child function can access, all the variables that are in scope for the child function, and that includes the variable called name. So let's take a look at the original definition of a closure with this new understanding in mind. Now a closure is the combination of a function, in this case the child function, and the lexical environment in which it was declared. That environment consists of any local variables that were in scope at the time the closure was created. So, not at run time, not when we invoke the function, but when we declare the function in our code.

Demo: Implementing Function Closure
I hope closures make more sense after the previous chapter, so I guess you're ready to get your hands dirty and write some code. As you found out, to capture the essence of a closure, you need an inner function and an outer function. In this demo, I want to use a slightly different approach to the one that I used in the slides, so I'll declare a variable that will eventually hold the reference to a function. Now, I will create an empty, immediately invoked function expression. Within this function, I create a new variable called nbPassengers. I also want to create an inner function that will increment the number of passengers and write them to the console. The inner function is called addPassenger and can access and then increment the nbPassengers variable. And now, I will assign this function to the child variable. Because I created an immediately invoked function expression, this will execute immediately and return, so the outer function will immediately go out of scope, leaving our child variable to hold a reference to the addPassenger function. Let's go ahead and invoke it and let us see the outcome, and the result is 101. Now at this point, I don't feel that the result will surprise you anymore. The addPassenger function captured the lexical environment where it was declared, including the nbPassengers variable, even when the outer function, so even when the function that declared the nbPassengers variable has exited. As you probably see from the slides and from the demo, closures have nothing to do with how, when, or where you invoke your function, but more with where you declare your function because closure is created for every function, and that closure captures the lexical environment surrounding that particular function.

Recap
I hope this module helped you gain a solid understanding of function, scope, and closure. You learned that scope represents the execution context, where variables and expressions are visible or accessible. In JavaScript, we can declare variables in the global scope, which are shared across the entire application. We can declare variables in a function, and they can be accessed inside that function or in a child function. We can also declare variables in a block using the let and const keywords. Closure is not the same as scope. Scope is essential to closure, but don't confuse these concepts. Closure is the combination of a function bundled together with references to its surrounding variables and statements. In the next module, we'll take a look at another somewhat confusing part of functions in JavaScript and that is how to use the infamous, this, keyword.

Understanding “this”
Using “this” in Global Context / Top Level Functions
In this module, we'll discuss another confusing feature of JavaScript. In most programming languages, this, has an obvious meaning, that's not the case in JavaScript, where the this keyword takes many shapes based on how and where you use it. That's the key reason why so many developers, myself included, struggle with it from time to time. So in this module, I want you to think about this based on scenarios or use cases. You'll understand what this means in a global context in top‑level functions, in constructor functions, inside methods, and inside arrow functions. You'll also see how to change the value of the this binding using special methods, such as bind, call, and apply. Before we start, I want to briefly mention some of the definitions you'll likely encounter for this concept. You'll hear some people say that this refers to the current execution context of a function. Others say that this represents the object which owns the function or the object that's executing the current function. These definitions are not necessarily wrong, but I feel they are not very intuitive. In my experience, capturing the essence of this in such a short definition may be a little bit complicated. Therefore, I will not stick to a single definition. I will instead use a scenario‑based approach and explain how this functions in most use cases. Still, even with this scenario‑based approach, I still believe that having a complete picture in mind can be helpful in better understanding the real value of the this binding, so I will share a pragmatic and maybe oversimplified definition of this, which has helped me a lot in the past. In non‑arrow functions, this, usually represents the object that is invoking a function. In arrow functions, this, refers to the parent function's scope. It's not 100% accurate, but I found this to be very helpful when looking at various pieces of code and figuring out why this behaves in a particular way. So I want you to keep this definition in mind, and now we are free to look at some concrete examples. There are plenty of scenarios in which we write global or top‑level functions, and in that case, this usually represents the object calling the function, so it is no surprise that when using this in a top‑level function, it usually represents a global context. If you're running your script on an HTML page, the global object is window. And if you're executing your code in Node, then it is the global object. Let's take a look at the simple function. Now when I say top‑level function, I mean a function you find outside other functions, outside the class, outside an object, just a function in a raw JavaScript file. Inside this function, there is a single nf code. I'm using this to access the navigator object and then print its userAgent property. Now, if you run the script in an HTML page, you'll get the browser's name as output. But why is that? Well, that's because, this, in a top‑level function executed in an HTML page, refers to the window object. That object does contain a navigator object, which, in turn, has a userAgent property. But what if we turn strict mode on? Well, this completely changes the situation because strict mode discourages the creation of global state. So if you look at the same example again, but add use strict to the function of the JavaScript file, you'll get an error. Now the value of this is no longer the window object, but undefined. Let's take a look at constructor function. Now I'm mentioning them here because these are usually also top‑level functions. But when you use them to instantiate a new object, the meaning of this changes. In this example, I created a function called Helicopter, which takes the current speed as a parameter. Inside the function, I'm initializing the speed property with the provided parameter, and I'm assigning that property to the this keyword. You might be tempted to say that a new global variable will be created on a global object in this scenario. And that is true, unless you use the new keyword to create a new object using the function as a constructor. Using, new, essentially binds this to the new object that is being created. In our example, when you print h.speed, speed is a variable on the Helicopter object, and it was initialized using the constructor function.

Demo: Using “this” in Top-Level Functions
In this demonstration, we'll look closely at how this behaves in top‑level functions. Let's go ahead and create a very simple function that prints the value of this. This is obviously a top‑level function, so this should point to a global object. If you run this script in an HTML page, you'll notice that we get the Window object, so this is the Window object. Let's see what happens if I run the application in Node. I'll hit Run, and now we get the global object, which is exactly what we expected. So in top‑level functions, this refers to the global scope. Let's see what happens if we introduce strict mode into the equation. I'll refresh the page, and you can see undefined printed out, and that's because strict mode limits how we can use the global scope. Thus, if you ever find yourself in a situation where you expect some piece of code to work, but you run into an error like this, do check out that strict mode is disabled. That could be an issue. Cool. Let me delete this and create a new top‑level function. You might guess by looking at the first capital letter that this is a constructor function, but let's assume it's not. So inside the function, I'm using this to initialize the speed variable. The value of this is mainly determined by how we invoke functions, so let me go ahead and call the Helicopter function just like a regular function and let's also print the value of this. Now, what do you think will happen? Well, because it's a top‑level function, this refers to the Window object. Thus, a new variable should be created on the Window object. And if you go to the right and expand the Window object, you see we have a new variable speed with a value 100. So in this scenario, we get the expected behavior. But now, let's use Helicopter like a constructor function and instantiate a new object out of it. Because we're using the new keyword, we completely change the value of this. In this case, this is bound to the new object that we created and we stored in a variable called h. Speed will end up as a property on our new object and not on the global scope.

Using “this” in Methods
If you're writing modern JavaScript, chances are you'll often use objects and classes. Therefore, it's essential to understand how this behaves in these scenarios. In this case, this represents the object, which is invoking the method. Thus, the value of this is determined at runtime when you invoke your method. Let's take a look at a short example. I created an object called airport, which has two fields, name and nbDeparturesToday. And I also created a method that allows us to add a new departure. Inside the method, I'm accessing and incrementing the number of departures using this.nbDeparturesToday. We can invoke this method on an object, in this case, the object called airport. Thus, according to the definition, inside the addDeparture method, this will have the value of the airport object, so our code will behave as expected. We have the same situation when dealing with classes. Inside the Airport class, we have the addDeparture method, and it's also using this to increment the nbDepartures field. In order to use this method, we must first instantiate a new object instance from the class, I called it Heathrow. Using this object, we can call addDeparture. And inside this method, this will have the value of an object called heathrow because that's the instance we're using to invoke the function, so this code also behaves as expected.

Demo: Using “this” in Methods
All right, let's check some code out and see how this behaves in methods. We'll start with an empty file. Let me go ahead and paste in an object that represents an aircraft. This object has a method called print, which displays the value of this to the console. Let's go ahead and invoke the print method. What do you think the result will be? If you recall the definition, in this case, this refers to the object which invokes the function. And if I hit save, you will see the result on the console. It's exactly what we expected. Now, let me go ahead and make this harder. I will declare a new variable and make it store a reference to the print method of the boeing747 object. What do you think will happen now? Let me hit save, and you'll see that this is now the Window object. Why? Because you are invoking anotherPrint method as a top‑level function. It's the global object that is now the owner of this function. All right, let's see how this behaves with classes. I'm going to delete all this code and paste in a new class that represents an aircraft. I defined a method called print in this class, which does the exact same thing as before, displays the value of this to the console. To invoke this method, we need to instantiate a new object, and the value of this will be the object that we use to invoke the function. Each object that you create from the Aircraft class will have its own this, and the methods will take the value from the instance that is calling them.

Using “this” in Arrow Functions
As you see in this module, arrow functions behave differently concerning the "this" keyword, and that's because arrow functions do not have their own binding to "this". They inherit the value of "this" from their parent scope, so from the outer function in which the arrow function is defined. Therefore, it's not the object invoking the arrow function that is used to assign a value for "this". The value is not decided at runtime anymore. With that said, you probably realize that arrow functions are unsuitable for every scenario because of this different behavior, especially not as methods. Confused? Don't sweat it. I'll show you some examples, and things will click. I defined an arrow function as a method of the object called aircraft. Then I use the aircraft object to invoke the printModel function. How do you think this will work? Well, if printModel was not an arrow function, then yes, because the method would have used the value of the invoking object, which is aircraft in this case. However, that's not the case with arrow functions. Our arrow function does not bind to this at runtime, but when we declare the function, it will use the parent scope as this, so in our example that is still a global object. Now why is that? Well, that's because the outer function in which our method is defined is now the global scope, and that may be confusing because you might look at this code and say, well, this method seems to be defined in an object literal in the object stored in the aircraft variable, and that's correct, but an object literal is not a function. Therefore, the outer function still remains now the global scope. So this will point to the global object, and therefore, our code will return undefined. What about classes? I defined a class called Aircraft, and again, I'm using the same printModel method defined as an arrow function, which prints the model using the "this" binding. Then I instantiate a new object from the class and I use this object to call the method. Well, it turns out that in this case the code will print the model of the aircraft, so the code works as we expected, even though we define the method as an arrow function. And now, the million dollar question is, can you guess why this happened? Well, that's because classes are just syntactic sugar in JavaScript. Behind the scenes, a class is transformed into a constructor function, so the code I wrote previously is equivalent to this. Aircraft is a constructor function, and printModel is a method defined inside this function. So we can look at things like this, what is the function definition in which our arrow function is defined, and the answer is the Aircraft function. So when we instantiate a new object using the constructor function, our method will behave as expected because a new "this" binding is created for each new object and our arrow function can access it, so different behavior when using methods based on whether you invoke them on an object literal or you invoke them on an object that was newed up.

Demo: Using "this" in Arrow Functions
After watching the previous chapter, you know that arrow functions are like the black sheep when it comes to handling the "this" keyword, so let's write some code to better understand how they capture the value of "this". Let's start by looking at this familiar code. Because the print method is not defined as an arrow function, when calling this method on the Boeing 747 object will work as expected. Let's go ahead and change the method to an arrow function and see the different outcome. I'll hit Save, and now the output is the Window object, but this time I'm sure you know why this happened. Inside our arrow function, this was assigned with the scope of its parent, and that is the global scope in this case. This example demonstrates why you should not use arrow functions as methods. My advice is to define methods using non‑arrow alternatives every time. Trust me that this will save you a lot, a lot of debugging time.

Controlling the Value of “this” Using bind(), call(), and apply()
Up until this point, you saw how "this" behaves in various situations, but wouldn't it be nice if we could control this behavior ourselves? It turns out we can if we use bind(), call(), and apply(). These three methods are defined on the Function prototype and are used to invoke functions. They provide a different way to call a function. But the cool thing is that we can also specify the value that "this" will take inside the function to control precisely what this will be. With this revelation in our minds, let's take a look at some examples. Bind() allows us to create a new function based on an existing function and provide a value for this. The first argument we provide to bind is the value of "this" followed by an optional list of arguments we wish to pass to our newly created function. In our example, I created a function called printModel, which looks at the "this" object and console.logs, the model property on that object. If you call the function, we'll get an error, and that's because in our example this refers to the global object. However, we can call bind on the printModel function and pass it a new value for this, in this case, an anonymous object which contains a model property. Bind creates a new function and we store that function in a constant called workingPrintModel. And then when we invoke workingPrintModel, we'll get the correct behavior. Awesome, but it seems a little cumbersome to create a new function and then invoke it. Are there any easier alternatives? It turns out you can use call and apply to accomplish the same thing without generating new functions in the process. We can use the call function to change the value of "this" on the invoking function. Here, I created the new aircraft object, and a separate function that adds passengers to an aircraft. It uses "this" to access the fields of the aircraft object, so if you call it directly, obviously it will not work because this will not be what we expect. This will be, again, the global object. So to fix it, we can go ahead and invoke the call method on the addPassengers function, and the first argument we provide is the value of "this", in our case the aircraft object, and then we also need to provide an argument for the addPassengers function. So again we provide 3, we want to add 3 more passengers. And this time the function works correctly, because "this" will point to the aircraft object. Apply is very similar to call. The only difference is that if you want to provide additional arguments to your invoking function, you must wrap them inside an array. But that's it, they accomplish the same thing. I can use apply instead of call. I'm still providing aircraft as the value for "this", and then I provide a value for the addPassengers function. I'll use 3 to populate the number of passengers parameter, but notice that I wrapped it inside an array.

Demo: Using bind(), call(), and apply()
Enough with the slides, let's see these amazing functions in action. I created a function that alerts passengers in airports. We can pass the name of the passenger to the function. However, the function reads the message from its execution context from a property called message that is stored on this. If we call the function normally, we will get a message like 'John Doe' undefined. And, again, this should make perfect sense by now. This is a top‑level function, and in this context "this" will refer to the global scope. But let's go ahead and fix this using call. The first thing I'll do is I'll create an object to hold the warning message. I stored it in a variable called presentToGateWarning, and now let's see how we can provide this object to replace this in our alertPassenger function. We'll start by writing the function name. Then we'll invoke call. And now we need to provide a value for the "this" argument. In our case, we'll link it to our warning object. And we also need to provide arguments for the alertPassenger function, in this case, the name of the passenger, which is John Doe. I'll hit Save, and now the warning message works as expected because we replaced the value of the "this" argument when we invoked the call function, and that's the power of these functions. But what if we use bind instead of call? I'll hit Save, and now nothing happens, and that's because bind does not directly invoke our function like call and apply do. Instead, bind will create a new function. In order to use bind, we need to create a new variable to hold the function returned by the bind method. I will store the newly created function in the variable called alertJohnDoe. And now we can go ahead and invoke this new function, and the code behaves like before. Now, obviously there's a subtle difference between bind, call, and apply. Normally, I would suggest that you stick with call or apply. You can also use bind, but I think it kind of leads to more boilerplate code.

Recap
We have reached the end of this chapter, and I really hope that the "this" keyword makes more sense to you now. You learned that the "this" object can take many shapes in JavaScript. In a simplified way, it usually refers to the object who is invoking or owning that function. Arrow functions, however, do not have their own "this" binding and inherit it from their parent scope. You can also control the value of "this" by using the bind(), call(), and apply() methods. They allow you to provide a value for "this" that you may choose freely. You can do the following exercise to master this concept. Each time you see the "this" keyword in code, stop and try to mentally assess its value by using all the knowledge that you have. You won't be 100% correct, but in time you will develop a very good intuition and the "this" keyword will become less and less confusing. In the last module of this course, we'll take a brief look at async functions in JavaScript, and you will learn how to implement the async/await pattern to write cleaner asynchronous code.

Working with Asynchronous Functions
Introduction to Asynchronous Programming and Promises
Welcome to the final module of this course. We can't conclude the discussion on JavaScript functions without looking at how they behave in an asynchronous context. So we'll take a brief look at promises and how they help us handle asynchronous operations. After that, I will teach you how to use the async/await pattern to write more concise asynchronous functions. And finally, we'll wrap things up and go through a short course recap. Before starting this module, I want to clear the air a little. This course is not focused on asynchronous programming in JavaScript, so I expect that you already have a basic understanding of asynchronous programming and promises. If you have worked on JavaScript projects before, you probably know the foundations of asynchronous programming. However, if you're brand new to the subject or want to take an in‑depth look at this topic, feel free to check out the JavaScript Promises and Async Programming course by Nate Taylor. With that out of the picture, let's explore asynchronous programming in close relationship with functions. Simply put, asynchronous programming is your application's ability to start a potentially long‑running task or function and still be responsive to other user events while waiting for the initial task to complete, or in other words, you don't want to block an entire application while waiting for a long operation to finish. Let's take a look at this concept from a graphical and functional perspective. Let's assume that at the beginning your program starts executing Function 1. After it finishes the short operation, it moves on to execute Function 2. A long‑running operation is to occur at this stage. I called it Function 3. If your functions work asynchronously, this should not impact the rest of the program. So Functions 4 and 5 can execute until the long‑running function finishes, which it will at some point in the future. And now our application gets notified and can process the results of the function using a callback. As I said earlier, this pattern should feel very familiar if you have some experience writing JavaScript applications. I talked a lot about long‑running tasks in the previous slides, and I want to elaborate on this using concrete examples. The following operations take longer to complete and we handle them in an asynchronous manner, HTTP calls, time delays like the ones created using the setTimeout and setInterval functions, accessing a computer's camera or microphone, or selecting files from a machine. Now that we took a quick recap of asynchronous programming, let's see how we deal with such scenarios in code, and that's where promises come into play. A promise is a JavaScript object returned by an asynchronous function that represents the current state of execution. So if you execute an asynchronous function and use vanilla JavaScript, then the result of that function is wrapped in a promise. By exploring the promise object, you can see if the action was completed successfully or if any errors occurred, and you can also provide callbacks that will be invoked when the promise is fulfilled or rejected. Let's take a look at an example. I created an asynchronous function called printMediaDevices. Its purpose is to list all the internal or external cameras, microphones or headphones connected to a computer. To achieve this, we can start at the navigator object, access the mediaDevices property, and call enumerateDevices. This function is an asynchronous function, and as such, it will return a promise as a result, not a list of devices, a promise that will be fulfilled at some time in the future. Now, to do something with the result, we can use the then function and pass a callback that will be triggered when the function finishes execution. We can also invoke the catch function and provide another callback to handle scenarios where something went wrong. As you can see from this piece of code, we have a long running task and two callbacks that can get invoked when the long‑running operation finishes, but until that happens, until the function called enumerateDevices actually returns something, our program is still responsive and available to execute additional functions, and that's the beauty of promises and asynchronous programming in JavaScript.

Demo: Fetching Data Using Promises
Let's leave the slides for now and work on a real example. I want to show you how to use promises to fetch data from external HTTP endpoints. In this demonstration, I want to come back to our flight billboard. In the second module, we loaded flights manually by invoking the createFlightPlanEntry function for each flight. I want to take things further and load them from a JSON file. I'm using JSON files to mimic remote HTTP calls, but the code will work in both scenarios. I created two files. The first one is called flight‑summary.json. This file contains the ID and departure for all the flights I want to load over HTTP. I also created a second JSON file called flight‑details.json. This file contains additional information such as flight status, number of passengers, and aircraft type. Awesome! Let's go back to our main.js file, and we'll start by deleting this piece of code, since we will read data asynchronously from the JSON files I mentioned earlier. Now, I will create an asynchronous function that reads data from the flight‑summary.json file. I'm using the fetch method to load data from the JSON file, and if you take a closer look at the fetch method, you will notice that it returns a promise. Let's go ahead and invoke this method. Remember, the output of this method is a promise, so we need to add our callbacks for success and failure if we want to do something with the actual response. So I will chain the getFlights method using then to extract the result as JSON. The JSON function is also asynchronous, so we need to use then again and pass another callback to grab the actual flights and display them on screen. I'll hit Save, and you can see that the billboard is updated successfully, but the status is not shown and the coloring has gone, because that information is stored in a second JSON file, the flight‑details file, so let's go ahead and load that as well. I created a new async function that loads data from the flight‑details.json file and then searches for the flight ID you provide as an argument. So for every flight loaded from the initial JSON file we need to make an additional HTTP call and load its flight details where the status property resides. Okay, now you must modify how we handle responses and integrate flight details into the equation. I'm going to delete this piece of code, and now I want to iterate over each flight summary, and I want to fetch the details. The getFlightDetails function is asynchronous and returns a promise, so we need to provide a callback to access the results, if any. I'll hit Save, and now the billboard is functioning correctly. We can see the status property is now displayed. However, looking at this code, you will notice that it is very hard to read. There is a lot of indentation and a lot of callbacks to follow. Wouldn't it be nice to have a better way to write code like this, and it turns out we do.

Async / Await Pattern
Starting with ECMAScript 2017, we can use the async/await pattern when dealing with promises. At its core, the async/await pattern is an easier way to work with asynchronous promise‑based functions. To implement this pattern in your functions, you need to follow two steps. First, you need to add the async keyword word at the start of a function that will execute asynchronous code. This will mark the function as an asynchronous function. Then, inside the asynchronous function, you can use the await keyword before calling any functions that return a promise. So, as you can see, await can only be used in conjunction with async. I'm pretty sure an example will help, so let's see some code. Functions that are marked with the async keyword always return a promise. Looking at this function, you might say that it returns a string, but this string is actually wrapped in a promise that resolves immediately. The function above can actually be rewritten like this. They are one and the same. The first one is just syntactic sugar to eliminate some boilerplate code. Now that you know what async functions return, let's see how we can consume the result of an async function. Because an async function returns a promise, you can use the promise API and pass callbacks when the promise is fulfilled or rejected. This is classic or legacy code that deals with promises. Or you can use await. Adding await before invoking an async function makes JavaScript wait until the promise settles, and there returns the result of the async operation, another promise object. So, in our example, value is actually a string and not a promise. I think we can all agree that this line of code is easier to understand than the line above it. Behind the scenes, await suspends the function execution until the promise settles, so JavaScript is free to run additional operations, so in terms of asynchronous programming, you lose nothing from a performance point of view. You gain the same benefits, but with cleaner, more elegant code.

Demo: Refactoring to async/await
In this demo, we will start where we left off and refactor our code to use the async/await pattern. I will start by modifying the getFlightDetails function. I will add async at the start of the function so I can use await inside it. I'm using await on the first line because fetch returns a promise. Then I store the HTTP response in a variable called res. If I hover over the variable, you'll see that its type is Response and not Promise, and that's the consequence of using await before an asynchronous function. Then we need to call the JSON function to parse the response body to JavaScript objects. Again, we can use await and store all the flight details in a variable called detailedFlights. Finally, we can filter those objects and return the flight that we're interested in. This function still has three lines of code, but I think it's easier to read. It reads nicely from top to bottom without worrying about any callbacks. But the real magic will happen after we modify the getFlights function and the way we use it, so let me go ahead and delete its contents. Now I can mark it as an async function, and let's go ahead and use await to load all the flight summaries. Awesome! I'm using await before the fetch function to get the HTTP response, and then we can get the actual flights by calling the JSON method on that response variable. And again, we're using await on the second line as well. We can now iterate over each flight and grab the details using await. We can now invoke the createFlightEntry function to create the flights and display them on screen, and now all we have to do is invoke getFlights. I'll hit Save, and we can see that our page still behaves as expected. We accomplish the same result, but the code is more readable. Therefore, when you deal with promises or functions that return a promise, please consider using the async/await pattern. If this code does not make perfect sense because you are new to this concept, don't forget to check out the JavaScript Promises and Async Programming course I mentioned earlier.

Recap
In this final module, we took a very brief look at creating and using asynchronous functions. With asynchronous programming, JavaScript can execute a long‑running task and continue to run additional operations in parallel. In JavaScript, asynchronous operations are implemented natively using promises. To simplify code and eliminate callbacks, we can replace traditional promise handling with the async/await pattern which was introduced in ECMAScript 2017. An async function is a function that will always return a promise. To create an asynchronous function, simply add the async keyword before the function declaration. Inside an async function, we can use await to capture the result of promise operations. You get the same result from a performance point of view, but with much more elegant code.

Course Summary
Hurray! We reached the end of this course. I sincerely congratulate you for taking the time to polish your JavaScript skills and for finishing this course. Throughout this journey, we explored how to define and invoke functions in JavaScript, how to pass data to functions via function parameters. You learned how to encapsulate classes by using a private modifier, getters and setters. Then you dived into more complex topics that scare off most JavaScript developers. You discovered what function scope is and how it relates to closure. You found out what the "this" keyword means in a variety of contexts, and you briefly look at how the async/await pattern introduced in ECMAScript 2017 can make your asynchronous functions more readable. Having settled that, I'm confident you are now ready to leverage the full power of JavaScript functions in your own projects. Functions are a fundamental pillar in developing web applications, but at the end of the day, functions are just a piece of the vast puzzle of JavaScript, so I highly recommend that you follow the rest of the courses on this path and pave the way for JavaScript mastery. I hope you enjoyed watching this course as much as I enjoyed creating it. I would love to hear your thoughts and feedback, as they are very valuable to me. We can get in touch on Twitter @romaniancoder or you can find me on www.dangeabunea.com. Until next time, have a great day and write amazing JavaScript code.