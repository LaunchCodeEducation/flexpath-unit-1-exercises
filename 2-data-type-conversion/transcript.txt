So we just spent a whole module talking about some of the different data types that exist in JavaScript. And here, within this module, we're going to be covering about data type conversion. So even though JavaScript does leverage dynamic typing, we still need to understand how types work in the language. So anyone that tells you you don't need to worry about types because JavaScript handles it for you, that's not entirely true. You need to know here how to convert from one type to another type, and we would call this process of changing conversion. Now there are several different use cases that you may run into when you want to convert from one JavaScript type to another, and I'm going to give you some examples here, and these are all examples that we will be covering here within this course. So first, you might want to join a non‑string value in with a string. Now we actually have already done this, I just didn't tell you that's what we were doing, and I will actually cover this one here within this clip, or maybe you want to format a number into a string so that it can be displayed as something like currency, or maybe you want to format an object into a string, and maybe this is a Date object, maybe you just want to show the calendar date and not the time zone, and everything else that comes with a date, or maybe you want to export an object to some sort of a portable format that you can then load back in later, and we will do that here within this module, or maybe you just want to evaluate an expression to a Boolean value, which is so important, especially once we get to conditional, which will be covered in a later module. So now that we've covered those concepts, we've covered some of these use cases, let's take a look at some of this in action. So I'm going to jump over to VS Code. So here within VS Code, the first thing I'm going to do is to create a new file. Now here within this file, I want to remind you that we do have access to a function in JavaScript called typeof, and this will return the type of any variable that we have created. So in this case, I'm going to create three variables, a string, a number, and a Boolean. And then, for each of these, we will log out the type that gets returned by typeof. So now if I were to hit F5, you can see that it returns a string, number, and boolean, exactly what we wanted it to do. Now let's go ahead and talk about one of the use cases, the one that I mentioned at the very beginning, which is maybe we want to join in a non‑string value with a string. So the first thing we're going to do here is create a couple of different variables. Here we have an age, which is a number, and firstName, which is a string. Now one of the ways we can join this together is to use back ticks and that template literal syntax. So here, if I was to create a new variable called description, utilize backticks, and bring in both the firstName and age, description will be a string, and it will include both the firstName and the age. And so it will have converted the age from a number value into a string that's included as a part of this overall string. So here, if I run F5, you can see just that. We now have a string that says David is 41 years old. Okay, perfect. Let's talk about another use case, and that is the use case where maybe we want to convert a string into a number. Now this one is a little bit less straightforward. Let's say we do create a string here, and it has the numbers four and one in it. Well, to create a number, we can utilize the Number function. Now notice this is not a constructor call here. We're not saying new number. As matter of fact, you want to avoid utilizing the new keyword when you are converting data from one type to another. So here we're going to say that we want to create a number from this string. So now, once we've done that, if we were to log this out, what do you think it would say for typeof? Well, let's run it and see. And indeed, in this case, it comes back that it is a number. So we have successfully been able to convert these two characters, 4 and 1, into the number 41. Now this also brings up another interesting case, and that is this, what if we do go in and use the new keyword? So I'm going to show you why you generally don't want to do that. So here we'll create a new Number, we're going to say new and use the new keyword, but then what we're going to do is I'm going to run typeof on the returned value. Now if we run this, if I hit F5, we actually don't get back a number, we get back an object. And in most cases, that's not what you're going to want to do. As matter of fact, I'll just say, unless you fully understand the ins and outs of the differences, you probably just want to stick with number and not worry about the new keyword. We also have another scenario we have to cover here in this use case, and that is what if we pass it a string that it just can't convert into a number? I'm going to pass in the string here the words forty‑one, and then we're going to try to create a number from that. And I'll go ahead and tell you that it can't handle that and so, what does it return? Well, let's go ahead and run it and see. So here we get a value back. It says NaN, that stands for Not a Number. This is what gets returned if we try to convert something into a number type, but it can't actually be parsed into a number. We also have some other cool capabilities that are included at the language level that let us check to see if a value is NaN, or Not a Number. And here I'm going to use the isNaN function to go in and check for that. And so if I run this now, we can indeed see that it Is Invalid. It did return true for that value. But let's talk about another one. Let's talk about how we convert a value into a Boolean. And in this case, we're going to say a number. So here I'll create two numbers, 1 and 0, and then I'll create two Booleans from those two numbers. So here we'll say that we have a Boolean based on num1 and a Boolean based on num2, and then we'll log out these two values. So what do you think these values are going to be? Well, let's run it and see. So it returns that Num1, which is the Number 1, would evaluate to true, and Num2, which is 0, would evaluate to false. Now this will become very important once we get to conditionals, but we see things like 0 and null and undefined evaluating to be false, and then anything that isn't a 0 value, evaluating to true. And we can see that that is playing out here when we convert these numbers over. Let's look at another example. What about converting a string into a Boolean? So here, we'll create a new string called Hello, and then we'll actually convert that to a Boolean. But then, I'm going to take another value, and I'm not going to assign anything to this variable yet. And if you remember, in the previous module, we said that the value of this variable, which in this case is val1, is going to be undefined. So what do you think that's going to turn into when we convert it to a Boolean? And we can see here that Bool 3 does evaluate to be true because that is the string that actually has a value. And Bool 4 evaluates to false because again that one was undefined, so that's going to turn into false when we convert it into a Boolean. Okay, so now I have one thing left to show you, and this might be one of the easiest things we've covered so far in this clip. I'm going to show you how we convert a Boolean to a string, and this has actually been happening even throughout this clip, right? So in this case, we're going to create a new Boolean variable called Bool 5, and I'm just going to set it to be true, and then I'm going to log this out as a string. And in doing so, again, if I were to go in and actually run this with F5, we'll see that that one turns out to be true. So here we'll just see the words true and false if we convert a Boolean into a string. Now we don't have to do that here with template literal syntax. We could also do that utilizing the string function, just like we've done with the Number function and the Boolean function. But now that we've covered that, we need to get into some other even more powerful use cases for converting between one JavaScript type to another.
So next we're going to cover a special case for conversion, and that is converting to JSON. So let me explain to you what JSON is and why it should matter to you. JSON stands for JavaScript Object Notation, and it enables developers to convert a JavaScript object into a string. Now, this string can be passed between applications, stored on the local file system, or loaded at runtime, and those are just a few of the different use cases that you can leverage when you're working with JSON. Now, let's just look at a quick example of this. So first of all, JSON is just a string. So everything you're looking at here is just going to be a string value. And you might notice that this looks in many ways very similar to our object literal syntax that we've used to create JavaScript objects, but there are some differences that we'll cover in a minute. But I could create an object and then convert it to JSON, and I could end up with a value like this. Let's go through and talk about some specifics about JSON. First of all, as I mentioned, it is similar to the object literal syntax. However, there are some differences, including that it requires double quotes for property names, which we don't have to have quotes at all on property names when we're using the object literal syntax. Also, it requires that any string values also be enclosed in double quotes. Also, when you create JSON from an object, it won't include undefined properties or functions. So there are some things that just can't be properly replicated in JSON from a valid JavaScript object. In addition, JavaScript has methods for converting to JSON, as well as converting from JSON to an object. However, as I'll go through here in just a minute, there are some limitations and some times you'll have to do some custom work to make it work the way that you would like. Now, as a reminder, we do have documentation. In this case, there's a whole page on JSON on the MDN Web Docs that you can review if you want to dive in and understand any of the rules at a deeper level. But let's actually work with JSON. So let's jump into VS Code. So I'm here within VS Code, and the first thing I'm going to do is to create a new file. Now here within this file, I first want to create a JavaScript object, and I'm going to do this just using the object literal syntax that we've used so far. And we'll give it some different values. We're going to have firstName and lastName, which would be strings, will have birthdate, which will be an actual date object, we'll have numYearsEmployment, which is going to be a number, specifically an integer, we'll have department and title, which will both be strings, isActive, which is a Boolean, and then salary, which will also be a number. So, this is just a basic JavaScript object. Hopefully all of this looks familiar to you. We have covered all of these different data types in the previous module. So, how do we actually convert this to JSON? Well, here we can utilize a method on the JSON global object called stringify, and this will take any object that you pass in and convert it into a JSON string. So, I'm not doing this here, but if I were to do type of jsonValue, it would return string. So let's go ahead and run this and let's see what we get. So I can see that I have a string output here that is JSON. Now, with this being said, there's a few bits here that are a little bit hard to read. So I'm actually going to show you a little trick here that we can do to make this a bit easier to read. So, I'm going to restringify this object, but I'm going to pass in null and then the number 2 as 2 additional arguments to that method. Now, this isn't going to change anything in terms of the JavaScript engine; it's just going to change the way that it actually creates this string by adding in, in this case, two spaces per indentation level. So, if I were to run this now, we can see that we get something out that's a little bit easier to read. Now, there's a few things I want to point out here. First of all, most things convert the way that we would think. Our strings remain strings, our Boolean remains a Boolean, and our numbers remain numbers. However, you'll notice here that our date was converted into a string, and in some ways that presents a bit of a problem for us when we go back and convert this into an object, but we'll talk about that here in just a minute. Okay, so now that we have that in place, let's keep moving forward. So let's talk about how you do the opposite. How do you take a JSON string and convert it back into an actual JavaScript object? Well, in this case, we can utilize the json.parse method, and this will take in your string and it will return an object that is created from that string. So now if I were to run this, we can see that it does indeed return an object. And so you'll notice here, though, that our birthdate is actually still a string because if you remember it converted it to a string. So later on, we'll learn how to convert this back into a date. We won't be covering that quite yet, but just know it's possible, but it will require a little bit of custom code to make that work as intended. Okay, so now that we've covered that, let's keep moving forward. Now, another thing we can do is we can actually write our own JSON. I just want to show you this because there are times you'll want to do this. Now, I'm just going to create a string. Now I'm using back ticks because I want this to be a multi‑line string, and here I'm just passing in two different string values. And I could go through if I wanted to and create an object just based off this JSON string. And if I did that, I would end up with a valid object. And I'll run this here to show you that's the case. Here uou can see we do get back an object where we have firstName and lastName and we have the correct names in place, the correct string values. And this also presents an interesting challenge. What happens when you try to parse something that's not valid JSON? What would you do? Well, in this case, if we were to look at this, I'm just saying "hello!" as a string, that's not valid JSON, and so if I try to parse it, what do you think is going to happen? Well, in this case, we're going to actually run into an error. So it's actually tried to parse this, and it's basically saying, hey, I can't do it. In this case, it says there is a SyntaxError, that there is an unexpected token. Now, we will cover how to deal with this later because anytime you do parse JSON, you need to account for this as a possibility; however, we're not covering that just yet. But we'll cover that when we get to error handling within our JavaScript applications.
So now we're going to talk about the process of formatting numbers, and trust me, you'll be utilizing this probably even more than you think you will. So let's talk about some different use cases that we might run into where we will need it to format a number. And maybe it's just something simple, like we want to display a number, and we need to round a number to its nearest integer value. Or, maybe we want to just limit the number of decimal places that are actually displayed when we're showing a number. So instead of showing 100 different points after the decimal, we just want to show 2, for example. Or maybe we want to output a number to a certain geographic area. So, not all areas actually display numbers in the same way, so we might need to convert it for that reason. Or maybe we want to do a specific use case tied to something like a currency format. These are all different use cases that would lead you to format numbers when you're using them within your JavaScript applications. Now, I need to introduce another concept that will be essential to what we'll be covering here in this module, and that is the concept of a locale. So, in computing, a locale is a set of parameters that defines the user's language, region, and then any special variant preferences that the user wants to see in their user interface. So usually a locale identifier consists of at least a language code and a country or region code. So, locale is an important aspect of i18n. Now, if you ever see the term i18n, that actually is just short for internationalization, and that's what we're going to be looking at here. So to just make that real, anytime we have a locale code, we're going to have generally three elements. So we will have the first identifier, a dash, and then the second identifier. And if you go by what we just learned from the previous slide, the first identifier will be for the language, and the second identifier will be for the region. So, in this particular example, this is the locale code for English spoken in the United States. Now here we can see a list of a bunch of different sample locale codes. Now, again, these are just samples. There are many, many more that exist. This is simply a small fraction of what's available, but I wanted you to see how these are represented for different areas in the world, and we'll be using some of these when we head over to VS Code in just a minute. But before we go to VS Code, I do want to point out two additional areas of documentation. One is for the math built‑in object, the global object that is available within JavaScript. So here you can follow the link on the screen to learn more about the different methods that are provided in that global object. And we also have the international number format object that we have available within JavaScript. We'll be using this as well, so you can follow this link on the screen to get more information about it. Okay, now that we have all of that out of the way, let's jump in to VS Code. So I'm here in VS Code, and the first thing I'm going to do is to create a new file. Now, within this file, I'm going to go in and start off by just creating a number. And I want to talk about how we can actually manipulate this number in three different ways. So you'll notice here we have 5.618345. Well, there's a lot of different things we might want to do. We might want to round this to the nearest integer. And so if we wanted to do that, there would be one global method we use from the math object. Maybe we want to actually have it give us the next integer passed this value, or maybe we want to give it the integer that it just passed. So in those cases, we have three different methods. So if I look here, we're first going to just do the rounding, and that's going to be math.round, and then we pass in our number. The next one is Ceiling. That is going to give us the first integer passed this value. And then we have Floor, and that is going to give us the integer that we went past before we got to this value. And so if we were to actually go through and run this by just hitting F5, you'll see that if we round the number because it's 5.6, it's going to round up to number 6 as the integer. If we use ceil, which is short for ceiling, that's going to be the number 6 as well because that is the first integer passed this value. And then if we do floor, that's going to give us the last integer before this value, and that would actually come out as 5. So, that's just a really basic way to utilize that math global object to format and manipulate the numbers that we're passing into it. But we actually need to walk through a lot more. Let's talk about another example. So here I want to talk about fixed. So what we can do is we can call toFixed on any number, and what this is going to do, it is going to fix the number of decimal places that we have after the decimal point. So if you notice here in our original number, num1, we have 6 different places after the decimal. What we're asking here in using toFixed is to return only 3 decimal points. Now, I want to call out here the type of data that's returned. That's why here in the console.log statement I am running typeof. So, let's go ahead and take a look at this. So here you can see it actually returns a string and not a number. Again, this is what we would use to actually display a value where we didn't have maybe a huge number of digits after the decimal point. And you can see that in the value, it's returned 5.618, which is the first 3 decim after the decimal point, and that's how we would utilize toFixed if we wanted to display a sub‑segment of the overall number of decimal points. Now, let's keep going here because the other thing we might want to do is display a number in a format for a specific locale. Now, I'm going to create a number here called num2, and here I'm going to use the underscores, but again, we don't have to use those. That's just a way to make it easier to read. So this number here is 1 million, but that isn't displayed the same way everywhere. So let's go ahead and see what we would do if we wanted to format it for the USA, right? And we're going to use that locale string en‑US, which, again, is short for English in the United States. And so if I run that by hitting F5, we can see that it returns 1,000,000. That's how it would be displayed in the U.S. But we also could choose to look at it from somewhere else. In this case, we'll look at it from Greece. So let's go ahead and run that, and you can see here that instead of commas, we're actually using decimal places. So those two different bits of punctuation actually switch places here. Now, we could go ahead and look at another example, which would be here, we want to look at Bangladesh. And so in this case, we can pass in the correct locale code, and when we run it, we can see that we just have spaces. I'm going to give you one more example here. And so here we could do Punjab and we could go in and pass in the correct locale code, and when we run it, you're going to notice that we actually have completely different comma placement than we did for the U.S. Now, here's the great thing; you don't have to remember all of these rules. This is something that is built in to JavaScript. So we can actually format numbers to the correct locale. Now, sometimes we want to do something that's even more complicated, and that is we want to go in and we actually want to format currency. And if you think about it, currency can be displayed in a lot of different ways. Now, let me explain what I'm doing here. I have a salary number. So let's pretend that we have an employee that makes 100,000 year. Now you might say, well, 100,000 what? Well, that's what we're going to convert it to here in a minute. But let's say what would their monthly salary be? So I'm going to go ahead and give an example here of utilizing toFixed. We're going to return this with two decimal places. So if I go in and run this with F5, we can see that the monthly salary is 8333 and 33 whatever. Again, we haven't defined what currency this is, so I can't actually give this any type of a descriptor yet. Now let's go ahead and take a look at what this would be if we were going to format this specifically for the U.S. So, en‑US, just like we did before. Now, there's a few different steps here, and I realize we haven't yet gone through and talked about functions yet and arguments and all of these things, so I realize some of this might seem a little bit strange. But what we need to do is give it two bits of information. The first is we do need to give it that locale, which we have. That's en‑US. And we also need to tell it what currency we're wanting to convert it to. So, in this case, that is USD. And there is a standard three‑letter identifier for every currency, and that's what we're going to be using here. So if I were to run this, you can see that this would come out to be $8333.33. But we could go through and display several different currencies, and you can see that there's a lot of different rules that go into different currencies. So maybe we want to actually convert this into Euros, for example, right? So we could log that out. Or, maybe we want to go in and instead of that, we actually want to utilize Japanese Yen because there is something that's unique about Yen, and we'll talk about that here in just a second. Or maybe we actually want to do Hong Kong dollars. And so we could actually enter in the correct locale code for that as well, as well as the correct currency code. So, now that I'm getting all of these in place, we'll run all of these together so you can see the different ways that currency would be displayed. So here if you see the U.S. dollars, that's what we saw before. In Euros, we actually have the identifiers that comes after the number. For Yen, we only have the whole numbers, we don't have what we would call minor units in their currency. And Hong Kong dollars looks a lot like U.S. dollars, except we have the prefix HK that comes before the dollar sign. And so these are all different ways that we can convert numbers that we have into values, whether it's just number values or currency values that are specific to different languages and different geographic regions in the world.
So we've already covered how to access the different elements of a date, but now I want to dive in and take it further and introduce you to some additional capabilities that you have when you're working with the global Date object in JavaScript. So, let's jump right to VS Code. So here in VS Code the first thing I'm going to do is to create a new file. Now here within this new file, I want to start off by creating a date. So here we'll utilize the standard date format that it's actually expecting. Now, we're going to specify here a date of January 23rd, it's going to be 2:23 in the afternoon, and it's going to be in the Eastern Standard Time Zone. We can see all of that through that standard string that's been included; however, if we were to just automatically convert this to a string, we get a pretty long bit of information. So let's go ahead and hit F5 and run this, and you can see we get a full date string that actually gives us all of that information, including the day of the week and a bunch of different bits of information. Well, sometimes we don't want to display all of that, and maybe, for example, we just want to actually display the calendar date. So one of the things we can do is we can utilize the methods that are included with our Date object such as toDateString. Now, if I were to run this, I get back some information. It says Monday, January 23, 2023. Now, notice here that we're using the short version of Monday and the short version of January. So, maybe this isn't necessarily ideal, and ideally we want to have the ability to customize this a bit, but if you remember from our previous clip, one of the areas of customization that we may need to do is to customize something for other locales. And so if we want to take a look at the other locales and how we would format that, we can utilize another method that's included with the global Date object, which is toLocaleDateString. So, let's go ahead and take a look at how that would work. So I'm going to start off here by doing the same thing with the same date, but we're going to utilize this new method, and I'll start by passing in the locale, en‑US. We're again English speaking here in the United States. So if I run this value, I'm going to get back 1/23/2023. Now, that seems like that's a pretty good date string if you're in the United States; however, we know that other places choose to actually lay out those different numbers in a different order, such as in the UK. So if I were to run this, you can see that returns the day and then the month and then the year, instead of the month, day, year. But we could go even further than that and take a look at what it would be like if we were in Japan. So here I'll do the same thing and pass in the locale ja‑JP. And then if we run it, we'll see yet again a different order, year, month, day. Now you've probably guessed this, but we don't have to just do calendar dates. As I mentioned to you, our Date objects in JavaScript represent both dates and times. So if we want to extract the time, we can also do that utilizing toTimeString. So if I were to run this now, you would see that this returns with 14:23:02 and then the specific time zone, which in this case is going to be Greenwich Mean Time minus five hours, which of course is Eastern Standard Time. But we can also do the same thing with this because we will at times have to format times to be different locales. So let's take a quick look at what that would look like. So here we'll do the same thing and start off with en‑US. So I'll pass that in, and I'll run that. And you can see here this returns 2:23:02 PM. Perfect! Now, if I was to keep going, we could then take a look at the same other locales. So here we'll do the UK, and if I pass this in and then hit F5, we're going to see that it returns by default a 24‑hour time, so 14:23:02. But if we went and looked at Japan, we would see that it's actually going to share a value, but let me go ahead and hit F5, and so you can see here the time, in this case, replicates what's included in the UK. So sometimes we will want a little bit more ability to customize this, and here we're going to get into some things that are a little bit more advanced, so I want to go ahead and show you that we're going to define a just object literal. We'll call this options. And I'm going to include two different properties, one called dateStyle and one called timeStyle, and I'm going to specify here that both of these are short. So, this is the options object that will allow me to customize how the JavaScript Date object gets translated into a string, and I want to give you a couple of different options here. So let's go ahead and look first at what it would look like in en‑US, that's generally where we start, that's the locale that I'm in. And so if we say toLocaleString, we pass in en‑US, and then we pass in the options, I can get back just the date comma and then the time. And in a lot of cases that might be what I want, but there's also a lot of additional customizations, but we'll talk more about that in just a minute. We also have the option to go in here and say, well let's do it for a completely different type of language. So in this case we'll do Arabic in Kuwait, and so if I were to run this and hit F5, we would see that this returns a completely different string, but here we have time first followed by the date. It's going to be year and then month and then day. So, we can showcase a good degree of flexibility with the included Date object. Now there are many different libraries, and we'll talk more about third‑party modules later within this course, there are many utilities out there to help you work with JavaScript; however, one of the great things is is that you get a lot of this native internationalization capability with the Date object that's included with JavaScript, and you can customize it. Now, I notice I've only shown you here the customization for dateStyle and timeStyle, so I quickly want to call out here the Intl.DateTimeFormat constructor. So the options object that you pass into toLocaleString includes the same objects as we have here on the DateTimeFormat constructor. And so you can go through and see all of the different values here that you can specify. So if I scroll down here to options, you can see we have dateStyle, we have timeStyle, we have different calendars, we have different dayPeriods. There is so much that we can change here based on what we're looking to do with the format of our dates. And we'll get into some more advanced use cases for this later, but what I wanted to cover in this module was that you can indeed customize how your dates get converted from Date objects into strings in JavaScript.