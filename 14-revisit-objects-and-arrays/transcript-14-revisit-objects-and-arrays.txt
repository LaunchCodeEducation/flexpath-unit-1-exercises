Course Overview
Course Overview
Hello everyone. My name is Matt Henry, and welcome to my course, Arrays and Objects in JavaScript. I'm a vice president of product at Innovative Language Learning and an independent developer. Arrays and objects are everywhere in JavaScript, and for that reason, many developers use them without really understanding them. A clear‑headed understanding of arrays and objects, including how they operate behind the scenes, is sure to make you a much more competent and respected developer. In this course, you're going to master arrays and objects, learning not just the technical details, but also strategies to use them effectively in your code. Some of the major topics we'll cover include object prototypes and how they can unlock a ton of power without the need for classes, reference types versus primitive types and how this fundamentally changes what you can do with objects, and a complete discussion of array iteration methods to write clean and readable code. By the end of this course, you will have the confidence to use arrays and objects in your projects without ever being surprised by their functionality. Before beginning this course, you should be generally familiar with JavaScript syntax and data types. I hope you'll join me on this journey to learn how to become a more competent and confident JavaScript developer with the Arrays and Objects in JavaScript course at Pluralsight.

Approaching Objects and Arrays
Approaching Objects and Arrays
Even if you're a JavaScript beginner, you've probably seen and used arrays and objects before. So, when you decide to start watching a course called Arrays and Objects in JavaScript, I'm not expecting that you have questions like what are arrays and objects, or how can I start using them? I think you already have a general idea about the answers to both questions. You don't need me to give you an academic definition or to get you psyched up about the exciting world of arrays and objects. Instead, you're here because you've been using these things but are puzzled about some of the details. Maybe the difference between prototypes and classes are a little fuzzy for you. Maybe you've heard that objects are reference types but don't really know why you should care. Maybe you've looked at the long list of array functions and thought, yeah, I'll stick with the for loop. In this course, we'll explore arrays an objects, not from the outside in, as strangers who are waiting for an introduction, but from the inside out, as casual friends who want to better understand why arrays and objects are the way they are. That's why we'll start by talking about objects. You should understand what it means for something to be an object in JavaScript, before you can really understand arrays. Why? Because arrays are objects. Many things about arrays can be simply explained when you understand how a basic object behaves. But objects are not just a stepping stone on the way to arrays. They're such an integral part to any sort of JavaScript development you'll want to do. Objects are everywhere, and when you feel like you understand them deeply, it will improve every part of your coding experience. So, let's get into it. Bear with me through one more introduction clip where I'll give you an overview of the course itself and what you need to do to get the most out of it. That's next.

Course Overview
This course will teach you about arrays and objects in JavaScript. After this introductory module, we'll get into objects. First, we'll discuss object prototypes and properties. Then, we'll discuss how objects are reference types and what that means for you. After that, we move on to arrays. You'll learn all the powerful things you can do with arrays, and pitfalls to avoid. After that, I devote an entire module to iterating through arrays. If you've been falling back on using a for loop for everything, this is where you can find out how much more productive you can become. Throughout the course, I'll be using a single project for code examples. It's a basic LMS, or learning management system, whose purpose is to help new employees get onboarded. It's made up of three parts, a front end for administrators so they can make and edit courses, a front end for employees so that they can take courses and bookmark things, and a back‑end API, which handles passing data between the front ends and the servers. It's very, very important that you understand this isn't a how to make an LMS course. I don't recommend you code along with me. I will make the code available to you so you can explore it if you're curious about how everything comes together, but the project is by design, very simple. It doesn't have authentication, error handling, or support for multiple users. But, what I hope it does provide is a realistic background against which we can introduce these concepts about arrays and objects. In this course, I use Vanilla JavaScript. Other than the back end, which runs on Node and Express, everything in the course is basic standards‑based JavaScript. Objects and arrays are used by just about anybody working with JavaScript, so, I don't want to get too caught up in any one application or environment. The goal is to keep things general enough that you can apply this information to your own situation. And finally, there's one major area which is off limits in this course, object‑oriented principles. JavaScript supports classes, and you can coerce it to behave like an object‑oriented language, but it's not its natural state. JavaScript is first and foremost a prototype‑based language. We'll be using prototypes throughout, even in some cases where using classes might be easier. For more on object‑oriented principles, check out the Object‑oriented Concepts in JavaScript course on Pluralsight. My promise to you is that it's worthwhile to spend some time exploring JavaScript as a prototype‑based language before you start to look at it through an object‑oriented lens. You'll better understand some of its quirks and also realize that you don't always need to use classes when prototypes can solve your problem just as well. Okay, introduction done, let's talk about objects.

Objects and Properties
What Is an Object?
You already know what an object is. Objects are one of the easier things to get your head around because when you talk about objects, you're no longer talking about technical details of a programming language, you're talking about the actual real life things your code's trying to achieve. My app has users, I need a user object. My app has products, I need a product object. But in development, things that are easy to grasp can be harder to understand because grasping leads you to feel like okay, yeah, I got it. When there's a million things to learn over the course of your development journey, why take the time to understand the deep nuances of something you already understand intuitively. If this is where you currently stand with objects, then you need these two modules because, here, we're going to look at what objects actually are, how they're implemented in JavaScript. This deeper understanding is crucial to becoming an effective JavaScript developer because objects behave the way you expect until they don't, and without taking your understanding beyond the surface level, this will lead to some very frustrating moments. This is usually the part where you'd get the formal definition of what an object is, but instead, let me just say three true things about objects in JavaScript. One, objects are containers of other data types. This is what allows us to use objects to talk about concepts like users or products. When you think about the objects in your own projects, one of the first things you'll think about is the data contained in those objects. A user has an ID, a name, a timezone, and so on. All of these things can be encapsulated within an object. What's a user? It's a thing that contains all these other things. The data contained within objects use the same data types we use elsewhere in JavaScript. But, when contained in an object in this way, we call them properties. The second half of this module is going to cover properties in depth. Two, objects are passed via reference. In general, you don't need to concern yourself with things like memory management in JavaScript, but this is a situation where it's really important. Objects are passed around in your code by a reference. Contrast that to what happens when you define a primitive data type, and here I'm talking about things like a basic number, a basic Boolean, the name is defined and it points directly to the value, this name means this. Objects are different. When you define an object with a name, the name doesn't point directly to the object, instead, it points to an address in memory. The object with this name, you can find that over there. This is not just academic, it directly affects the way you will write your code. We'll discuss that in the module, Object References and Scope. Three, objects link to a prototype. This unlocks a whole lot of functionality, which simulates the way objects work in other languages, but it's important to keep in mind that this isn't how objects work in most other programming languages. You can simulate what we call object‑oriented principles in JavaScript, but it's crucial that you understand prototypes first or else it's easy to become confused. I'll discuss that in just a little bit. So, what is an object in JavaScript? It's a container of other data types, which are passed via reference and linked to a prototype. Let's see how to create objects next.

Creating Objects
The way to create an object, you've probably seen before, is with the object literal syntax. This means using this structure with curly braces. Inside the curly braces are the contents of the object, or in other words, all of the properties. So in this case, we are defining an object to describe a course. That course has a title, an ID, and an author. So, this is an object in its simplest expression. We just encapsulated a bunch of properties. Each of those properties has a name and some data. Before moving ahead, let's do a quick sidebar on syntax. Property names are usually referred to as keys. The data associated with keys are called values. In this case, all the keys and values are strings, but the values are in quotation marks and the keys are not. It's not required to put your keys in quotation marks in an object literal, but, if your keys contain the type of characters normally not allowed in variable names, such as a space or a hyphen, you do need to surround it in quotes. In between each property in an object literal are commas. These are required between properties. They are not required after the final property, although some people prefer them to be there, your code will run either way. Finally, you need a semicolon here because this whole thing is an expression. If you've ever seen a JSON document, this syntax will look very familiar. A JSON document is basically an object literal. After all, JSON stands for JavaScript Object Notation. But, in a JSON document, the keys must also be surrounded in quotation marks, regardless of what characters they contain. Also, JSON documents don't allow trailing commas, and because they're not expressions, there's no semicolon necessary. Okay, if you've work with JavaScript before, this is all familiar to you. We use object literals like this early and often, but there's something a little weird about the way objects are normally taught because sometimes objects are just a structured collection of properties. You build it up, add all the properties you need, and then use it in your code. But then as you learn more, you introduce a different way to think about objects, as instances. Let me explain. Another common way to create objects is with the new syntax. You might see something like const myDate = new Date. This is saying there's something out there called date, which has a bunch of functionality attached to it. And, I want to make a new one that I can use for my own purposes. So we create a new date object or a new instance of a date, and we set that instance to the name, myDate, and just like that, we have access to all date's functionality within this myDate object. So we have two different ways to think about objects. On one hand, we're working with an instance of some unchanging blueprint that has useful structure or functionality we want to use. On the other hand, we're creating one purpose‑built collection of properties from scratch that helps us simplify some concept in our code. If this seems like two completely different things to you, you're right. Creating objects with the object literal syntax greatly simplifies the process of getting a readymade object you can start using immediately. But this convenience has a dark side, because it means you can start using objects without really understanding them, and this way of using objects bears little resemblance to other ways of using objects you'll encounter later. The truth is all objects linked to some previously defined blueprint. These blueprints are called prototypes in JavaScript. In this case, we're linking to the date prototype. But, what about this case? What prototype is it linked to, and why does it matter? And by the way, what is this date prototype, and how do we have access to it in the first place? To understand this, let's take a deeper look at object prototypes.

What Is a Prototype?
All objects link to something called a prototype, but, what does that actually mean? Let's start with that code from the last clip, const myDate = new Date. We know that when we do this, we have this thing assigned to the name, my Date, which can do all sorts of date things. I could print out myDate.getDay, and it returns a number which represents the current day of the week. Hey, it's Tuesday. But how is it that I have access to this? First, let's ask what this thing, Date, is. We never defined something called date and we certainly never defined functionality for getDay, and yet we're able to use it. Date is one of the standard built‑in objects that is always available to you in JavaScript. It's like the people who wrote the implementation of JavaScript in the environment you're using wrote a bunch of code for you. That's great, but if the idea of relying on invisible code is disconcerting to you, join me for a short sidebar to see for yourself. I will open up the developer tools in the browser I'm using and go to the JavaScript console. Here, I will type this. This will show you the global object of the environment you're in, the stuff that you can always access in your code if you just know the name for it. If I scroll down here, I can find Date. I can open that up, but I still don't see anything called getDay. But what if I open up this thing called prototype? And there it is, getDay, along with all the other functions I'm able to call on objects which link to this prototype. Date is just one of the many objects which are predefined and available to your code whenever you write JavaScript. But, there are many others, with names you might recognize. Math, String, Array, and what's this? Object? That's right. There's something defined on the global object called Object, and it also has its own prototype. This is going to become important very soon. These are the takeaways right now. Many objects are predefined for you in the JavaScript environment you're working in. That means you can use them in your code without writing them yourself. The important part of these predefined objects are their prototypes, which is what describes their special behavior. The thing that makes a date a date and an array an array can be found in their respective prototypes. With that, let's return to this code one more time. When you say const myDate = new Date, you are creating a new empty object called myDate. We say that myDate is a type of date or an instance of date, but what we really mean is that myDate is linked to that same prototype we saw in the global objects, Date. All that stuff we saw, including a function called getDay, is now available to the myDate object by virtue of this linkage. So what happens when you call myDate.getDay? JavaScript first looks at the object level. Is one of the properties on this object called getDay? In this case, no. Remember, this is a new empty object. The only thing defined about it is the prototype it's linked to. Since there's no property called getDay defined on the object itself, JavaScript next looks at the prototype. Does it have a property called getDay? In this case, yes, so it gets called. If the prototype didn't have this property, it would then look at the prototypes prototype, and on and on. We call this the prototype chain. Only if none of the prototypes in the prototype chain contain the property would JavaScript return an error. I'll just restate this. When trying to access a property on an object, JavaScript first looks at the object itself and then goes up the prototype chain. The first match will be returned. I hope the method of directly linking to a prototype by using the new syntax is starting to become more clear, but now it's the more simple way of creating objects with an object literal which should seem strange. Let's talk about that next.

Defining Prototypes with Object.create
Based on our current understanding of the way objects link to prototypes, now it's the object literal syntax which should seem strange. MyObj is an object, that much is clear, but when we said that myDate is a date object, myObj is what? What prototype is myObj linked to? That's why I took a brief detour to look at this item in the environment called object. It's this prototype that every object literal links to. It's also this prototype that sits at the very end of every prototype chain. So, to answer our question, myDate is a date object because it links to date's prototype. MyObj is an object object because it links to object's prototype. It can get confusing when talking about objects because it's sometimes unclear whether someone's talking about a lowercase o object, which is the generic way to talk about this data type, and a capital O object, which defines the most basic prototype that all objects link to. And calling something an object object like I just did is a nightmare. So you can talk more clearly about this by saying myObj links to Object's Prototype. Another way in JavaScript to say that something belongs to an object is .notation, so we could say myObj links to Object.prototype. We now have the missing link in order to bridge these two ways of creating objects. The object literal syntax is simply a shorthand for creating a new object which links to Object.prototype. So it's the same as if we were to set it to a new capital O, object. There's one other way to create objects that you should know about, and now that we've explored prototypes, it will be much easier to understand. That last way is Object.create. This is a function which creates a new object and takes in one parameter, the prototype you want to link to. Which prototype do we want for a standard object? That's Object.prototype, so all three of these approaches are equivalent. In the same way, these two ways of creating dates are equivalent. Because we can use Object.create to define the prototype explicitly, it also allows us to create our own prototypes. So, I can define a prototype for a course as an object literal and then set newCourse to a new object with that prototype. Now the newCourse object is linking to a prototype that we've just created. Remember that newCourse itself is empty. When we search for a property such as title, there's nothing on that object which is returned, so the value from the prototype is returned. But, if we set a property on the object itself, that value will be returned instead of the prototypes value. And remember, coursePrototype was created as an object literal, so its prototype is Object.prototype. There's one caveat to the statement I made earlier that all objects link to a prototype. It is technically possible for you to use Object.create to make a new object with no prototype by passing null in as a parameter. As you get into really advanced JavaScript, there might be some reasons you'll want to do this, but I think it's pretty safe to say that you don't need to worry about this right now. This is as far as I want to explore prototypes for now, but we'll keep making references to this concept as the course goes on. For now, here's a summary of object prototypes. Many objects are predefined for you. Objects link to prototypes which define their behavior. Calling a property on an object will look through the prototype chain. Object literals link to Object.prototype, which also sits at the end of the prototype chain. The prototype of an object can be set with the new syntax or Object.create. In talking about objects and their prototypes, we talked a lot about properties, but now, let's transition into a deep dive on object properties, starting with creating them, next.

Creating Properties
The rest of this module is devoted to object properties, and it's where we'll start customizing objects to our own purposes. Remember, we're building out an LMS to onboard new employees. Now we need to think a little bit about that behavior. In our LMS, we need an object to define a ContentBlock. This is how we'll represent a single piece of information that a new employee should understand. By defining a ContentBlock in this way, we can organize our courses into smaller units, which can be displayed one at a time. An employee could also save individual ContentBlocks into their notebook to review later. So, we need a ContentBlock object and we need to add some properties onto it. Here, you should be asking yourself the question, am I making a single object that will only be used once, or is my project going to have a lot of different objects that all follow the same blueprint? If you only care about making a single object, it's fine to add the properties to an object literal. Object properties can be just about any type in JavaScript, strings, numbers, Booleans, functions, and even other objects. So, a basic ContentBlock object might look like this, but we know we need a bunch of ContentBlocks. They're all going to have basically the same properties and functionality. So it's useful to define it once and then make a bunch of references to it. Sounds like we'll need a ContentBlock prototype, and this object literal's a great place to start. I'll just change the name of the object to contentBlockPrototype and also set its property values to be default values. Now, I can create a new object using the contentBlock prototype. Let's refresh what we've just done. ContentBlock1 is an object whose prototype is contentBlockPrototype; otherwise, it's empty, so if we try to access a property on this object, like color, we would get an error. That makes sense. But, if we were trying to access a property defined on its prototype, such as description, we would get a response. JavaScript goes up the prototype chain and returns the default value, which is no description. This should be familiar to you by now. Let's now create some properties on the object itself. There are two ways to do this. First, by using dot notation, second, by using bracket notation. Dot notation is the shortest way to create a property, but there are some situations you can't use it. For example, if you're trying to access a property whose name is an illegal variable name because it has a space or a special character in it, JavaScript will see this as a syntax error. You have to use bracket notation instead. Bracket notation also has the advantage that you can compute the property name at runtime. You could do something like this, looping over numbers and creating properties, info 1, info 2, and so on. But, as a general rule, I will be using dot notation unless there's a really good reason to use bracket notation, and I recommend you do the same. If we were to access contentBlock1's description property in this case, the property set on the object is returned. You can see that the default value is still set on the prototype, it's just that JavaScript doesn't need to traverse the prototype chain because it finds a property with that name on the object itself. Now I can add the remaining properties to this object by using dot notation. Of course, I'm not limited to using properties that are defined on my prototype. I can define a brand new property, like color, and only put it on the object. If I now access contentBlock1.color, it would be returned. This is part of the dynamic nature of JavaScript objects, you can add new properties easily and quickly. But, now it produces an interesting problem when we write code to access our object properties. Let's talk about that next.

Accessing Properties
You can access properties the same way you create properties, by using dot notation or bracket notation. The complicating factor here is that when you're writing code to access object properties, sometimes you don't even know if the property exists. Consider the example from the last clip. We've created a situation where some ContentBlocks have a property for color. We'd want to use that property if it exists, but we also don't want to assume that it exists. This means we must code defensively. Here, I'm working on the employee‑facing front end. This UI is responsible for letting the employee navigate between ContentBlocks in a course and rendering each ContentBlock. Specifically, this is the function which reads the data from the ContentBlock object and updates the DOM. It's pretty simple. We're setting the innerHTML of two elements to the value of contentBlock.title and contentBlock.description. If we knew that contentBlock.color was set on all ContentBlock objects, we could do something like this, but here's the issue with that. In this sample course, block one and block three have no color defined, only block two does. Let's see what happens. Block one appears correct, I see the default white color. Block two also appears correct, I see the yellow color. But block three displays as yellow when it should be white, and that's not all. When I press back two times, now I see that block one is yellow too. When accessing a property in JavaScript that doesn't exist, JavaScript returns undefined. So, for block one and block three, we're telling JavaScript to set the background color of this element to undefined. When it gets that instruction, it just ignores it and does nothing. So, block one is displayed, JavaScript does nothing, so the background remains white, like I set it in CSS. Block two is displayed, JavaScript sets the background to yellow. Block three is displayed and JavaScript does nothing. We return to block two, JavaScript sets the background to yellow again, then we're back to block one, and JavaScript does nothing. We need some conditional handling of this line so that we set the background color if the color property exists, and set it to white otherwise. But what exactly should we check for? There are a few options. We could check if contentBlock.color is equal to undefined, setting the background color to white if so, and contentBlock.color, otherwise. As you can see, that solves the problem. I can also call the function hasOwn on contentBlock, passing in the string, color. This function comes from Object.prototype and is a way we can check that an object has a property of the given name defined on the object itself. That means if the property is defined on the prototype only, it will return false. By the way, hasOwn is meant as a replacement for the function hasOwnProperty, which you might have seen before. You can use either, and hasOwnProperty has better browser compatibility, but it's recommended to start using hasOwn. Another way is the in operator. You can write color in contentBlock as an expression which will return true if there's a property with this name defined on the object. But, unlike hasOwn, this will also return true if anything in ContentBlock's prototype chain contains this property. So, hypothetically, it would return true for hasOwn in contentBlock because that property is defined on Object.prototype, but for our purposes, it would work as well. So, those are the three ways to check on the front end, whether a property is defined on an object. But, there is one other option. We could make sure ContentBlocks never return undefined when accessing the color property. We could simply add a property for color on ContentBlock's prototype and set the value to white. This takes advantage of the way the prototype chain works in JavaScript. If there's something defined on the object for color, it will return that value. Otherwise, it will go up the prototype chain and return white. Then we could remove all this conditional code on the front end and just query contentBlock.color, with the knowledge that a valid response will always be returned. We now know how to create and access properties. In the next clip, you'll learn how to delete properties.

Deleting Properties
When talking about consuming data in an application, one acronym you'll hear is CRUD. CRUD stands for create, read, update, delete, and you can think of it as the four types of operations you can perform on data. As far as object properties are concerned, you now know how to do three of the four operations. Let's review. Create. You can create a property by accessing the property name with dot or bracket syntax and setting its value to something. If the property is not already created on the object, JavaScript will create it. Read. Similarly, you can read a property by accessing it with dot or bracket syntax. If it exists, this returns the value; otherwise, it returns undefined. Update. This is exactly like create. Delete is the final piece of the puzzle, and this is how you do it. Delete, space, property name. By doing this, you will completely delete the property from the object, but why might you want to do this instead of just ignoring the property? Well, consider if you have created useful default values on an object's prototype. If we read the color property on the object, JavaScript will only traverse the prototype chain if it does not find a property with that name on the object. By deleting that property completely from the object, now querying the color property on the ContentBlock will return the value from the prototype. If instead we had set the property to be a blank string or set it to undefined, then that blank string or undefined value would be returned. When using prototypical inheritance in JavaScript, try to make sure that you don't define a property on an object unless it's significant, or else useless data may cover up useful data. Back to our LMS. When someone at Globomantics had the great idea to allow anybody to set the color of a card's background, they didn't consider two important things, consistency and accessibility. As a result, after a few months, cards have been published using whatever colors the creator wanted. It looks bad, and worse, some of the cards don't meet accessibility requirements for color contrast and are hard to read. So, the request comes in, the only color we want to allow is light yellow, any other color should be shown as white. Our contentBlockPrototype already has white defined as the color, so if we delete any color property on a ContentBlock that is not light yellow, the color property on the prototype will be read instead. Now, non‑matching colors are being removed and displayed as white instead. This completes how to create, read, edit, and delete properties in JavaScript, but, we're not quite done. What if you don't want your object's properties to be edited or deleted? That's next.

Protecting Properties
So it's pretty easy to edit and delete properties on your objects, but it's worth asking, is that a good thing? If you come from a strictly typed object‑oriented language like C#, you may find it very strange how easy it is to edit objects. In those languages, objects are secretive about their internal data and the developer selectively chooses which properties can be accessed outside of the class. Compare that to what we know about objects in JavaScript. Every property can be read, edited, or deleted by anybody who knows its name. Of course, part of the difference is that we're comparing an object‑oriented language to JavaScript, which is a prototype‑based language. Of course they behave differently. And again, you can adopt some object‑oriented principles in JavaScript, but in this course, we are focused on prototypes. So, how can we control access to our objects without getting into JavaScript classes? Here, we need to look even closer at properties and extend our mental model of what properties are. We've been talking about properties as if they're made up of two things, a name and a value, but in fact, each property can contain a number of attributes, writable, configurable, and enumerable. Value is obvious, it's what we set the property equal to. When we access the property, we get its value. The other three are Booleans that can either be true or false. They all default to true, but we can change them to false if we want to. When a property's writable attribute is set to false, it cannot be edited and it cannot be deleted. Sounds like exactly what we want, so, how do we change a property's writable attribute? You need to use Object.defineProperty. This method takes in three things, the object, the property, and then a list of attributes as key‑value pairs. For example, here's where I configure my ContentBlock objects with my prototype before passing them on to the rest of my app. And later on, I'll be deleting the color property on these objects if the color is not light yellow. In order to prevent that, I could insert Object.defineProperty, passing in the ContentBlock object, the color property, and then this key‑value pair of writable false. Now, the line which attempts to delete the color property will fail. Configurable has some similarities to writable, but it's meant for a very different thing. When a property's configurable attribute is set to false, the property cannot be deleted, but it can be edited. But, the most significant thing about it is that it prevents its attributes from being changed. After all, what's the point of setting writable to false if someone can just set writable back to true? If configurable is false, then this line would fail. So far, I've been talking about object properties, but what if you just want to lock down an entire object? You can do that using Object.freeze, passing in the name of the object. Object.freeze does two things. First, it sets the writable and configurable attributes to false for all the properties in the object. The other thing it does is prevent extensions to the object because even if you lock down every property in an object, there's nothing preventing someone from adding a new property to that object. Object.freeze will prevent that as well. While we're here, there are two other methods that are similar to Object.freeze that you should know about. Object.seal does the same thing as freeze except it doesn't mark the properties as writable false, so it prevents extensions and prevents configuring any of the property attributes, but properties can still be edited. And, Object.preventExtensions only prevents new properties from being added, it doesn't do anything to the existing properties of the object. That covers these property attributes, but, what about this one? We'll talk about enumerability next.

Enumerating Properties
To understand this last property attribute, enumerable, we need to understand the concept of enumerability. Sometimes you'll want to ask JavaScript, tell me all the properties this object contains. For that time, we might use a loop, like this. You probably already know what a for loop does, but they're usually used for arrays. An array for 10 items, the for loop runs 10 times, once for each item. But, in the context of an object, the items we're talking about are properties, so, how many times will this for loop run? It will run once for every enumerable property in the object. That's what enumerable means, able to be counted. If we didn't want a particular property to appear when looping through properties of an object, we can set enumerable to false in the same way we adjusted writable and configurable in the last clip. Just for example's sake, I'll set the description to be non‑enumerable. Now this property would not appear when looping through this object's properties. I'm showing an example using the for in syntax, enumerating through the object itself, but actually, there are some other ways to loop through an object's properties, Object.keys and Object.getOwnPropertyNames. So, what's the difference? In the way they handle two things, whether the properties are enumerable or non‑enumerable and whether the properties are owned by the object or inherited. For a reminder, in this example situation, id, title, and description are owned by the object and color is inherited from the prototype. Also, description is set as non‑enumerable and the rest are enumerable. The for in loop we saw before returns all enumerable own properties and enumerable inherited properties. So, things that appear on the prototype could also appear, as in this situation where color is returned even though the ContentBlock object itself does not have a color property defined. If you want to ignore properties which are inherited from prototypes, you can instead use Object.keys, passing in the object. This returns an array, so we'll need to use the forEach syntax. This will now return id and title alone, leaving out any inherited or non‑enumerable properties. So, is there any way to get a non‑enumerable property to appear in a for loop? Yes, you can use the Object.getOwnPropertyNames method. Using this will return the description property even though we marked it as non‑enumerable. In summary, using a for in loop with the object itself returns all enumerable properties, both owned and inherited, Object.keys returns all enumerable owned properties only, and Object.getOwnPropertyNames returns all owned properties, even the non‑enumerable ones. That covers the different attributes of properties and also wraps up this module on object properties in general. From the next clip, we'll talk about object reference types and scope. I'll see you there.

Objects Behind the Scenes
Objects Are Reference Types
Objects are reference types. In this module, we'll fully explore what that means and how it changes the way you work with objects, and we'll start by revisiting one of the first things you learned about JavaScript, const and let. When you define a variable, you can choose to use const, meaning that the variable's value won't change over its lifetime, or, let, meaning you'll want to redefine the value later. So if you set const goldenRatio = 1.618, and then later on try to set goldenRatio to something else, you can't do it. This is a constant value and it cannot be redefined. But now, let's try using const on an object. You might be thinking, hey, didn't we just find a much easier way to perform Object.freeze that we learned in the last module? If you can't edit the object, doesn't that have the same effect as preventing extensions and making the properties non writable? Unfortunately not. The truth is I can still edit each property and add properties, so, what's the deal? It all has to do with how objects are reference types. There are two places in memory JavaScript stores data, the stack and the heap. The stack is a limited size space allocated for the JavaScript thread. Your browser or your node environment will set this limit. It's quick to access, but limited, both in its total size and in the size of the slots that can store each value. The heap, on the other hand, is a dynamic memory store. It's a little more complex to access, but can grow to encompass large things that don't have a defined size, including things that will grow as your application runs. As a result, there aren't slots with limited size. When you define a primitive type, like our goldenRatio number, JavaScript knows it will only get so big. JavaScript stores that in the stack. But, when you define an object, like our course, JavaScript doesn't know how large that object is going to become. It can't go in the stack or else when you add properties to it, it would eventually outgrow its slot size. It has to go into the heap with its dynamic memory allocation. But, here's the crucial thing. The name of the variable, myCourse, is stored in the stack, but the data associated with this name, the object itself, is in the heap. To bridge the gap, a reference to the object is stored in the stack with the name. When accessing the thing that your program calls myCourse, JavaScript finds the name in the stack, sees the reference to the heap, and then heads over to the heap to find the object itself. So why does an object defined with const still allow you to redefine the properties? Const puts restrictions on the relationship between these two things in the stack. The number defined with this name cannot be changed, and the reference defined with this name cannot be changed. It does not put restrictions on the object itself. If you add a property down here in the heap, nothing's changed about the reference up here in the stack. We have not redefined this constant. You can make as many changes as you want to this object without affecting the stack. What you can't do is associate the name, myCourse, with something else. Let's make another object, and this time I'll use the let keyword. Now there's another object in the heap and another named reference in the stack. Because yourFavoriteCourse is defined with let, I can do this, yourFavoriteCourse = myCourse. This will change the reference associated with your favorite course so that it now points to the same object that my course points to. This means if I edit the properties of this object by using either myCourse or yourFavoriteCourse, it would edit the same underlying object. It also means that the object formerly known as yourFavoriteCourse is lost in the heap because there's no more reference to it. But if I were to undo this and instead try to assign myCourse = yourFavoriteCourse, this is not allowed because now I'm attempting to redefine the name of this constant in the stack. Getting used to the difference between primitive and reference types is the next major level in mastering JavaScript objects, and if your head is still spinning, don't worry, the rest of this module will further explore this point and reinforce what you've learned in this clip, starting with how to compare and clone objects, next.

Comparing and Cloning Objects
The fact that objects are reference types means it's not as straightforward to clone or compare them, cloning primitive types is extremely simple, just set a new variable to the value of the old variable. This copies the value in the stack over to a new variable in the stack. But, as we saw in the previous clip, doing something similar with objects does not clone the object, instead, we get two names, one object. So if we try to edit course2, we'll be editing the same object that course1 points to. How about comparing? With primitive types, comparing is simple. Using the double equals sign, you return a bool if the two values are equal. Using the triple equals sign, you can do the same thing without type coercion. But with objects, even if two objects have the exact same properties, they'll appear as unequal. That's because these names point to two completely different objects. The fact that they contain the same properties with the same values doesn't matter for determining equality. So, being reference types, objects present problems when you must copy or compare them. In this clip, we'll talk about those problems. We won't fully solve them, however. How complex it is to copy or compare objects is a factor of how complex the objects themselves are. A simple object like our course, well, we can solve that problem, but an object which itself contains several other subobjects, nested multiple layers deep, that's quite a bit harder. Let's look at cloning first, and actually, there's a very good reason for our LMS to do this. When we open a page to display a course and all of its content blocks, the data about the course comes from our API as JSON. JSON can be used to transport a JavaScript object as a string through a server and into your code, where it can then be converted back into a JavaScript object. But when that happens using the JSON.parse function, the resulting object will point to Object.prototype. We want these to be courses and point to the course prototype. The basic process is this. When we get our JSON from the server describing the course structure, we create a new object linking to our course prototype. Then, we copy all the properties from the JSON object over to the new course object. First, we use Object.create to make a new object using course as prototype. Now, we need to decide how to copy all the properties over from one object to another. There are two ways this can be done, Object.assign, and the Spread Operator. Object.assign copies all enumerable owned properties from one to another. Object.assign takes in two arguments, the target object, which is our newCourse object, and the source object, which is our JSON object. Now this course object points to the course prototype, but otherwise contains all the properties returned from the JSON object. If you don't care about the object's prototype, there's another easy way to clone objects, by using the Spread Operator. The Spread Operator looks like this. If you put it before an enumerable object like this, then it returns all the enumerable owned properties from that object. Jumping back to the very beginning of this clip, we can fix this example by using the Spread Operator within an object literal syntax. These are now two separate objects which contain the same keys and values. But, here's the reason we're not done with our discussion about cloning. Objects can contain other objects. I could have defined my core structure like this. Now, author isn't just a simple string, it's an object of its own. If I were to do this same thing, it would clone each property in the object, yes, but, the property, Author, is itself an object, so it would clone the reference into the new object. That means changing the author's first name would change it on both objects. Solving this problem involves looking at an object, copying all the primitive values over, and handling each subobject separately. Then looking inside each subobject for more subobjects and handling those separately until you hit pure primitive values. This technique is called a deep copy and it can get quite complex. Likewise, when comparing objects, it can get quite complex. But what they both have in common is that if you know the structure of your objects, you can usually come up with a good enough option. For courses in this app, I can come up with a decent way to clone and compare. To clone, I'll do the technique I showed earlier. The only other challenge is handling the content property, which is an array. In module five, I'll show you how to handle that in detail. To compare, I can write a custom function that just returns true if the properties I care about all have the same values. It isn't the most robust code in the world, but it would be good enough for the situations I need to compare course objects. And that's about as far as I will cover deep cloning and copying in this course. From here, we're going to learn how to add some power to our prototypes by exploring functions as properties.

Functions as Properties
So far, all the properties in our objects have been primitive types, like strings, numbers, Booleans, or other objects. But there's one big type of property I've left out, functions. In JavaScript, functions are treated like any other variable. This is somewhat unusual among programming languages in general. Functions can be passed in as arguments to other functions or added as properties to objects at any time. So far, our ContentBlock prototype has been a little silly. There's not much to it, mostly what it does for us is provide default values when some property is not set. But, by adding functions to this prototype, it can start to get a lot more useful. I'll demonstrate this by implementing the bookmarking functionality. When an employee is reading a ContentBlock, they should be able to add the ones they want to reference later to their notebook. Then when the employee goes into the notebook section, they'll see the list of saved ContentBlocks. This is handled by the API calls, api/bookmark and api/unbookmark. By passing in the ID of the ContentBlock in the request body, this will add or remove this ContentBlock from the list of bookmarked blocks. Let's see how we can achieve this with a function attached to the prototype. On the study UI I have a button for BOOKMARK. Clicking this should make the API call. Here's the event handler we call when this button is clicked. The first line grabs a reference to the current ContentBlock being displayed. Then, we check if it's currently bookmarked. If so, we want to unbookmark it; otherwise, we'll bookmark it. Finally, we update the display of the card in order to toggle the state of the button. We could put the API call right here, there's nothing wrong with that, but there's another place we want to allow unbookmarking ContentBlocks, over in the notebook. So to me, it makes sense to define this function on the ContentBlock prototype and access it in both places. I'll make a reference to functions I'm about to create, unbookmark and bookmark, and now I'll head over to where the prototype is defined. Define a function like any other property with the name and a colon, but then I'll write function and open up curly braces. Oh, by the way, since ECMAScript 6, you can use shortcut syntax like this instead of writing the word function. Use whatever method you'd like, but in this course, I use the old method. In the bookmark function, the first thing I want to do is set the property bookmarked to true. I'm doing this because it's what the button click handler looks at to decide if it will call the bookmark or the unbookmark function, and it also determines how the button text appears. In order to access a property on the object itself, I use the this keyword, this.bookmarked gets the bookmarked property of whatever ContentBlock is calling this function. Next, I'll post the request to actually update the server state. As this isn't a course on API interaction, I'm going to gloss over the details, but basically I'm posting a request to the API endpoint I mentioned earlier, passing in this ContentBlock's ID as the request body. For the unbookmark function, I'll do almost the same thing, except the endpoint is different, and I'm setting bookmarked to false. Now, on the study interface, when I click the BOOKMARK button, it calls the bookmark function defined on my prototype in order to make the request to the API. And, I can see that the request body contains the ID of the ContentBlock I clicked. And because I defined this on the prototype, when I go to my notebook UI and I want to implement these remove buttons, I can call the very same on bookmark function. That shows you a bit of the power of object functions. As I've said before, you'll find a much more robust treatment of this subject in the course, Object‑oriented Principles in JavaScript, but I did want to show you how you don't need to define classes in order to get functionality, very similar to instance methods. But, any conversation about object functions isn't complete without investigating the subject of scope more carefully. That's next.

Scope in Objects
There are two things I want to talk about in this clip on object scope. The first is how the word this is evaluated with JavaScript objects. The second is what happens when objects are passed into functions. First, this. This is a special word that we use within an object to refer to other properties of that object. In the last clip, you saw me use the unbookmark function to set the value of the bookmarked property. What object does this refer to? It's whatever object that the function was called on. So, when I call unbookmark on this removedContentBlock object, which itself is whatever ContentBlock is in the notebook where you click the REMOVE button, then over here in the unbookmark function, this refers to that ContentBlock. Likewise, this.id refers to that ContentBlock's ID. Next, what happens when you pass an object into a function. In the notebook UI I have this function, apppendNotebookEntryForContentBlock. Basically, I pass in a ContentBlock object to the function and then the function appends a new copy of the notebook entry template to my page, using the data from the ContentBlock. But, here's the question. Is the object ContentBlock that's inside the function the same as the object that we passed into it outside the function? One way to test this is to see what happens if we try to change the object inside the function. For example, changing the title property to EDITED, and then logout the value after the function is called. We can see that, indeed, the value of this object's title property has been changed by the function. But before analyzing this further, let's change the function to not just edit the title property, but to set the object to a completely new object. Now, what is the value of contentBlock.title when we look at it outside the function? It is, in fact, the original unchanged title. This may seem weird, but it's just JavaScript behaving consistently, and it all comes down to, once again, primitive types and reference types. If we were to try this same experiment with a primitive type like a Boolean, we would see something similar to the second example. For primitive types passed into functions as arguments, JavaScript copies the value passed in as a new temporary variable. This variable can be referenced within a function and even edited, but when that function ends, so does the copy that was created. The original variable passed into the function remains in its normal state. That's why the value of the Boolean remains false here, despite being passed into the function, which ostensibly sets it as true. Remember that when we define a variable and set its value to a reference type, like an object, JavaScript first creates a space in the heap for the object itself, and then in the stack, it creates a reference to that object associated with the variable name. This relationship between the variable name and the reference behaves like a primitive variable would. That's why in this function, attempting to set the property ContentBlock to a new object had no effect outside the function. Within the function, a new copy of the ContentBlock variable was created. Now, that temporary variable was referencing the same object we passed in, but the object itself was never edited, only the reference. That's why when the function completed, that copy was lost. We're left with the same ContentBlock object that was passed in, all we did was change what object a temporary variable pointed to. But in this function, the temporary variable ContentBlock wasn't what we edited, instead, the function accessed the object referenced by the variable ContentBlock, then looked at the title property and edited that. When the function ended, the temporary variable was lost, but the change affected the actual object stored in the heap. So all variables passed into functions as arguments are safe from modification within those functions. The exception is when you pass in a reference type and then manipulate properties of the object within the function. Now that you understand what it means when we say objects are reference types and how they differ from primitive types, you can prevent yourself from falling into most object traps. But there's one last trap to learn about, object wrappers of primitives. That's next.

Object Wrappers of Primitives
We're about to move on from our discussion about objects, and I hope you come away appreciating how different objects are from other types in JavaScript, except, sometimes they aren't. Here's a simple number. It's a primitive data type, right? So, why the heck can I do this? It's easy to see what toFixed is doing, it rounds the number to two decimal points. But, why is it doing it? Number is a primitive data type. The question is where are these methods coming from? So far, we've only seen this kind of behavior with objects that have prototypes, and we know objects are reference types. Primitive types behave nothing like reference types, so to see them behave like objects is disturbing. So, what's going on here? The truth is that these are objects, kind of. They're called primitive wrappers, and, the best way to think about these is as a convenience within JavaScript to give some of the handy features of objects to primitives without actually making them objects. If you would check your JavaScript environment, you would find global objects for number, string, and Boolean, and these have prototypes defined with all the method definitions on them, so it is technically possible for you to make a number like this. Only, don't do this, because the truth is that numbers are primitive types, and that's a good thing. The way primitive wrappers work is that first, number is defined as a primitive type, but then when this line of code is run, behind the scenes, JavaScript creates a number object with the same value as number. It calls the function toFixed on it, returns the value, and then immediately deletes that object. This very next line, you are simply editing the value of a primitive type as if nothing strange has happened. So, how should you think about primitive wrappers? Well, just as what they are, a nice convenient way to get access to object‑like functionality you can use with primitives without needing to make everything an object. That does it for our discussion of objects. In the next module, we'll start talking about the most useful object you'll use, arrays.

Arrays
Arrays Are Objects
In this, the second part of the course, we're going to focus on arrays. Despite this course being called Arrays and Objects in JavaScript, we focused on objects before arrays for a very good reason. Arrays are objects. There are a few unique things about arrays, but in general, everything that was true of objects is true of arrays. Arrays contain properties, you can access properties with bracket notation, arrays get their specialized functionality from its prototype, and you can create new arrays in many of the same ways you can create other types of objects. But here's how arrays are different. Instead of a list of arbitrary property names, arrays used zero‑based indices, which are numbers. You can't use dot notation to access these property names, and there are a lot of specialized functions on Array.prototype which you should really learn about. So, your background in objects is a good jumping off point to understand arrays deeply, but there's still a lot to cover here. In this module, you'll learn about working with arrays in general, how to create them, modify them, and sort them. We'll also preview some advanced topics like deep cloning, maps, sets, and other typed arrays. In the next module, you'll cover array iteration in depth. One of the most common things you'll do with arrays is to loop through each element and do something. I want to make sure you're all familiar with the power Array.prototype can give you to make complex tasks doable in only one or two lines. We'll start at the beginning by focusing on how to create arrays. That's next.

Creating Arrays
In this video, we're working on our admin‑facing edit course UI. This is where we can define a course and add ContentBlocks. So, let's talk a bit about how courses are structured. Every course is an object. It contains the metadata we've talked about before, a title, an author, and an ID, but then, each course has a property called content, which will store the ContentBlocks. Since there could be anywhere from 0 to dozens of ContentBlocks in a single course, this property is a perfect opportunity to use an array. When someone clicks this ADD NEW BLOCK button, we should add a new ContentBlock to the content property. But we can't just start adding stuff using methods like push, because right now content is undefined. We first need to define content as a new array. I'll check to see if currentCourse.content is null, and then create the array here. There are a few ways to create arrays, just like there are a few ways to create normal objects. First, with the new syntax. This creates a new object that links to Array.prototype. By being linked to that prototype, this object gains access to all the array functions built into that prototype. We saw the same pattern with capital O, Objects in module three, but I want to call attention to these parentheses. Why are they here instead of just writing new Array? When we create a new object in this way, we're calling the prototype's constructor function. This is a function that lets you configure things about the creation of a new object. When we create a new array like this, we're passing in 0 arguments to the constructor function. As a result, it creates a new blank array for us. What we could do instead is to pass values into the constructor function like this. This would create a new array with three blank empty objects inside of it. Arrays can hold any type of property, so you could also do something like this with numbers, but be careful about this situation. If you only pass in one number, like this, this doesn't create a new array containing the number 4, instead it creates a new blank array with a size of 4. In other words, there are four blank slots. This doesn't prevent you from putting more than four elements into it, it just has four empty slots to start. Instead of using the new syntax, you can use the array literal syntax. Remember that our object literal syntax was empty curly braces. Array literal syntax is empty square brackets. This is the same thing as creating a new array with the new syntax. You can pass in values to the array literal syntax to create a new array with some values. But, unlike the new syntax, if you do this with just one number, it will add that number as the first value instead of making a new array with that many empty slots. You also know that you can create a new object by using Object.create, and by passing in Array.prototype, it becomes a new array. Array.of is a function which will create a new array with the contents passed into the parentheses. So it's almost exactly like the new array constructor function, except passing in one numerical value will add that value instead of setting the size. Array.from is another function to create a new array. It works with array‑like objects. An array‑like object is something that's iterable, but is not exactly an array in the sense that it doesn't link to Array.prototype. For example, a string is array‑like because you're able to use a for of loop to loop through each character in the string. So saying Array.from and then passing in the string JavaScript will actually create a new array where the first element is a J, the second element is an a, and so on. Another type of array‑like object is a NodeList or an HTMLCollection. These are the data types you get when you call a function like document.querySelectorAll to get a list of DOM elements on your web page. These behave like arrays in a lot of ways, but passing them into Array.from, you could be sure that they are fully arrays and can use all the Array.prototype functions on them. But, back to our code. I'll simply initialize the content property as a new array by using the array literal syntax. Now clicking the button causes my currentCourse.content property to be initialized as an array and a new blank ContentBlock to be pushed into it. As a result, the code which updates my page with the state of this object displays a new blank form for that ContentBlock. That does it for creating arrays. Here's a summary of all the different ways you can do that. Use the array literal syntax, create a new array using the constructor function, use Object.create, passing in Array.prototype, use Array.of, or use Array.from with an array‑like object. In the next clip, I'll show how to check whether a property actually is an array before you start to push things into it. That's next.

Identifying Arrays
In this line, we're checking whether the currentCourse.content property is null. If so, we initialize it as a new array. Then down here, we're using array functions to push content into it. But there's one possible bug here, the currentCourse.content property could be defined, that is, not null, and still not actually be an array. If so, this push function will fail. So, how can we test that a property actually is an array before trying to do array things to it? And to that point, how can we test whether any object is a certain object? In general, you could use the instanceof operator to see if an object links to a prototype. The syntax looks like this. After this line, the instanceof operator will return true because, yes, it links to Array.prototype, but it will also return true if we check whether this property is an instanceof object. That's because Array.prototype links to Object.prototype, so by extension, this property is both an array and a capital O, Object. A similar function is Object.isPrototypeOf. You start with the prototype you want to check, and then call isPrototypeOf, passing in the object you want to check. I like this one because it feels very human readable, Array.prototype.isPrototypeOf currentCourse.content. Like instanceof, this will return true for prototypes further down the prototype chain. A better and more precise way to check whether something is an array is Array.isArray. This will return true only if the object's direct prototype is Array.prototype. So instead of checking if this property is null, we can check whether it's an array. If not, which includes a situation where it's null, we'll redefine it as an array. Okay, we have created arrays and we're sure that our arrays actually are arrays. Now, we can talk about adding content to arrays, next.

Adding and Accessing Array Elements
Now that we have arrays, in this clip, I will cover how to add items to, access items in, and remove items from those arrays. While doing this, I want to introduce the mental model of stacks and queues, which may help the way you think about arrays. We've already talked about bracket syntax. When accessing properties of objects, you can either use dot syntax or bracket syntax. But when accessing items in an array, we don't use property names, instead we use indexes. An index is a number starting at 0 and increasing by 1 for each item in an array. Think about the index as the slot number. Get me the item in the zeroth slot of my array or the second slot of my array, etc. You can't use dot syntax with arrays, you must use bracket syntax, passing in the index. Like any properties, you can both get and set array elements in this way. In beginner JavaScript courses, you'll commonly see examples like this. While this does show you how to store and access elements of an array, keep in mind that you'll rarely use arrays like this, accessing an element directly by index. You'll usually add elements to the front or end of an array using specific methods, and iterate through each element in the array in sequence. When you do access an element by index, it will probably be a dynamic operation instead of a hard‑coded two or three. In the rest of this clip, I want to introduce two ways to think about arrays, as stacks and queues. JavaScript has array functions which make sense in the context of these two mental models. The most important mental model is to think about an array like a stack. Instead of visualizing it like a horizontal row, like this, visualize the array stacked on its end, with the value of 0 indexed at the bottom, sort of like a stack of papers on your desk. Stacks start out empty and when we put items into the stack, they'll go on top. So the top item is always the last one we put in. In JavaScript, you can put an item onto a stack by using the push function. Push takes as its argument the item you want to add, and it will place it in the next empty slot. If there are four items in the stack, pushing a new item will add it to the next slot. I used push in the admin UI for editing a course. When creating a new ContentBlock in a course, I wanted to add it to the end of my array of ContentBlocks. I do that by pushing a new project object with a unique ID I get from the server. It adds it to the end, regardless of how long the array is at the time. Sticking with our stack metaphor, what if you want to take an item off the stack? For that, there's a function, pop. Pop takes the last item in the array and returns it. So, keep in mind, the stack actually gets smaller as a result. If you wanted to read the last item in an array without actually removing it, you could look it up by index. Calling .length on an array will return an integer for the length of that array. But remember that this is not equal to the last index. Arrays are 0‑based, so an array of 3 items will return a length of 3, but since they're numbered 0, 1, 2, you'd actually want the element at index 2. So to get the last item's index, you just take the array length minus one. A stack is known as a last in, first out data structure. The last item you add is the first item you take out. But there's another mental model to think about arrays, as a queue. A queue is a first in, first out data structure. It's like a queue at a restaurant. The first person to arrive stands in the first position, and then future people enter at the back of the line. People are removed from the line starting with the first position and then the entire line shifts one position up. To get this effect in JavaScript, you can use the shift function. This removes and returns the first item in the array. As a result, every item further back in the array moves forward. The previous number two person becomes the number one person, and so on. So, using push will always add an item to the end of an array. Pop is used to pull an item off the end of the array, and shift is used to pull an item off the front of the array. There's one other function you can use, unshift. This is like having our line of people, but someone enters from the front. Instead of everybody getting closer to the front of the line, everybody takes a step backward. I want to mention one thing about shift and unshift. As you can see when you make a change, every person in the line has to move, so it's not as efficient as push or pop, which only affect the items at the end of the array. So you might notice that using shift and unshift is a little slower than using push and pop. What's common with all these functions is that you don't need to worry about accessing an element at a certain index, just push or shift the new value into the array. But what about accessing all elements in order? Well, we'll talk about that in depth during the next module, Array Iteration Deep Dive. In this clip, you learned how to add or remove an element to the front or the end of an array, but what about the middle? To learn about that, we need to first understand some more array methods. That's next.

Cutting Up Arrays
In the last clip, you learned about a few ways in which you can remove an element from an array, but in both cases, we either removed an element from the front or the end. What if you want to remove an element from the middle of an array? I'm back in my Admin section in the edit‑course UI, and this time I want to implement this DELETE BLOCK button. This button appears near every block, and whatever block I delete should be removed from the array. In previous modules, we learned about deleting properties by using the delete syntax. Can we use this here? Well, this would be a good way to delete the entire array of content blocks, but it wouldn't work in this situation. If we did, then we would make this slot of the array empty. It would cause all sorts of problems, because the length of the array doesn't change, and when we iterate through these items, we'll get errors accessing the content block in this slot. Instead, we need to learn about some other functions that let us cut up arrays, slice and splice. Okay, the fact that these two functions are both used for cutting up arrays and have names that are off by just one letter means you're absolutely going to get confused by them while working. Don't feel bad if you have to look this up. But, when you do get confused, just remember the meanings of these words. Splice is a word that means to unite. It's used for long things like rope or tape. For example, you can splice two lengths of rope together to make one long rope. Slice is a word that means to cut, and it's used to separate one long thing into multiple pieces. Based on the definition of splice, you might think that this function is used to make multiple arrays and combine them into a single array, but actually it's used on a single array to first remove some stuff from the middle and then slice the array back together into one. So maybe it should have been called slice and splice, but it is what it is. Use splice on the array you want to remove something from. The first argument you pass in is the index you want to start cutting from. In other words, the cut will be made so that this element is the first to be removed. Then pass in a number which represents the amount of elements you want to cut out from that place. Use 1 if you just want to remove that one item. The result of this method is that the content array will be edited so that the item at the second index only is removed. Content now has one fewer elements than it did before. In addition, the removed element is returned from this function as an array, so we could capture that like this. Keep in mind, this is an array of one item, so in order to access the value of this, you would access the 0th element of this array. You can actually use splice with additional arguments. Doing this will add elements in the place of the cut. So this code removes the item at position 2 and returns it to a new array, removedElement. It then places the item, apple, into that position. Let's compare this to slice. Slice takes in two parameters, the start and the endIndex for the cut. You can think about this like taking a slice of cake, because you need to make two cuts, where to start and where to end. Slice returns the portion of the array you sliced out, but unlike a real cake, the original array is not affected. In this example, a cut is made before the element at index 1 and before the element at index 3, then those two elements are returned to the variable. The original array is not adjusted. If the second parameter is left out, JavaScript will assume you mean the rest of the array, so this will return the entire array except for the 0th index element. You can also use negative numbers for the end position, which will mean it counts backwards from the end. So this will return all but the first and last elements of the array. Remember, splice edits the original array, but slice leaves it alone. If you want to use splice, but you don't want to edit the original array, you can swap splice with toSpliced. Use the same arguments, but this way it will return the new array without affecting the original array. Now that we've looked at these methods, what should we do in this case? We've just clicked the delete button and gotten the index of the element to delete. Do we use slice or splice? We want to use splice. The first parameter will be our delete index and the second parameter will be 1. This edits the current course.content array so that the item at the delete index is removed. And that's how to use slice and splice to edit arrays. In the next clip, we'll learn various ways to put arrays back together.

Putting Together Arrays
Let's say we had two courses, Cybersecurity pt. 1, Cybersecurity pt. 2. And we decide later, it's a little silly to have two parts. Let's just have one big Cybersecurity course. How can we combine these two courses into one? The goal here is that the content array in Part 1 has all of those elements and then also all the elements from the content block of Part 2. Then we can delete Part 2 completely and rename Part 1. As with most things in JavaScript, there are a few ways to combine arrays. First, the concat function. Concat is called on one array, passing in the other array you want to combine with. I can combine these two arrays like this. The concat method can take in as many parameters as you want. So if you wanted to combine all your courses into one mega course, you could do that like this. So the concat function works, but you actually don't need to use a function here. When the spread syntax is placed before an iterable object like this, and arrays are the number one example of an iterable object, it's like activating each property one after another in place. This one line sets part1.content to equal a new array that contains all the elements of part1.content and part2.content. To appreciate what the spread operator is doing, consider how this would work without it. This creates an array which contains two other arrays, because both the content objects are arrays. So we are left with a structure like this. This obviously won't work. When we iterate through our content array, we expect a bunch of content blocks, not two arrays of content blocks. What the spread operator does is to unpack those arrays into their individual elements. The result is exactly what we want, one array containing all the elements from the previous arrays in a single line of very readable code. By the way, this spread operator has a bunch of other uses, and this isn't the last we'll see of it. In fact, you'll see it again in the next clip on cloning arrays.

Cloning Arrays
In the last module, we talked about some challenges regarding cloning objects. Here's a quick refresher. Cloning an object is not simple because they are reference types. The simple way of cloning an object that JavaScript makes available to you is to create what we call a shallow copy. It's shallow because all primitive properties of the object are cloned, but any nested properties only have their references cloned if they're an object. As a result, two cloned objects could end up containing one or more properties, which actually point to the same object in the heap. Editing one of these objects would cause changes to the object in both places. That's usually not what you want. Arrays come with the same challenge because they're also objects. Say we had a course that we wanted to duplicate. We can use the spread operator to do that. This clones the ID, title, and content properties, but since the content property is an array, we have only cloned a property which points to the same reference. So if we think that we've successfully cloned the course and go about editing properties of the new course, we'll be editing the same object that's linked to our original course. But okay, we expect that. It would be no different than if the content property pointed to a generic object. Since we know what our core structure looks like, we could try to intelligently work around these issues. This is an improvement because now the cloned course's content array refers to a different object than the old course's content array. But it still has problems because inside each of these content arrays is some number of different objects, and each of those are just objects on the heap which are being referenced in the same way in both content arrays. You could keep going a level deeper, and depending on the complexity of your objects, it might be possible to actually deeply clone them. In our case, we know that once we get to the content array, each object inside that array only contains primitives. So we could set the cloned course.content to a blank array, then iterate through the old course.content using the spread operator to push new copies of each object inside. And this actually does work in our case. Finally, every property and sub‑object of the course actually points to a new object on the heap. But I'm sure that you can appreciate that if our ContentBlock objects contained their own sub‑objects or their own arrays, this could get very complex very quickly. So I'm once again saying that a full discussion of deep copying is outside the scope of this course. But there's one other technique I want to show you, and this takes advantage of the built‑in JSON utility. There are two functions, JSON.stringify, which converts a JavaScript object into JSON, and JSON.parse, which converts JSON back into a JavaScript object. The key is that during the conversion from a JavaScript object into JSON, every property is serialized into plain text. And as a result, it loses its reference to the objects on the heap. So you can use JSON.stringify on the object and then JSON.parse on the result of that function. What you get is a way to do something similar to what we had before, except it's all in one line. Do keep in mind with this approach that there's no link to any prototype besides Object.prototype. When we parse JSON using JSON.parse, we get objects that link to Object.prototype, you'll have to do some additional work if you want to link these objects to different prototypes. But for this LMS, that works just fine because we already know we're using JSON to receive data from the database. So I've already made functions which parse a JSON course that's in the expected structure, and return an object that links to my course prototype, and a contents array that contains objects that link to my ContentBlock prototype. But depending on your situation, this might introduce a whole new set of headaches to deal with. In this clip, we did our best to solve the problem of copying objects and arrays with some moderate success. In the next clip, we'll focus on something we can solve definitively, sorting arrays.

Sorting Arrays
This is the student notebook with its list of content blocks that have been saved by the student. Behind the scenes, there's an array calledNotebookContentBlocks, which stores the blocks that appear on this page. We get the list of content blocks directly from the server, populate this array, and then render the content blocks in the order they appear in the array. But what if I want some control over this order? In this clip, I'll introduce a few ways you can control the order of arrays. The first method is the simplest, and it's probably too simple for what you need, but hey, maybe it's exactly what you need. That's the reverse function. It will reverse the order, and that's it. When you call this function on an array, it actually changes the order of that array. If instead you would like to create a new array for the reverse version and keep the original array the way it is, you could use the toReversed function. But that's not why you're here. The really powerful function to handle arrays sorting is called, appropriately, sort. The sort function takes in as its argument another comparison function. That comparison function itself has a highly defined structure that makes all of this work. Let's dub out a simple example. You could either do this as an arrow function and create the function inline, or by defining the sort function as a separate function. To really understand how to use the sort function, you must understand what's expected of this comparison function you pass into it. There must be two arguments passed into the function. We already took care of that here. By convention a and b are used, but you can name them whatever. Within the function body, you're going to compare a to b. Here imagine that a and b are two random elements in the array, so we can think about them as content blocks. The purpose of this function, or what it's trying to answer is under what circumstances should a be sorted above b, and when should b be sorted above a? We answer that question by returning a positive or negative number. By convention, 1, ‑1, or 0, but any number will do. If we return 1, that means a should be sorted higher. If we return ‑1, that means b should be sorted higher. And a 0 means they're equal. Let's do a simple example. We'll sort this alphabetically based on the title property of the content block. Since JavaScript looks at strings that come later in alphabetical order as being larger than one that comes earlier, we can write code like this. If a's title is smaller than b's title, that means b is further in alphabetical order than a. In that case, we need to return a positive number because a should be sorted first; otherwise, return a negative number because b should be sorted first, if neither return 0. It's a requirement that this comparison function returns some sort of numerical value for all possible conditions. By applying this, we can see that the notebook array is now sorted in alphabetical order by title. A shorthand for this function is to just return a.title ‑ b.title. When b is larger than a, a negative number is returned. Otherwise, a positive number is returned. I personally avoid this kind of thing in my code because it's difficult to understand at first glance. I'm more concerned about writing code that's clearly understood by coworkers and myself in the future than I am with writing the tersest possible expressions. But hey, this does work. Let's try one other comparison function. Let's sort by length of the description field from longest to shortest. The first decision is in what circumstance will I return 1, which means I want a to appear first. Well, since we're going from longest to shortest, if a.description.length is greater than b.description.length, then I want to return 1, and then I can just do the opposite when I return ‑1. And now content blocks are sorted by the length of their description field, from longest to shortest. Like reverse, there's also a function toSorted, which operates the same way as sort, but does not change the underlying array. And that's how to sort arrays. We're nearly done with our tour through arrays. Sparse arrays are next.

Sparse Arrays
Earlier this module, we talked about deleting an array element. For example, to remove the element at index 2 in an array, you should use splice. You should not use the delete operator to delete an element. The reason is that it creates what's called a sparse array. A sparse array is an array with empty indexes. The amount of elements it contains is less than the value returned by its length property. You can get a sparse array in a few ways. By deleting an element from an array. This deletes the content, but leaves the empty slot. By initializing an array with a particular length, but not filling it. By adding an item to an index that's greater than its length. The issue with sparse arrays is that array functions don't always handle sparse arrays the same way. Some encounter the empty slots and treat them as undefined objects, and some just skip right over them. But the bigger issue is one of data consistency. Arrays are at their most powerful when each element contains the same or similar data. How would you sort an array when some elements might be undefined? You now have to protect against empty elements when writing code that iterates through your arrays. Try to avoid creating sparse arrays whenever possible by sticking to the methods of adding to arrays introduced in this module. Instead of assuming what the next index of an arrays should be and directly adding a new element by index, just use the push or unshift function. Instead of setting the length of an array during an array creation, understand that in JavaScript arrays are dynamic and setting the length won't prevent anyone from adding more elements into that array. As long as you're mindful about when an array can become sparse and take reasonable steps to avoid it, you should be fine. In the next video, we'll finish up our tour of JavaScript arrays by introducing some other array‑like types you should know about.

Maps, Sets, and Typed Arrays
Arrays are undoubtedly the most well known and useful collection type in JavaScript. But they're not the only ones. In this clip, I want to briefly introduce three other collection types in JavaScript: maps, sets, and typed arrays. To understand what these are, let's refresh what we know about arrays. An array is a collection type which is comprised of keys and values and can be ordered in any way. Keys are limited to zero‑indexed numbers. Values can be any primitive or reference type. That's an array. So what's a map? A map is a collection type which is comprised of keys and values and are ordered in the order they were inserted. Keys can be any primitive or reference type, and values can be any primitive or reference type. So, two major differences for a map. Keys can be any primitive or reference type. The same sort of things that can be values in an array can be a key in a map, and the order is constrained to the order the items were put into the map. So I could define, for example, a map to keep track of a user's course completion times. As a course is completed, it can be added to the map by using the set function. So not only are actual objects being used as the keys here, the order that those objects are inserted is kept track of. That's a map. What about a set? A set is a collection type which is comprised of values only, which must be unique, and are ordered in the order they were inserted. Values can be any primitive or reference type. So the most significant thing about sets is that they don't have keys. They are still ordered by the order they were inserted into the set, but you typically would not use a set if you just want to look up by an index. Instead, a set is used to store unique values. In fact, if you try to add an item to a set by using the add function, it will fail and return false. And finally, typed arrays. A typed array is a collection type which is comprised of keys and values and can be ordered in any way. Keys are limited to 0 index numbers, and values must be in the specified format. Typed arrays are used for situations where performance is extremely important, such as web assembly. As a result, I'm not even going to talk about them here. You should just know that when you see options like Int8Array or Uint32Array, or Float64Array, these are typed arrays. That does it for our overview of arrays. The next module is all about iterating through arrays. I'll see you there.

Array Iteration Deep Dive
Introduction to Array Iteration
I used to have a bad habit. A few years ago, I learned about a function called for each that I could use on arrays. The thing about for each is that it can do just about anything you want. It does what it says, for each element in this array, do something. The reason this is a bad habit is when there's a solution for my problems that works pretty well, and I already know it, it's easy to lose the motivation to find a solution that works very well. And there are a lot of these solutions on array.prototype, some of which could have done the same things I use for each to achieve, but in a much more streamlined and efficient way. This module is called Array Iteration Deep Dive. We're going to look at basic loops, yes, but we're also going to look at all the other functions that let you iterate through an array and do something. Functions like reduce, every, filter, find, and the very powerful map. If you've been avoiding learning about these functions because a for loop is good enough, my hope is that this module will be eye opening for you. We'll start at the beginning with basic loops next.

For Loops
One of the very first programming concepts you probably learned is the for loop. In JavaScript, a four loop has a syntax like this. First, you initialize some number. Then, you specify the conditions that the loop should run. Then you say what should happen to the number every loop. So, to iterate through an array, you might do something like this. I, or the index, starts at 0. We want to continue looping so long as i is less than the array's length. Remember, the largest index in an array is one less than the length of the array. So we don't ever want i to equal the array.length. And then we want i to increase by one each time, i++. With this index i, which increases between every valid index of the array, you can access elements of the array and do any iteration logic between the curly brackets. There are two additional tools you can use within a for loop, continue and break. Continue is a signal that you're done with the current iteration and want to move on to the next one. Normally, all the code from top to bottom will evaluate fore iteration, but, for example, if you knew you didn't care about a particular iteration, you could use continue to signal you want to move on. If this element is undefined, skip past all the other logic and move on to the next iteration. Break will cause the entire loop to stop running. So if, for example, you are looking for a particular element and find it, you can use break. The thing about for loops is they work. Just about any of the iteration tasks you need to do can be done with a for loop. But it's not a great choice for array iteration for a few reasons. There's a lot of boilerplate code. You have to describe how array iteration itself should work each time instead of being able to just focus on the iteration logic. It's very easy to make an off‑by‑one error. This code will work, but if you get a detail wrong, you end up skipping an element or looking up an index that doesn't exist. It's a little difficult to read. For loops are a great general purpose looping tool, but when what you want to do is just loop through all the values of an array, this code is an overly verbose way to say that. There are two types of loops that improve on this ,for... in loops andfor... of loops. These both replace the hard‑coding of array iteration logic into a more simple syntax. We saw thefor... in loop. When talking about objects. What it does is loop over all enumerable own or inherited properties of an object. For an array, the elements are enumerable properties, so this has the same effect of looping through every element. But I suggest not using this for arrays because if you define properties on the prototype, it would return those properties as elements in the loop. Afor... of loop is a better fit for array iteration because it loops over an iterable object instead of enumerable properties of an object. That gives us our array elements without possibly including enumerable properties. So, we'll stick with thefor... of loop. But what about getting direct access to the index when looping? For example, with a for loop, I can do this. This will populate every element of the array with element 1, element 2,etc., and it can do this because I have access to the index with this i variable. Well, you can also do that with afor... of loop. You just need to change a syntax to this. Now the element itself is bound to the value variable, and the array index is bound to the key variable. Also,for... of loops can use continue and break just like for loops. So, forof... loops are looking pretty good. The only negative thing I have to say about them is that they don't have special handling for sparse arrays. If one of your arrays might be sparse, you have to make sure that each element is not undefined in order to safely iterate over it. But there's an even better option, forEach. Since forEach is defined on array.prototype, it's called directly on the array ForEach uses a function parameter like the sort function we saw in the last module. The inner function passes in a parameter for the element which you can name whatever you want. But what if you need access to the index? You can pass in multiple parameters to this function, so instead of just passing in this element, you can pass in the element and the index. The great thing about forEach is that it handles sparse arrays well. It will skip right over any undefined elements in an array. The negative thing is that there's no handling for break or continue. Another good thing about it that you might not appreciate at this point is that it works well using the functional paradigm. So it's going to work very well with the other functions you'll learn in this module. Okay, so forEach is the best way to do array iteration and, like a normal loop, is capable of doing just about any task you want it to do. So why isn't this module over? Well, by the end of this module, I hope to convince you that even though forEach will work for most tasks, there's almost always a better array function out there. In fact, by the time I refactored my LMS code, I ended up replacing almost every instance of forEach with a different function, and I ended up with much more readable code. Let's start down that path by exploring how to summarize arrays next.

Summarizing Arrays
In this clip, we'll see how to take an array and summarize something about it by reducing it down to a single value. I'll look at five functions in this clip, join, some, every, reduce, and reduceRight. Join is a pretty simple one. When you call join, you're calling toString on every element in the array. What's toString? It's actually one of the only functions that's defined on Object.prototype, so every object has access to it. It does what it says, it explains how to render an object as a string. But if you log out an object normally, you get the very unhelpful object Object output. So, you could always implement toString on your own object prototype to better explain how this object should appear as a string. For example, I could implement toString on my ContentBlock prototype to return something a little bit more informative. So, join calls toString on each element in the array, returning one long string. In addition, you can pass in a separator string as an argument. With my previous definition of toString, calling join and passing in a comma and a space will return a nicely formatted string to define my course's content. Next is two similar functions, some and every. Both of these will return a Boolean if elements in the array match a certain condition. Some returns true if the array contains some, that is at least one element that matches the condition, and every returns true if every element matches the condition. Like filter, both of these functions take in another function to describe the behavior you want to match for. Pass in a parameter representing the element, and then a function body that returns either true or false. So, this code will return true if at least one block in a course has been bookmarked. This one will return true only if every block in the course is bookmarked. But the ultimate summarizing function is reduce. This is a very useful way to calculate some sort of a number based on your array. For example, give me the total price of all the products in my cart. Think about how you would make this calculation yourself using a calculator. First, you'd identify the value you need to look at, product.price. You'd look at the first price, entering it into your calculator. Then, you'd perform the first calculation between the first and second price. Your calculator now shows the subtotal. Then, you'd go on to the third price, performing that calculation on the result currently in the calculator. You'd continue this until you get to the last number. In this example, your calculator can be described as an accumulator. After three products, it contains the subtotal of those three products so far. It's accumulating the total as you work. Like other array functions, the reduce function takes in a function of its own to define its behavior, and that function needs at least two arguments. The first is the accumulator. Like our calculator, this is a variable that will hold the result of the calculation so far. So it starts out as the first value in the array and increases with each iteration. The next is the current value, or the array element that's currently being looked at. The function body describes what to do during each iteration. We've got a reference to the value, product.price, that we want to add up. We do that by adding this value to the accumulator. Then the function can return that value. If you need the current index of the element, you can pass in the third argument into this function. Another thing you might need to do is set the initial accumulator value. If it's not set, reduce uses the first value in the array as the accumulator value, but in some cases, you'll want to set it to something else. For example, say your shopping cart gives customers free shipping if they have at least $25 of products in their cart. You could define a reduce function like this. The accumulator begins at 25, subtracts the current price for each iteration, and then returns the value. So, that's reduce. What about reduceRight? Well, everything you know about reduce applies to reduceRight. The difference is that the array is traversed in the opposite order. The accumulator is set to the last element in the array, or some other value if that's set. And then a calculation is performed on the accumulator and the second to last element in the array. In this clip, we talked about join, some, every, reduce, and reduceRight. In the next clip, we'll continue exploring array functions by seeing the various ways you can search through an array.

Searching through Arrays
In this clip, we'll look at five more functions, includes, find, findIndex, findLastIndex, and filter. What all of these have in common is that they help you search through the content of an array, either for one specific element or for any elements that match some criteria, and then return those matches. Includes is a function that has a nice human‑readable syntax. Array includes element. It returns true if the element is in the array and false if not. By now, you're a pro with primitive versus reference types, so you know that if you pass in an object, you'll only return true if the array contains the exact same reference. In other words, passing in a new object literal into this function will never return true, even if you construct an object which contains the same keys and values as some other object in the array. But if you define the element with a named reference, then check for that reference. You will get a true response. Includes can take in a second parameter, which is the index from which to begin searching. This will only return true if the new block appears in the array in index 3 or beyond. Now, this does only return a true or a false. It might be that you want to get the element itself. For that, you need to use the find function. The find function takes in a function which contains a reference to the element you are checking. So, it will run this function on each element in the array and return the first element, which returns true for the condition you set. In my API code, I have a function to look up a ContentBlock by ID, and I do it like this. I'm looking for a block within this array whose ID property matches the ID I pass into the function. If nothing is found, the function returns undefined. Keep in mind that this function will stop looking once a matching entry is found. So if you try to use a criteria in your function which could match multiple items, only the first result will be returned. If you want all the results that match the criteria, I'll be shortly introducing the filter function, but I want to show you two variations, findIndex and findLastIndex. These return not the result itself, but the index of the result within the array. I don't think it would surprise you to hear that findIndex returns the index of the first result and findLastIndex returns the index of the last result of the array. And now filter. The structure of filter's inner function is the same as the structure of find, but instead of returning the first matching element, it creates a shallow copy array with all matching elements. This code returns an array containing all blocks whose bookmarked value is set to true and adds it into an array called bookmarked blocks. Even if only one item is returned, it will be included in an array. So that covers five more array functions. In the next clip, you'll learn one more, and also how to bring everything together with a new way to approach array functions.

Map and Functional JavaScript
The last function you'll learn in this module and in this course is map. I want you to compare some of the array functions we've covered so far. ForEach, filter, sort, some, every, reduce, all of these functions take in as an argument a function and either return a shallow copy of an array or some other value. Each of these functions are useful by themselves, but they start to get really powerful and even elegant when you chain them. One last visit to our LMS Notebook UI, and you'll notice something different about the code, which takes the array of JSON content blocks and renders them to the DOM. If you haven't seen this syntax before, this is called chaining functions. It works because of the way JavaScript handles whitespace and also because the output of all these functions is an array. First, we have our jsonBlocks as we receive them from the API. On that, we call map, passing in parseContentBlockJsonAsContentBlock. Okay, we don't know what map is doing yet, but this somehow is parsing our JSON as content blocks and applying the correct prototype. Then, the result of that function, which is also an array, is passed into filter. Filter uses this filterByBookmarked function. The result of that is passed into sort, which is using this sortByTitleAlphabeticallyDescending function. I bet you can guess what that does. Next, the result of that function is passed into map again using the generateNotebookHTMLForContentBlock function. And finally, the result of that is passed into map appendToNotebookDOM. If you're still confused about the syntax, it might be easier to imagine this as one long line. JsonBlocks.map returns a result, which filter is called on, and then sort is called on the result of that, and so on. It works because at all times the value being passed between functions is an array. I show this to you because there's no time to fully explore the ideas behind functional programming and to try to convince you of its value, and it's not the purpose of this course. But if you're like me, you see the code like this, you see how easy it is to understand and reason about, and you don't need any more convincing. This is a cool way to write code, and the map function is key. What the map function does is to take an array and apply a function to every element in the array, returning an array with the results. I use map in three places here. First, parseContentBlockJsonAsContentBlock. I'm applying this to an array, but the function uses singular nouns because the function itself is only responsible for parsing one block at a time. That function looks like this. And we talked about this in detail in module 4. It makes a new object linked to the contentBlockPrototype, then applies the properties from the JSON object to that object and returns it. So at this point, we have an array of proper content blocks, then that goes into our filter function, which only returns blocks that have a bookmarked property set to true. We talked about filtering in module 5. The array of content blocks that pass that test now arrive at the sort function, which we also described in module 5. The content blocks are now filtered and sorted and now enter another map function. This time this function generates an array of document fragments that use the template element I have defined on the page. That array of document fragments now enters another map function, which appends each of those fragments to a particular element on my page. So, that's map. Even though I can explain what it does pretty simply, I hope it's useful to see how it can be used as part of functional programming patterns in JavaScript. To learn more about this way of writing code, check out the Functional Concepts in JavaScript course on Pluralsight. And you'll have time to do that soon because in the next clip, I'll summarize what you've learned in this course, and we'll finish up. See you there!

Course Summary
In this course, we explored objects and arrays in depth. We covered a lot, so let's summarize it all here. First, we learned what objects were and how to create them using things like the object literal syntax, the new syntax, and Object.create. Then we talked about prototypes, which give objects their unique functionality. We learned about Object.prototype and how to make our own prototypes. We also learned about the prototype chain. Then we did a deep dive on object properties, how to create them, access them, and delete them. We learned about protecting them by modifying property attributes or Object.freeze, and enumerating them by using the for... in syntax. Next, we discussed objects being reference types and how that changes the way you work with them, including challenges related to comparing and cloning objects. We also talked about functions and properties, some topics related to scope, and primitive wrappers. Then we moved into the arrays section of the course with how to create arrays and test whether a certain thing was an array. We learned how to add and access array elements, cut array elements up using splice and slice, combine arrays using the concat function and the spread operator, and how to clone and sort arrays. We briefly looked at sparse arrays and other types in JavaScript which behave somewhat like arrays. And finally, we did our array iteration deep dive, learning about a number of ways to go through each element in an array and do something. This culminated in our discussion of map and functional JavaScript patterns, which I encourage you to learn more about. I want to thank you for completing this course with me, and good luck with your continued development journey!