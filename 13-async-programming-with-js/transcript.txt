Course Overview
Course Overview
Hello, everyone. My name is Nate Taylor, and welcome to my course, Asynchronous Programming in JavaScript. I am a director of engineering at Pluralsight. JavaScript promises are a powerful solution to working with asynchronous programming. However, they can also be intimidating to learn, but they don't have to be. This course is designed to cover everything you need to know to begin working with promises and async/await in JavaScript. Some of the major topics that we will cover include asynchronous programming, consuming and queuing promises, creating promises, and using async/await. By the end of this course, you'll know how to work with promise‑based libraries, as well as how to use async/await in your code. Before beginning this course, you should be familiar with basic JavaScript syntax. I hope you'll join me on this journey to learn async coding with the Asynchronous Programming in JavaScript course, at Pluralsight.

Understanding Promises
Understanding Promises
Newcomers to JavaScript often struggle with its asynchronous nature, especially if they're coming from another programming language that doesn't use callbacks. And that struggle is intensified when new users here about promises because they're told that promises make things better. But at first blush, promises aren't trivial. Before digging into how promises can help simplify code, let's take a minute to look at a fairly common problem, that is fetching data, and how the fact that it's asynchronous throws a wrench into the system. The code you see on the screen makes two separate HTTP requests. The first is to get order statuses, and the second is to get a list of orders. Now this block of code might not be something you see every day, so let's take a second to walk through some of the high points. It starts by creating a new XMLHttpRequest. This object allows us to make requests against an API. It specifies the path of the request in the open function, in this case, specifically, localhost:3000/api/orderStatuses. It then has an onload function that you can kind of think of as a success function. That is when the HTTP call returns successfully, it will call the code inside this onload function. And finally, it has a send function. Looking at this code now, when is the API request actually made? It's not made until the line xhr.send. That is, there's a lot of setup before the request is actually sent. The second xhr request is similar except that it hits the orders endpoint. Let's look at what happens when xhr2 is successful. When the xhr2 call succeeds, it calls the code inside of the xhr2.onload function. Inside this code, it parses the response and then looks up the order statuses for the orders from the list of statuses provided by the first xhr. Switching over to the browser, I can run the code you just saw. When I browse to the my orders page, you can see that this page is empty. If I head over to dev tools, you'll see an error, specifically Cannot read properties of undefined. And that's a pretty frustrating error, but what caused it? Take a look at the network pane above the console. What do you see? Do you notice how the orders request came back before the order status request? This is ultimately what produced that undefined result. Before we go back to the code, do you have an idea on why this situation would produce an undefined result? Feel free to pause the video to think about it. Now that we're back looking at the code, look again at the function. Specifically, look at xhr2.onload. Do you see that line statuses.find? That line attempts to look up the status for the given order based on its ID. But if the orderStatus's call returns after the orders call, then that list is going to be empty, and this is what ultimately produces the undefined response in our application. Code like this isn't unusual when people first learn JavaScript. Most of us have written code like this and seen it fail just like this. We can fix this code so that the correct value returns and displays in our results area. All we have to do is move a little bit of code around, and we'll see what code we have to move and where it has to go next.

Solving the Race Condition
Because of things like network latency and server performance, interacting with an API can lead to uncertainty. In the previous clip, we weren't sure we actually had the data we needed when we needed it. In this clip, we'll see a technique we can use to ensure that we have all of the data before we need it. By navigating again to the my orders page, you can see on the screen that this time the order status is defined. And if you go to dev tools, you'll notice that in the console window, the order status call completed before the orders call. And if you remember from the last clip, the order that those were returned in was very important. So, what happened? Did we just get lucky on this page, or is there something in the code that ensures the correct API calls happen in the correct order? You've likely guessed that the code had to be changed in order to ensure the correct sequence, but how? Take a look at the code on the screen. Hopefully, you recognize a lot of this code from the previous clip. Once again, we have an xhr that's fetching order statuses and a second xhr that's fetching orders. There's a slight difference though. Do you see it? It's that our xhr2 is defined inside the xhr.onload function. And what is that onload function? It's the function that gets called when our request succeeds. So in this code block, we don't even try to make the request for our order unless and until we have the data for our order statuses. However, it comes at a cost. Now our second call is buried inside the success of our first call. And what problems could be caused by nesting functions in this manner? In the next clip, I'll tell you about two problems that you can run into if you nest your code this way.

Problems with Callback Pyramid
As we saw in the last clip, one way to solve the race condition problem is to use callbacks and functions inside of functions. While solving one problem, we've introduced another problem, and that is the callback pyramid of doom. According to Wikipedia, a callback pyramid of doom is a common problem that arises when a program uses many levels of nested indentation to control access to a function. But why is this called the callback pyramid of doom? Well, let's start by looking at a simplified example. This is the type of code that you might see in JavaScript when you need to make sure that A runs before B and B runs before C and C runs before D. But it's also an example of code that could be called a pyramid of doom, and it gets its name from the indentation on the left. If I was to rotate the code or if you tilt your head just right, it looks a bit like a pyramid. But what makes this a pyramid of doom and not a pyramid of awesomeness or even just a pyramid? That is, why is it bad? The first reason is that the pyramid can hide bugs. Let's revisit code from earlier in the module with a slight tweak. This time, instead of just getting two pieces of data from the API, it's getting four, and each one is nested inside the previous one. There's a lot going on here. Even though most of it is similar, you still need to process what's happening every time you read it. And in fact, there is actually a bug in this code. Have you found it yet? Inside the xhr3.onload function, instead of parsing the results that come back, you're actually parsing the results that came back on xhr2. It's a simple mistake to be sure, and it's one that when you see it in your code, you're likely to chide yourself for being so careless. But it's also a common mistake. In fact, in preparation for this course, I did this exact thing in some of the code samples. Don't worry though. I've fixed it, so you won't be seeing this error again in the course. Another problem with pyramiding code like this is how do you handle errors? In the previous example, if xhr3 returned a 500 error from the server, then xhr4 wouldn't be called, and the onerror function of xhr3 would be called. But it's all inside of an onload or xhr2, so what should happen? Well, if you said you should handle the onerror case, you'd be right. But that can make your code even messier now because now with the code on the screen, you have a lot more code in your onload functions and you're making the first problem even worse. Additionally, your handling errors inside of success functions which can lead to another series of messy decisions and how you write your code. So, how can we solve this problem without introducing a new problem? How can we write code so that it executes in the order we want without massive nesting functions? We'll learn how next.

Solving the Callback Pyramid
As we've seen, nesting callbacks can lead to messy code. How can we get the benefits of nesting without the messiness of nesting? Well, the answer, as you might have guessed, is promises. But what is a promise? According to Mozilla, a promise is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value. Right off the bat, we see that it's an object that helps with an asynchronous operation. That's great news for us because all of those xhr calls that we were using, they're all asynchronous operations. So, it's promising to help with things like that. It also tells us that it represents the eventual completion. Similar to the xhr.onload function, promises don't always have to execute instantly. But a promise is telling you that when it does complete, you'll be able to work with its value. Another way to think of it is that promises allow developers to write asynchronous code in a more clear and less error‑prone manner, and that was a big part of my motivation when I first learned promises. Even though the concepts were not intuitive at first, I persisted because I wanted my JavaScript code to be more readable. A promise object can have three states. The first is pending. This is the initial state. When you first create a promise, it's in the pending state. Since we're talking a lot about API calls, while the call is happening, the promise is pending. If you remember that order statuses call that took 1.5 seconds to respond, a promise would be in the pending state for the entire 1.5 seconds. The next state is fulfilled. And a promise moves from the pending to the fulfilled state when the asynchronous call has completed successfully. When a promise is fulfilled, it will return a single value, for example a specific order from an API. The final state is rejected, and a promise moves from pending to rejected when the asynchronous call has failed. When a promise is rejected, it will return a reason why it was rejected. Similar to the catch function of a try catch block. There's a couple other terms you might hear with promises. You might hear someone say that a promise is settled or resolved. Both of these are referring to the same state. Whenever someone says that a promise is settled or resolved, they mean that the promise is now in either the fulfilled or rejected state. That is, it means that a promise is no longer pending. Before continuing on, let's take a quick sidebar to talk about the work of promise. If you're coming to JavaScript from another language, you might already be familiar with a concept called promises. In some languages, these promises are a term used for lazy evaluation of code. Let's take a quick look at some pseudo code here. In this snippet, the first line starts to construct a query on a users table. Inside this function could be lots of other operations on that user table, but the query doesn't get executed against the database until that last line, that .Count line. This code is lazily evaluated. It's not executed until it's needed. In this case, it's not needed until we try to get the count. JavaScript promises are not lazily evaluated. Once a promise is kicked off, it's executing. It's in that pending state. Even if the value that it returns isn't used until later, the query will be performed. Okay, with that sidebar out of the way, let's resume our discussion of promises. At this point, you're probably ready to start seeing them in practice, and there's one quick step we need to do first. And I'll walk you through that next.

Setting up the Sample Project
Are you starting to see the types of problems that promises are trying to address? Are you ready to get into some code and see what's actually going on? Great. Let's take a minute or two to make sure that we're all on the same page with the sample project. For this course, we'll be accessing an API used by Carved Rock Fitness. They're an online sporting goods retailer, and their API allows them to create, track, and ship orders out to their customers. Their API consists of a few key objects. There's addresses, products or items, orders, users, as well as a couple of metadata entries such as item categories and order statuses. This is but a small part of their API, but using these entities, we'll be able to check on the status of an order or determine where the order has been shipped to. In order to run the API, we first need to get the code. Start by cloning the GitHub repo for this project, and you can see that it's located at ps‑javascript‑asynchronous‑programming. While you're on the GitHub page, expand the list of branches. In addition to the main branch, there are other branches that tie directly to modules in this course. Each branch has the completed code for that module. That is what the code should look like once the module is done. This allows you to have a bit of a safety net. You can try the code out. And if something doesn't go right, you can check out the module's branch and have the completed code. Now that you've cloned the code, go ahead and open it up in your IDE. I'll be using VS Code, but any IDE that you're familiar with will work. Make sure you're on the main branch. There's a couple of things to notice in this project. First, this project is built on top of JSON server. This gives us the ability to run an API locally without needing to set up a database. The data is located in the data/db.json file. Since JSON server is an external dependency, you will need to run npm install before the project will work. Next, notice that there's a public directory. This directory has a couple of folders, css and src. And we won't need to mess with these. These are files that are referenced from our web page, but you won't need to edit any of them. If you want to, feel free to look around. But for the most part, there's just other libraries and helper files Then notice that there are two HTML files. These are index and orders. These correspond to the main page of Carved Rock Fitness and the my orders page. Much like the css and src directories, these files will not need modification during our course. Where we will spend most of our time in this course is the orders.js file. This file is included in orders.html, and it holds the logic to fetch the data from our API and display it on the screen. Now that we did a quick walkthrough, are you ready to start seeing how promises can help solve some of the issues that we've talked about? In the next module, we'll jump right into consuming promises.

Consuming Promises
Consuming Promises
Now that you've seen a glimpse of why you'd want to use promises, it's time to start seeing promises in action. For most JavaScript developers, the first time they'll encounter promises is when they consume another library. An example of this is one of the most popular HTTP request libraries, Axios. At the time of this recording, it was averaging 36 million downloads a week. This library is an abstraction on top of the XMLHttpRequest calls you saw in the last module. One of the key abstractions is that it is promised‑based. That is, you can't use Axios without using promises. To see this in action, inside of your IDE, open up the orders.js file. And if there's anything in there, you can clear that out and start with a blank slate. Then add this following line, axios.get with our URL. A quick side note here. In the last module I mentioned that there were some helper files in the public/src folder. One of those is the Axios library. It's referenced in our HTML file, and that's why you have Axios here without importing it or installing it using npm install. Then, if you run the command npm run start, this will launch the web server so you can see your code in action. When you go to the browser, make sure that your console window is open and the Network tab is visible. Then navigate to localhost:3000/myOrders. Notice it looks a lot like the app did when it had a race condition in the last module. But if you have xhr logging turned on, you'll see a request to orders was made. This shows us that Axios did indeed make a request for us. A quick sidebar here. This is an example of what I meant earlier when I said that promises were eager. As soon as we issued the get command on Axios, it made the request. It didn't wait around for us to do anything with the data that it returned. Since we know a request is being made and it's returning a successful result according to our xhr window, why isn't there any data showing up on the screen? Before we get to the code, remember that earlier we talked about how a promise can have three states, pending, fulfilled, and rejected. In our case, it's in the pending state until the server sends us data back. It's then up to us to handle that data. In this case, we want to handle the fulfilled state. That is, we want to make sure that when the request succeeds we can access the data. To do that, we use a function named then. It's important to note that then is a promise function and not an Axios function. That is, every time a promise is fulfilled and you want to handle that case, you'll use the then function. Then is a function that takes one parameter, and that parameter is also a function. The inside of that function will only get called when the promise succeeds. In some ways, it's similar to the xhr.onload function that we saw earlier. This is where we would place our code that we want to be executed once our promise is fulfilled. Returning to our code in orders.js, it's time to add a then function to our command. And as I just said, inside of that then function is how we'll handle the data that comes back. To do that, we're going to call a helper function, showOrderList, and we're going to give it an HTML ID of order‑list, and we're going to pass in the data. Before we execute this and look at it in the browser, let's do a very brief walkthrough. Inside of the function passed into then, we're destructuring the result that is passed it back. That is Axios passes back an object that has a lot of information in it, including a property named data that has the data returned from the API. The other information it sends back includes things like HTTP headers, the status, the request, all that kind of stuff. It's good information, but it's not what we care about. So we're passing that destructured data to a function, showOrderList. This is another one of those helper functions that is in the public src folder that was discussed in the last module. That function creates the HTML for the data that we passed in. Switching back to the browser, if you refresh the page, you'll see that the Orders table has data in it. And just like that, you've consumed your first promise. Let's review the code that made this happen once more really quickly. This function is the essence of a promise. It starts by calling an asynchronous function. In this case, it's an HTTP GET request. Next, it chains a then function onto that request. Essentially it's saying, after the get completes, run this function next. Remember, part of the definition of a promise is that it handles the eventual completion of an asynchronous call. We're not concerned about when the then call happens, but we know it happens after the get call succeeds. That works great when everything works. But what happens when your API request fails? You'll see how to handle errors next.

Handling Errors with Promises
There are countless ways for any asynchronous function to error. Even in our case with HTTP requests, you can get a 404 or a server error or a handful of other status codes that indicate that the call was unsuccessful. Let's see how to handle those. Let's hop back into the IDE and specifically in our orders.js file. In order to see how to handle errors, let's slightly tweak our then function. In the last clip, I told you that Axios returns a lot more information than the data from the API. It also includes the HTTP headers, status codes, etc. So, let's change from destructuring the object and just have a single result parameter that will have the entire Axios result object. And then we'll need to change from data to result.data. Next, let's examine the result status code. This is the HTTP status code of the request. With HTTP status codes, a 200 is a success. So, we'll use simplified logic that anything that's not a 200 is an error. In this case, if it's success, we'll show the order list. And if it fails, we'll show an error. Now, let's force our request to be unsuccessful by requesting an order that doesn't exist. So go to your URL and add /999. With all that done, return to the browser and reload the orders page. Once again, make sure that your console is open as you browse to localhost:3000/myOrders. You'll notice that once again our orders list is empty. The screen just has the Orders header and nothing else. And in your console, you have two errors. The first is that the orders/999 is not found. And the second is an uncaught error in a promise. The first error is expected. We're trying to get a record that we knew didn't exist, so we should expect that 404. But the second is unexpected. What does uncaught in promise mean? Remember that a promise can have three states. The promise is in a pending state until the API returns something. And in the last clip, we dealt with that middle state, the fulfilled state. But this time, the promise didn't succeed. So now we have to deal with a rejected state. And just like fulfilled has its own function that gets called, the rejected state does as well. Instead of using then to handle the rejected state, we need to use catch. And just as I said when dealing with the fulfilled state, it's important to note that catch is a promise function and not an Axios function. That is, every time a promise is rejected and you want to handle that case, you'll use the catch function. And just like then, the catch function only takes a single parameter, and it's a function, and that's the information that the promise sends. It could be an object or a string or whatever the promise wants to send back. So let's set our code back to what it was in the beginning. We'll still keep the URL that returns a 404. And in this case, that's orders/999. Just like we did with our then function, let's chain a catch function. All we want to do is display that error, so we'll still call the showError function. Save that file and go back to the My Orders page and refresh This time, under the Orders heading, is a message that says there was an error and that the request failed with a 404. Additionally, when you look at your console, you should still see an error that the get request returned a 404. But you should not see an uncaught in promise error because now you've handled the error case of your promise. Briefly return to your code. Notice that inside the catch, all we're doing is displaying the error. That's for demonstration purposes. If this was a real application, you might take other actions here. What you do inside your catch block is dependent upon the use case of your particular application. Additionally, what data the error or reason contains is up to the library that you're consuming. Now that we've seen how errors work, let's put the URL back to one that returns data. If you were to refresh the My Orders page right now, you'd see the order data once again. Or, more correctly, you would see some of the order data. The order status information is blank. How can we make sure to fill that information out? I'll show you how you can use multiple promises to get the data you need in the next clip.

Chaining Promises
So far, you've seen the simple case of making a single asynchronous call and handling it, success or failure. But let's be honest. You probably didn't need promises for that. You've been doing that on your own for a while now. So how can promises help ensure that the right data is loaded when it's needed? One nice thing about promises is that the settled functions, then and catch, both return promises. This means that you can chain promises together. If we were to look at our success code from earlier in the module, we could have our then function return of value, nothing special. Any ordinary return value will work. And the then function will wrap this return value in a promise, which means that we can chain another then to the function. Now when this code runs, it will place the orders on the screen and then log out Pluralsight to the console. We'll leverage this ability to be able to sequence our data requests. Let's return to the IDE and the orders.js file. We want to add some information to our orders list page. Specifically, we want to display the order status. To do that, we'll first fetch our list of order statuses and then use that data to look up the status of our order. So start by creating a get that fetches order statuses instead of orders. Next, we need to handle the case where that returns successfully. And what function would we use there? That's right. We'll use then, so let's add that. At this point, our data object is an array of orderStatuses. And now that we have all of those, let's fetch our list of orders. As we've seen before, we need to handle the then of our second Axios call. We could put that then function on the same line as our second Axios call, but then we'd pretty much be right back to where we were in the last module with our callbacks. So instead, let's try something else. Start by adding a new variable before Axios and name it Statuses. Then before our second Axios call, let's assign data to our statuses variable. Next, we need to make sure that we return our second Axios call. If we don't, JavaScript will return undefined from the function, and we'll have all sorts of issues. After our existing then, let's add one more then. This code might look a little complicated, so let me walk through it really quick. Inside of our second then function, the value of data is our orders. We're mapping over our list of orders so that we can look up each order's status, and that's what we're doing with the statuses.find function. We're finding the status description of that exact order. Once we've added the order status property to each order, we can call the familiar showOrderList. Now that that's all typed up, make sure the file is saved and that your server is still running. When you refresh the My Orders page, the orders again display, and this time the Order Status column is filled in. It's starting to look like an actual orders page. And if you pop over to the Network tab in the developer tools, you'll see that the call to orderStatuses executed before our call to orders. This is pretty similar to what we saw in the last module, but we did it without nesting a lot of function calls inside of function calls inside of function calls. That is, we didn't have to use the callback pyramid. Look at the code one more time, and let's read this code from top to bottom. It starts by getting all of the order statuses. Then, it fetches all the orders. Then, it loops over those orders and assigns their order status description. Our code is starting to become a bit more clear and readable just by using promises, and you can imagine how you could change several promises together in this fashion as long as you remember to return the promise in each then. But what if you're like me and you forget sometimes? Okay, let's be honest, more than sometimes to return the promise? I'll show you how you can handle that situation more gracefully in the next clip.

Catching Errors in a Chain
Sometimes when you're chaining promises together, the unexpected can happen. That could be an unexpected API result or even a bug in your code, like what if you tried to access a property on an object that didn't exist? Those often get logged in the console, but how could we make that better? Go back to your orders.js file in your IDE. In order to force an error, let's start by deleting the return keyword when we're fetching our orders. This should cause an error with our second then function because data won't be defined. Next, we want to add a catch function. The question is where do we want to add it? Well let's start by placing it after the second then function. Return to the app and reload the page. When it reloads, you won't see a list of orders. Instead, you'll see an error, TypeError: Cannot destructure property data of 'undefined'. And if you click in your console, you'll notice that it's not there. Since you used the catch function, you handled the error, meaning it won't bubble up to your users in their developer tools. Returning to our IDE, let's look at another way that we can use this catch function. Start by adding back the return statement on our Axios call so that it completes successfully. This time, inside of the second then function, introduce an error by adding the word order in the find function. That is, we're trying to look up o.order.orderStatusId. Return again to the browser and refresh the page. Again, there's no console error, but the results block now shows TypeError: Cannot read properties of undefined. The catch that you added will catch any error in the stack. You do have the freedom to move around the catch function, and it doesn't have to be the last function. For example, the pseudocode on the screen is valid. In this situation, the first catch will only handle errors that happen in the first then function. However, the second catch will handle errors that happen in any of the then functions, including the first one. And it will also handle errors that might happen in your first catch function. As you start to chain promises together, you might want some code to run only once the entire chain is settled. You could have a lot of duplicated code in each then and catch block to ensure that you're capturing that the promise is completely settled. Or, as I'll show you next, you could accomplish that with a built‑in promise function.

Performing One Last Operation
We've already seen how to handle a promise getting fulfilled and what to do when a promise gets rejected. But what if you need to execute some code after a promise settles, but you don't care if it was successful or not? Thankfully, there's a function just for that. As we've already seen, one common case for consuming promises is using a library like Axios to make HTTP requests. And often, when applications make HTTP requests, they like to show a loading indicator. And then, once the call is fulfilled, we want to hide that indicator. But we also want to hide the indicator when the call is rejected. I think we've all ran across the website that doesn't hide the indicator when there's an error and you're unable to do anything. So we need to make sure that the indicator goes away whenever the promise is settled. However, we don't want to do it the instant a promise is resolved. We want to make sure that all the code in all of our then and catch blocks completes before we hide the indicator, particularly if we have a long running process in one of our blocks. We don't want the indicator to disappear too quickly. So, how do we handle this? Return to the orders.js file in your IDE. Then, at the top of the file to show our loading indicator that we have imported from our helper functions, make sure you call showWaiting before the first Axios request. With that, let's hop over to the browser and make sure we know that the loading indicator is working. Refresh the My Orders page. And when you do, you can see that there's an indicator on the screen with the message waiting. And I'll give it to you. This isn't the best loading indicator, but it works for our purposes. So our loading indicator shows up, but it's not being hidden. So, how do we make sure that it goes away? Going back into our code, we have a couple of choices. We could place our hideWaiting function in the then block or the catch block or both. We already said that we want to make sure that both states stop showing the waiting indicator. But as we started the course by talking about producing good code, it's probably not best if we duplicate a lot of code by placing it in each of the blocks. Thankfully, promises have a function just for this case. So after the catch function, add a new function named finally. Inside this function, let's use a timeout to call our hideWaiting. We normally wouldn't want this, but for demonstration purposes, it'll let us see the waiting indicator for at least 1.5 seconds before it disappears. Return once more to the browser and reload the app. You can see the waiting indicator shows up. And then about 1.5 seconds after the data shows up, the loading indicator goes away. This allows you to run some asynchronous code, handle the success or failure cases, and run some final code. In our case, we're using that to clean up our waiting indicator. Remember, there are three states of a promise, pending, fulfilled, and rejected. And in this clip, you were able to see each of those three states. And more than that, you were able to see how to start chaining fulfilled and rejected states to handle the flow of your data in your application and then wrap up with a finally function. Now that you know how to handle consuming promises, you might be thinking about our call to orderStatuses. That's kind of a metadata call that isn't likely to change very often. And it would be nice if that type of data could be queued up at the launch of our application. There's good news. In the next module, I'll show you some various ways to queue up several promises all at once.

Queuing Promises
Queuing Promises
Have you ever needed several functions to run independent of each other, but you couldn't continue until they were all complete? If so, that's a use case that promises excel at. One of the first large‑scale applications I wrote using JavaScript required a lot of metadata. There were users and customers and jobs and more, each with their own statuses and types. We might have needed 10 pieces of metadata to perform one action on the screen. But I didn't want to load the user metadata and then load customer metadata and then load job metadata because that data wasn't really related. I just need to make sure that all the metadata I did need was loaded before I continued. In fact, not only did I not need to have sequential API calls, I didn't want them. It'd be too slow for my users. I wanted to match up all of my calls, fire them off all at once, and then move on once they all came back. And this is part of the power of asynchronous programming. You don't have to wait for one call to finish before you start another. And with promises, you can still tell the code to not continue until all of that data comes back. As we've already seen, our orders list shows the order status, but it also has a blank field for each of the order's shipping addresses. And in the last clip, we wrote some code to make sure we didn't load our orders until the order statuses were fetched. We want to do something kind of similar with our addresses as well. Return again to the orders.js file in the IDE. As we've done in the last module, let's use Axios again. But this time, it's going to be a little different. Start by creating two calls, one for orderStatuses and one for addresses and then assign both of them to their own variables. So I have a statusReq equals my orderStatuses call and an addressesReq equals my addresses call. Now remember, Axios is built using promises. So both statusReq and addressReq variables are each a promise. The question is, how can we wait until both of these promises are fulfilled? We could probably write some complicated logic and try to manage the state ourselves by tracking when each promise is returned, but I'm not particularly interested in writing code to manage that state. I just want to write application code. And I can only imagine how it would continue to get more complex with each promise that we needed to wait on. The good news is there are a few functions on the promise object, and one of them is aptly named all. So, let's try that out. We'll use promise.all, and then we'll pass in an array that has both of our two promise requests. Then, we can attach a then function for this all so that we can handle it in the same way as we've done with a single promise. So far in this course, every time we've used then it's been to handle a single promise. But here we have two promises, and it could have been more if we needed them. So, what will the result value be in then? Do you have any ideas? It's going to be an array of results, and the order will match the order that we added them, not the order that they're resolved. Let me repeat that because it's important. The order is tied to the order that they're added and not the order that they return. And that's good news because it means statuses will always be the first result. Remember, these are Axios objects coming back and so therefore we need to access the data property on them to see our data. Next, let's create those variables outside of our promise scope so that we have access to them throughout this block of code. Now that we have our data, let's make a call to get our list of orders again. And remember to make sure you return that promise and then chain another then function. Most of this code should look somewhat familiar based on how we got our order status in the past. The new part is that we're finding this order's address in the list of addresses and then using that to build up our shipping address text. Hopping over to the web, if we reload our page, after about 1.5 seconds, we see our list of orders. And this time, they include both the order status and the shipping address. And if you look at the Network tab, you can see that all three calls were made to the API, orderStatuses, addresses, and orders. And if you notice, both orderStatuses and addresses were kicked off simultaneously. Addresses returned nearly instantly, but orderStatuses took some time, about 1.5 seconds. And remember, that's a delay that we've built in to this call so we can see some of the functionality of promises. It was only after both of those returned that the orders call was made. What happens though if one of our calls fails? Will it sit there waiting endlessly for it to be fulfilled? Well, let's tweak the code and find out. Start by adding a third Axios call at the top, this one for address types. And then, let's make sure to create an array to hold the results like we did with our others, as well as assign the array to the results. And of course, we need to add it to the Promise.all array and also the then array. One thing to note before we go back to the browser, there is no metadata called address type. So what we're expecting is for this call to fail with a 404. So, let's hop over to the browser and see what it does. This time, our orders list isn't updated, and you can see that the call failed with a 404. Navigating to the console, you see that there's an error, Uncaught (in promise). And do you remember what we have to do when we see an Uncaught (in promise) error? That's right. We have to catch it. So let's go add a catch statement in our code. Just like we can chain a .then after an all call, we can also chain catch functions the same as we would any other promise. So, let's save that and head back to the browser. Notice what happens. Not only does the page update nearly instantly with a 404 error, but if you look in the Network tab, it updated before the order status call even completed. Let's rerun that one more time and pay attention to the network call and see what happens. The all function will wait until either all promises are fulfilled or until the first promise is rejected. This can be useful in a situation where you don't want to continue if any of your promises are rejected. For example, if the address type data had been something so essential that we couldn't possibly continue without it, we wouldn't want to wait for other promises to complete before we continued by handling that error. But what if that's not the situation? What if the data is so independent that you don't really care if one or two calls fail and you want to wait until they're all settled? I'll show you the two things we need to change to make that happen next.

Settling All Promsies
Sometimes when you cue up promises, you want as much data as possible to come back. If one or maybe even two promises fail, that's okay so long as you get the rest of the data. To see how to do this, return to the code from the last clip and modify the code for the allSettled function. The first thing is to change the function name. Instead of Promise.all, it's allSettled. AllSettled is similar to all, but it's different enough that I want to pop out to some slides to explain it before we continue to use it. First the data that is passed back is different. All will return results objects as part of an array. But allSettled returns a different shape. It has an array, but for each object, there's two keys. The status key will be either fulfilled or rejected like you see on the screen, and the second key will be either value if the status is fulfilled or reason if the status is rejected. That is, the then function on allSettled will return all promises even if they're rejected, which leads to the second difference. We don't need a catch block because the promise will resolve with an array of data including the rejected promises. And even though a catch block is not specifically needed, it's still a good practice to include it. It'll help catch any errors that might occur inside of your then block. With that brief explanation, let's hop back into the code and take a look at what this should look like. Instead of just assigning the data property to each of our arrays, we're going to do something a bit different. This code will check the status property. And remember, our two choices are either fulfilled or rejected. If it's fulfilled, it will assign the data to the array. And again, remember, because it's fulfilled, we have to use the value property in order to access our actual Axios value. If it's not fulfilled, we're simply going to use window.alert to let the user know the error. Now, using window.alert is not something I'd recommend in a production app. But for the purpose of this course, it'll be fine. With that all done, let's return again to the browser. When you refresh, after about 1.5 seconds, there's an alert to let you know that the addressTypes call failed, that it's not a valid route for our app. Then, once you clear that, the rest of the data is there. By changing the name of the function from all to allSettled and by expecting a different object shape in the then function, you're able to queue up several promises that wait until they're all settled before calling the then function. In the previous clips, we've seen functions that operate on a list of promises and return a list of promises. But what if you only need a single promise returned? We'll look at that next.

Waiting for a Single Response
In some situations, you might queue up more than one promise, but only care about the first one to get fulfilled. In that case, there's a promise function that you can use. Before looking at that function though, I want to take a quick detour to talk about two other built‑in JavaScript functions, every and some. These functions exist on array objects in JavaScript. Both functions follow the same syntax. They take a function that will be evaluated. With every, if that function is true for every item in the array, then every will return true. With some, if that function is true for at least one item in the array, then some will return true. When we used Promise.all earlier, it was similar to using Array.every. That is, we only wanted our then code executed if each promise was successful. You might be tempted then to think that Promise.allSettled is like some except that allSettled called the then function even if some of the promises failed. That's why, in the last clip, we had to check the status value of each promise result. So if it's not all settled, what function is similar to some? It's a function named any, and this will succeed when any of the queued up promises succeed. The syntax of the function is similar to all are allSettled and that you pass in an array of promises. However, the value returned to then is different than either all or allSettled. It's not an array, but a single item. And that item is the result of the first promise returned. Another difference between all in any is that all will reject the promise, and that is called the catch function, whenever the first promise rejects. That is, with all, they either all succeed, or the call fails. But with any, it's the opposite. Any doesn't fail unless each promise rejects. Again, similar to that some function. In essence, with any, you're stating if any of the promises succeed, count that as a success. And only count it as a failure if they all reject. You might be wondering at this point, when would I use the any function? And that's a good question. And I can tell you from experience that the majority of the time I've cued up promises, I've used either all or allSettled. But one situation where it can be used as if you've got multiple endpoints that are distributed geographically. They all return the same data so you don't really care which one succeeds; you just want the fastest possible response time. In that case, if you used any, that's exactly what you get. Whichever in point returned quickest would win, and your code could move on. As I mentioned a few minutes ago, any waits until all promises reject before it fails. What if you didn't want that and instead wanted the first response to come back whatever it was? We'll talk about that next.

Waiting for the First Response
Have you ever had an API request that usually returns really quick, but occasionally can take a long time? In those situations, you don't want to flash up a loading indicator only for it to instantly disappear because that could be too jarring for your users. But you also don't want to not have an indicator for those cases where it does take a long time. You could use this next promise function to make that request and, if it's taking too long, show a loading indicator. The Promise.race function is similar to Promise.any in that it takes an array of promises and passes a single value to its then function. The difference between any and race though is when it returns. As we saw in the last clip, any returns the first successful promise. Otherwise, it waits until all the promises are rejected. But race doesn't care about the result. Whenever the first promise settles, race settles. It's a race between the promises regardless of the results. That means when you use race, you definitely need to handle both the .then and .catch functions. If the first promise to settle is successful, it will call the then function. However, if the first promise to settle fails, it'll call the catch function. As I mentioned at the start of the clip, this could be useful to put a timeout on one of your requests. In this code, if the possibly long running‑request succeeds, it will call the then block and show the user data. However, if the timeout promise completes first, it will throw an error, and the catch block will be displayed showing a message like there's an issue with your request. Please try again Later. Since race will take the response of the fastest promise, it's not going to have as many use cases as the other functions. Most of the time when I'm queuing up promises, I will use all our allSettled because I want the data once all of my promises are fulfilled. And as I mentioned in the last clip, I have rarely needed to use any. In that same vein, I don't remember a time that I've ever used race. But it is a function that you should be aware of if the need arises. You've now learned that there are four distinct ways to cue up a list of promises. All will wait until either all promises are fulfilled or until one promise is rejected. AllSettled will wait until all promises are settled, either fulfilled or rejected. Any will wait until the first promise is fulfilled or until all promises are rejected. And race will only wait until the fastest promise is settled, either fulfilled or rejected. With these functions, you have a lot of control over how promises are used in your application. And up until this point, we've been focusing on how to consume promises. But how can you actually create a promise? The next module will show you the two main things you need to consider when creating a promise.

Creating Promises
Creating Promises
By now, you've seen some of the power of promises as your code transitions from being nested function inside of nested function to chains of thens and catches. But if you want to move past just consuming promises from other libraries, you need to know how to create your own promises. As you think about consuming promises and start to think about what you need to do to create your own, what are the major aspects you need to consider? Right. You need to make sure that you manage the three states, pending, fulfilled, and rejected. Pending is probably the easiest state to handle because, if you remember, a pending promise is just a promise that has not yet settled. So when you create a promise, it's pending until you tell it to move to the fulfilled or rejected states. That leads to the question of how do you create a promise? And before we answer that, let's look again at the definition we saw earlier in the course. A promise is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value. We've already talked about eventual completion and asynchronous operation. But do you see anything else in the definition that tells us how to create it? Do you see object? A promise is just an object. That means that we create a promise the same as any other object in JavaScript. As you can see with the code on the screen, tmp is now a new promise. And at this point, it's also a pending promise. Okay, so that's how we create it, but how do we change its state? The first thing to know is that a promise takes a function as the one and only parameter to its constructor. This function is called the executor function. The inside of that function can really be as simple or as complex as you want it to be. For demonstration purposes, I'm going to use setTimeout inside that function. A quick aside here if you're not familiar with setTimeout. It takes two parameters. The first is a function, which gets executed after the second parameter. And the second parameter is a timeout. In this case, it means that after 1500 ms, or 1.5 seconds, timeout will be logged to the console. Do you remember earlier in the course when I called out that promises are eager? That means if we were to run this code right now, the setTimeout function would start executing immediately. And about 1500 ms after we newed up the promise, timeout would be logged to the console. The problem is is that all that would happen and still not change the state of the promise at all. If this code were to run, what would we get written out to the console? Only the word timeout would get logged. We'd never see the word then on the screen. That's because I haven't been 100% truthful with you. A promise does take a function as its one and only parameter, but it doesn't take an empty function. It takes a parameter, resolve, and this parameter is a function that the promise will use to resolve its state. So now we need to decide when we want our promise to be resolved. It probably makes the most sense to resolve it after the timeout has triggered, that is inside the function passed into setTimeout. In this case, the code looks a little different. I've gotten rid of the first console.log statement and replaced it with resolve, and then I've updated the then function to log out whatever value is passed into it. If this code were to run, the statement timeout would be displayed in the console about 1.5 seconds after the promise was kicked off. In our case, the data that's passed to then is simply a string. It's that timeout string that we're passing. But remember, in the previous modules, we saw complicated objects from Axios that contained things like status codes and result headers and blocks of data. And even that block of data was possibly also a complicated object. When you're creating a promise, what's passed to the then function is completely up to you. Looking again at that sample function, we see the setTimeout, and that function will only execute its function one time after the completion of the timeout, in our case 1500 ms. But setTimeout has a related function named setInterval. The syntax of the two functions are the same. The difference is how they execute that function. Where setTimeout will only execute once, setInterval will execute repeatedly. That is, every 1500 ms, the setInterval function will run again. In the next clip, we'll use this feature of setInterval to demonstrate the various promise states.

Understanding Promise States
What happens when a function that has been promisified fires multiple times? Understanding this will help you understand promise states. Let's start by looking at the code we just finished the last clip with. As we saw, that code logs out to the console once after 1500 ms. Now, if we change our function from setTimeout to setInterval, we'd have a similar, but slightly different situation. Remember that the difference between timeout and interval is that interval will run continuously. In this case, it will trigger every 1500 ms. So, what do you think will happen when we run this code? We can test this out in our terminal. I'm going to start by executing the command node, which will give us an interactive node terminal. And then I'm going to paste in the code that you just saw. When I run this, it will produce a timeout after 1.5 seconds and log that out to the screen. But if we wait here for a little bit, it doesn't log out another timeout. In fact, we could wait here all day, and it wouldn't log out another timeout. So, does a promise change the behavior of setInterval? Well, not quite. Let me kill that process and we'll try something else. Before I run this code, notice that the only difference is the new line where I log out the word interval before it calls resolve. This time, when I execute the code, we see after 1500 ms that it logs out both interval and timeout. Then, after another 1500 ms, it only logs out interval. So the setInterval function is behaving as normal. That is, it's executing every 1500 ms. But it's only resolving once. Let's kill that process. Now that we've killed that process, let's again run Node, and let's paste in one more block of code. Again, before running this, notice what's different. All I've done is add a finally block. This time, when it's run, we see interval, then timeout, then done. Then, after 1500 ms, we again see interval. So, what's happening here? Remember earlier in the course when we talked about states? I mentioned that there are two other words that are used to reference when a promise is no longer pending. Those words are settled or resolved. And based on the last demo, you can see that once a promise is settled, its state is not updated. That's because calling resolve causes the promise to be resolved so that if you call resolve or reject again, it has no effect. That is, once the promise is settled, it's done. And attempting to settle it again won't do anything. It's also why the finally function in our last demo executed right away. In fact, it executed before setInterval could kick off its next log. The function continues to run, but the promise will not change. If moving a promise to the fulfilled state is that easy, then surely moving it to the rejected state is just as easy, right? Well, we'll find out in the next clip.

Rejecting a Promise
In the last module, I told you that I'd show you the two things you need to know to create promises. You've already seen the first one, how to resolve. It's time to look at the second thing. How do you reject a promise you've created? You've already seen the general syntax of a promise and how to resolve it. And you're all smart people, so you can probably guess how we would go about rejecting a promise. That's right. Even after I confessed I wasn't completely truthful with the first promise constructor, I still wasn't 100% truthful when I showed you that a promise takes a single function and a single parameter because the function passed in the promise constructor actually has two parameters, one for resolving and one for rejecting. And I know you're probably thinking, I bet there's yet another parameter you're not telling me about now, and there's not. There's just these two. If you don't completely trust me, that's okay. I put a link on the screen that you can use to go check out the docs on MDN and see that there's only two functions passed in, resolve and reject. As we've seen elsewhere, you can control what gets passed when a promise gets resolved, and you can also control what gets sent when the promise gets rejected. Whatever you pass into the reject function will be passed in as the parameter to the catch function on the code that calls this promise. Let's take a quick look at a semi real‑world situation. This is a block of code that will promisify our xhr request from earlier in the course. Start by understanding that this promise is a function that allows the user to pass in a URL to access via Git. You can see that URL parameter here on the line for xhr.open. Next, you can see that we're determining if the HTTP status code is a 200, we're going to resolve our promise. That is, we're going to say it was successful if it returned to 200. But also notice that we have two calls to reject because in our application, we've decided that any call that is not a 200, we want to be considered a failure. And we also want to handle the onerror code of our xhr function. Also note that those two rejects are passing back different pieces of data. The first passes back the status text. For example, if the status code was 404, the status text would be not found. The second is a more generic error, simply request failed. What I want you to take away from this block of code is that when you are creating a promise, you have some design decisions to make on success and failure. You decide what's a success and what's a failure, and you also decide what data gets passed in those situations. A few years after promises were developed in JavaScript, the language came up with async/await. And I think now that you know the basics of promises, you're ready to learn some secrets about async/await. The next module will help demystify this operator. And once you understand one important fact about async/await, your knowledge of promises will transfer to this new syntax as well.

Iterating with Async / Await
Iterating with Async / Await
Now that you're familiar with promises, it's time to reveal an uneasy truth. JavaScript promises are kind of old. For some people, they've already been replaced by async/await. But don't worry. What you already know about promises will prove to be a solid foundation for async/await. If JavaScript already had promises, why did it introduce async/await? Or in other words, what's the point of async/await? The purpose of async/await is to make it easier to use promises in a synchronous format. In other words, don't think of async/await as a new technology or paradigm. Instead, it's often referred to as syntactic sugar for promises. Syntactic sugar is syntax within a programming language that's designed to make things easier to read or to express. So the goal or purpose of async/await is to make working with promises easier. It simplifies some of the code and makes it more clear exactly what is going on, similar to how promises were more clear with what was going on in the code than the callbacks were. This is good news. Since you already learned about asynchronous programming and promises, your understanding of async programming will carry forward to async/await. So while you're going to be learning more about asynchronous programming, you'll be starting with a solid base. Before getting into the examples, let's take a minute or two and defined what async/await actually is. To start, there's two separate keywords. There's async and the await keyword. The async keyword is used to designate that a function is asynchronous. The keyword is used when a function is defined, and you can define it with either a standard function declaration like you see on the left or with a fat arrow function like you see on the right. In either case, this function will return an implicit promise, which should be somewhat comforting because underneath the function, it's still just a promise that's being operated on. Because it's an implicit promise, it means that whatever you return will be wrapped inside of a promise. Additionally, if your function throws an error, that will be wrapped inside of a rejected promise. The await keyword pauses the execution of an asynchronous function while it waits for the promise to be fulfilled. There's a couple of important notes about await. First, it can only be used inside of an async function. If you try to use it outside of an asynchronous function, you will receive an error. And secondly, it only blocks the current function. However, it does not block the calling function. For example, if you had this code, the await for someFunc would halt getNames and not go to the doSomethingElse until someFunc was done. However, it would not stop getAddresses from executing. Don't get too hung up on the details though as the rest of the module will get into some code examples that will help you understand. The important thing to note is that both async/await and synchronous promises are both trying to accomplish the same thing. The next clip will show you how you can take an asynchronous HTTP call that you've already done in this course and turn it into a single line of code.

Awaiting a Call
Now that you've had a brief overview of async/await, the only thing left to do is dive into some examples. Start by going back to the orders.js file. We're going to start with a blank file, and we're going to use async/await to fetch our list of orders. Much like we did with consuming promises, we want to do a simple HTTP request. The code here has the await keyword before the axios.get function call. This highlights that you can use await on functions that return promises. That is, you don't need some separate async/await version of Axios. Additionally, since this is now making this promise asynchronous call, you can assign the data parameter to the value of the get call. There's no then function that you need to process this data in. Or more accurately, you can destructure the result of that get call into a data parameter. Make sure you still have the server running and go to the My Orders page. When you load this page, you'll get an error in your console. It tells you that there's an unexpected reserved word. Can you see what that error is? Let's go back to the code and look at that get function. Do you notice anything here? Remember in the last clip, there were two important notes on the await keyword. The one that applies here is that it must be used inside of an async function. So let's add an async function definition. Notice at the bottom, I call the get function we just created. This time, when you reload the page, you don't see any console errors, or at least you shouldn't. And you should see a somewhat familiar output. Granted, it doesn't have all of the data, but our list of orders is back. Let's take a quick look at the code side by side. On the left, we have our promise‑based approach. And on the right, we have our async/await‑based approach. They're both accomplishing the same thing, and they're doing so in similar ways. However, with await, it might be slightly more clear the order the code is getting executed in. Much like with promises, what happens when an API call fails? Well, the next clip will show you a familiar way to handle errors with async/await.

Handling Errors with Async / Await
When handling errors with promises, you only had to attach a catch function. But how do you handle errors with async/await? Head back to the code from the last clip. As we did with our promise code, change the route to get order 999 because this will produce an error just like it did when we used it with our promises. In the last clip, I promised you that it's a familiar way to handle the error. You want to try and take a guess at what that way is? Believe it or not, this is one place where it's not really related to promises. That is, there is not an awaitCatch function. Instead, it's the tried and true try/catch block. If you save that and reload the page, you'll see a familiar 404 error in the response text, and you'll notice the standard 404 error in the console as well. Looking at this code one last time, notice that since the error handling is the standard JavaScript try/catch block, you now have the ability to have the same error handling for both your synchronous and asynchronous code if you're using async/await. Before we continue on, let's set our route back to the default so that it doesn't give us any more errors. Earlier, we saw how promises can be chained to combat race conditions. In the next clip, I'll show you how to accomplish the same thing with async/await.

Chaining Async / Await
Async/await makes sequencing asynchronous calls even easier than promises did. Earlier in the course, we chained some promises together to get our order statuses so that we could display them on the screen. We used the then of our order status call to fetch our orders and assign the correct status to each order. We want to do the same thing, but this time with async/await. So, head back to orders.js. Inside of our try block, let's add a call to get our order statuses. Next, let's go in between our call to orders and our call to showOrderList. At this point, we have both of our statuses and our orders, so we can loop over them and assign the correct status to each order. And then we just need to make sure that we're passing the orders value to the showOrderList function. One thing to note here, this data.map function is the exact same map function that we used earlier in the course. Heading back to the browser, we can refresh our My Orders page. We again get our list of orders, each with an order status, which is what we'd expect. And when we look at our Network tab in the console, we see that the order status call is first, and the orders call is second, again what we would expect since we sequenced our API calls in this order. Switching from callbacks to promises was a big improvement in our code. But if we compare our async/await to our promises code, it might be an even better improvement. If we start by looking at our promise‑based code, we can see that this improved that xhr code from the very start of the course because it allowed us to chain multiple then statements together to handle the flow as opposed to nesting multiple callbacks. And compare this code with the async/await code. This appears to be an even better improvement than from xhr to promises. The code is a bit more concise and straightforward. And if you want to chain another HTTP request, all you have to do is add another await statement to that API call. The challenge is that handling async/await in this fashion makes all of the calls sequential. So, what if you want to make concurrent requests? I'll show you how async/await can break free from the sequential calls in the next clip.

Awaiting Concurrent Requests
We've been using async/await in a way that makes sure to call asynchronous functions in a truly sequential fashion, and sometimes that's great. But other times, you don't want functions to depend on one another. Don't worry though. You can still use async/await. Let's return to the code from the last clip. In this code, we have requested our order statuses. And then, once that data was returned, we requested our orders. But we had to wait 1.5 seconds on line 3 because that's how long that request takes. So, let's make a couple of tweaks. Start by changing everything to the left of Axios for our orderStatuses request and replace it with a variable. And then, do the same thing with our orders request. So we should have a statusReq = axios and an ordersReq = axios. Notice that there's not an await statement there. Keep in mind that axios.get is still a promise, and promises are eager as I've mentioned many times in this course. That means that the request has already been kicked off. Now, after our request, let's await our two functions. And then make sure to change the variable name from data to orders on the map function. And after those two awaited statements, we process our results to set the order status on each order. Heading to our browser, reload the page. After a brief pause, you'll see all the data instantly appear after about 1.5 seconds. Before returning to the code, take a look at the console, and you'll see that the orders API call resolved first, and the order status call resolved second. And you can tell that by the green bar. So even though the orders request happened second, it completed before the order's status call completed. Return to the code and take a look at the await statements. We're awaiting the order statuses first, which means we don't do anything with our orders data until we get the data for our order statuses. But because the order statuses, recall, is slower, by the time the await is complete, the request for orders is also already complete. So both calls were running at the same time even if we did tell the code to wait on the slower request first. There's one more possibility for these calls. What if we wanted to handle the same two calls, but show the data in the order that it came back. In the next clip, you'll see how to handle that exact case.

Awaiting Parallel Calls
Part of the power of asynchronous programming is that you can make parallel calls so that you're not locking a fast‑running process with a slow‑running process. You can do that exact thing with async/await. To see how to make parallel calls, start by commenting out the code that we've written so far. We need to start by creating our function as an async function and then calling it. Now the question is, what do we put inside of that function to make it work in parallel? Remember that async/await is syntactic sugar on top of promises, so we have the ability to mix the two. So let's start by awaiting a Promise.all function call. This will wait until all of the promises we pass in are complete before continuing on to the next line. Also remember that async functions return an implicit promise. So, let's add the first promise to our Promise.all call. Let's pause here for a moment because this might be unfamiliar syntax. We're creating an anonymous async function. Since it's async, it will return a promise, which gets passed into our array of promises for our all function. The body of our anonymous function is the familiar async/await call to get our order statuses. Also notice that after the anonymous function is declared, it's immediately executed with the open and closed parentheses. Finally, it's calling a new function, showMessage, that we'll see in a minute when we reload the app. Next, let's add our second promise, this time for our orders call. With this construct, we now have two promises in the array of our Promise.all function And as we saw earlier in the course, Promise.all will kick off each of the functions and wait until they're all complete before returning. And since we're awaiting the Promise.all call, the get function won't end until all of our promises are done, meaning that if we added code after our Promise.all function, it wouldn't get executed until all the promises were complete. That might seem similar to what we just did in the previous clip. So, what's different? Head back over to the browser and reload the page. When you do, the orders list comes back nearly instantly. Then, after about 1.5 seconds, a new message is displayed above our order header stating status is fetched. If you check out the Network tab in the console, you'll see that once again the orders call finished before the order statuses call even though it was kicked off second. More than that, by using this construct, we were able to update our UI even before all of our API calls finished. In a more sophisticated UI, you might use this to update various pieces of data instead of just displaying a Statuses Fetched message at the top of your page. This is an example of how you can combine promise functions with async/await to cause parallel execution to happen. Both the orderStatuses block of code and the order block of code were running in parallel. And with that, we've covered a lot of information about asynchronous code. We'll recap in the next clip.

Review
You're now ready to go out and tackle asynchronous programming in JavaScript. One of the first and most important things that you learned in this course was that every promise has one of three states, pending when the promise has not yet settled, fulfilled when the promise returned successfully, and rejected when the promise has an error or is unsuccessful. We used these three states to kick off requests, handle the return data, or display errors that came back from the API. You also learned how to create your own promises. This will be helpful as you begin to create your own asynchronous code or wrap existing functions and turn them into promises. Remember to create your own promise, you only need to create a new promise object and then pass in an executor function with a resolve and a reject parameter. You can then decide when to use each of those two parameters to update the status of your promise. Then you learned about async/await, and my hope for you is that while you learned some new keywords, the concepts were already familiar. At the end of the day, async/await excels at the ability turning asynchronous code into sequentially executed code. You can make them concurrent or even parallel as we've seen, but one of the best places to use them is when you need code executed in a particular order. Finally, thank you for taking time to watch this course. I really enjoyed working through promises and async/await, and I know they can be tricky topics, but hopefully we've been able to demystify some of those asynchronous concepts. And I'd love it if you'd leave a rating for my course. And if you found this course helpful, please go to my author page here on the screen and click the Follow button. Thanks.