Let's chat about the syntax of JavaScript. Now if this is a new term for you, syntax is just a set of rules that define how the collection of characters and symbols should be structured within a programming language. Now by following these rules, you will be able to create valid JavaScript. If you don't follow these rules, you're JavaScript would be considered invalid. Let's cover some basic concepts around JavaScript syntax. First, you will organize your JavaScript code into statements. A statement will generally perform some specific action. Now in the example that you can see here we are logging a message to the console. Now if you're not sure what I mean by this, don't worry, you'll see this in action within this module. Now I let the JavaScript engine know that my statement is done by inserting a semicolon at the end. Now we'll talk more about semicolons here in a bit. Now you may be tempted to think that by looking at this example that statements all have to exist on separate lines within your JavaScript file, but that's not the case. As long as you have those semicolons in place, you could write an entire JavaScript application on a single line, but for the sake of code organization, we generally don't do this. By placing statements on separate lines, it makes it easier for humans to read through what you're doing in your code. Honestly, the JavaScript engine doesn't care, but trust me, your future teammates will certainly care. Within every programming language we have keywords. These words have specific meaning since they perform a specific task. In this example, I'm defining a variable using the let keyword. Now you will notice within VS Code that these keywords appear in a different color than the other text that you write. As you learn more about JavaScript, you will learn many different keywords and what actions they take. Now I don't want you to think that you will need to memorize hundreds of these keywords. If we look at the current version of the specification, we have 64. And if you're writing JavaScript on a regular basis, you may use about a third of these on regular tasks. Now another part of JavaScript statements would be operators. You can kind of think of these as the symbols that we use when we write code. These symbols represent some specific action that we will be taking on one or more values. Now we would call these values operands. Now here, I'm going to use a mathematical operation to add two numbers together. Now if I were to run this code, I would get an output of five by adding the numbers two and three together. In this example, the plus sign is an operator with two and three being the operands. Let's chat briefly about those semicolons because a part of the goal of this course is to help you understand what you will see in JavaScript code out in the real world. Now while I've told you that your statements end with semicolons, they don't actually have to. For most JavaScript code it would just run fine without them. The ECMAScript specification allows for automatic semicolon insertion in most cases. That being said, there are some areas, especially if you're new to JavaScript, that could trip you up. Because of that, I personally recommend that you always use semicolons. Now with that being said, if you're looking at some open‑source code or if you're working with a team where semicolons are not used, I just want you to understand what is happening. Now just to finalize that discussion, let me reiterate, you need to use semicolons until you have a level of experience with the language where you can understand what problems might be caused by not using them. And finally, I mentioned earlier that one of our goals with our code is to make it human readable. I can put some text in my JavaScript file, that the engine will completely ignore, solely for the purpose of helping other developers understand what's going on. We call these comments. Well, I'll be diving into comments more deeply in a later clip. I can show you briefly what a basic comment would look like. Now in this example, I'm using some variables. Now I realize I haven't covered this yet, but I'll be doing that shortly. Now in this example, I'm grouping a few different statements together and giving a description of why that block of code is there and what it's doing. This is just one type of comment. And in the next clip, I'll be diving more in depth into different ways that we can write comments and also add in some general notes on code readability.
So next, we're going to talk about the concept of comments in our JavaScript code, and this is something I've only briefly introduced so far. So, let's dive in a bit and take a look at it. So first of all, in programming in general, a comment is text within the source code that is actually ignored by the engine running the application. As such, changing or removing the comment would have no effect on the actual application. And this may leave you asking, why would we use comments in our JavaScript code? Well, I want to give you two reasons, and I'll give you examples of both. First of all, it is to help other humans understand the code. Now there are some good ways to do this and some bad ways to do this, but if we're doing something that's confusing, it might help other developers on our team to have us leave a comment explaining our thought process around a specific block of code. But also, we can use comments to add metadata for tools that are analyzing our code. So let's look at some examples of JavaScript comments. So first, we have a single‑line comment, and we can do this simply with two slashes in front of whatever comment we want to add, and generally you would want to put this directly above whatever you're commenting on. But in some cases, you want to do more than just one line, and even though you could do a bunch of these single lines together, there is another syntax for adding a multi‑line comment. And so here, you can see this particular syntax where we can go in and add in as many lines as we want. Now, I mentioned though that there might be another reason for adding in comments and that would be for dealing with metadata related to tools that are analyzing our code, and I'm going to give you two examples. First, we can actually use comments to document a specific block of code. Now I know we haven't yet talked about functions and there's a lot here that we haven't covered yet, but I'll just point out that we can use this to specify different parameters and return values and then tools can be used to actually generate web pages of documentation for our code. So, we're not going to cover that fully yet, but I just want to point out that's one of the ways you can use it. Now, there's another tool that we'll be talking about at the end of this course called ESLint, which can actually help with our formatting and to make sure that our code is valid according to the rules that we have specified. And in this case you can choose to actually tell that tool to disable looking at a specific line for one reason, utilizing comments like this. And there's actually multiple different ways we can specify those config rules. But this just showcases two different ways that we can utilize comments with other tools that are separate from the engine that's actually running our JavaScript application. Now I want to give you a quote here about comments because I think this is also equally important to understand. So, nothing can be quite so helpful as a well‑placed comment, but nothing can clutter up a module more than frivolous dogmatic comments. Nothing can be quite so damaging as an old crufty comment that propagates lies and misinformation. So, in summary of this quote from Robert C. Martin, just understand that your comments need to stay up to date with your code, and if your code is self‑explanatory in a situation, then you might not need to add in a comment at that spot.
Back in the first clip of this module, I mentioned variables. Now variables are essential to any programming language, so let's discuss how to leverage variables within JavaScript. If you were building a company directory application, which we will be doing over the length of this course, you would store information about each employee, including their first name, last name, maybe their number of years at the company. Hey, you could even store their birthday. But before we assign values to these, each of the variables will need to have a name, so let's chat a bit about naming in general. Now, first I feel that it is appropriate to bring up Phil Karlton's famous quote, There are only two hard things in Computer Science: cache invalidation and naming things. Now if you're new to programming, you will be amazed at the amount of time you will spend staring at the screen and wondering what should I name this variable or function. Getting good at naming things is just as much a skill as writing the code. Now since our end goal is to have code that is easily understood by other developers, we really need to focus on this. Now in JavaScript, we have a few hard rules and then a few best practices when it comes to variable names. Let's cover the rules first. Now names can contain letters, digits, as well as the dollar sign, and underscore characters. Second, you cannot start your name with a digit. Now names within JavaScript are case sensitive, so an uppercase A and a lowercase a for a name would be different variables. Now now that we have the rules out of the way, let's chat about the best practices. Variable names in JavaScript usually start with a lowercase letter. Next, JavaScript variables generally leverage camel case naming. This means that the name starts out with a lowercase letter and then all of the subsequent words start with a capital letter. Now this is different from some other languages that might normally use a dash or underscore to separate words. Now while these best practices are not rules, they can help you write code that will fit in with most of the JavaScript that is being written today. Okay, now that we've covered these rules and best practices, let's get to the code. Now let's actually assign some values to a variable for the items we mentioned earlier. First, we need to use a keyword to define a variable. We have three different keywords that we can use here, and I'll explain each of them in this clip. For now, we will use the let keyword. So here, we will start with the keyword and then we will give our variable a name. I'll give the first variable a name, firstName. Now we can see here that we're using camel case for the variable name. Now, I'll use the assignment operator to specifically say that I want to give this variable a value. I'll use quotes around my first name and then I'll put the semicolon on the end of the statement. Because I'm using the characters that make up my name here, this is a string, and in JavaScript we can define strings with single quotes or double quotes, there is no difference, unlike some other languages. Now we also have other ways to define strings, but we'll talk more about that later within this course. Now next, I can do the same thing for the lastName variable. After this, we can create a variable for the number of years I have spent at the company. I'll use the same keyword and I'll give this the name numYearsEmployment. After the assignment operator, I can just add the number six for this. Just as before, I'll add a semicolon to the end of the statement. Finally, I need to add in the birthday. So we're going to do some new things here, and don't worry, we'll dive into how to work with dates later within this module. So I'll specify let as the keyword, and then I'll give it the name dateBirth. Next, I'll add in the assignment operator and then I'll use a keyword we haven't used yet, new. Now I'll specify here that we're creating a new Date object and then I will pass in the birthday. Now, this isn't my actual birthday, I'm just adding in a random value here. I realize that we'll need to dive into the syntax a bit more deeply for creating a date, but as I mentioned, we'll be doing that later within this module. The first thing I want to revisit is a term that I discussed back in JavaScript: The Big Picture and that is dynamic typing. We don't define the data types for each variable in JavaScript. Instead, the JavaScript engine figures out that based on the data that we assign to a variable. Now in the example we have here, we have defined strings, a number, and a date. Now this is one of the benefits of JavaScript, as well as one of its biggest pitfalls. I'll be discussing several things you need to watch out for with dynamic typing throughout this course. Now I mentioned at the beginning of this clip that we had three different keywords for creating variables, and up to this point we have only discovered one. Now one of the things we get when we use the let keyword is that we can actually go back and change those variables. If I want to update my years of employment from six to seven, I can easily do that. Now there is another keyword that we can use if we want to create a variable and have it never change, and that would be const, which is short for constant. If you create a variable using the const keyword, you cannot go back and update its value at a later time. Now there are many reasons why you would do this, and I'll be covering many of them throughout this course. The third option we have for creating a variable is the var keyword. This was the original way to create a variable in JavaScript. It has its drawbacks, and I would recommend that you don't use it in your code. I do want you to know it exists, as you may run across it in some code out there. So when reading code, just think of it like the let keyword. It does create a variable that you can change. Finally, I want to explain one additional characteristic of JavaScript when it comes to variables and that is how JavaScript decides what variables to keep in memory and which to release. JavaScript uses garbage collection, and according to Wikipedia garbage collection is a form of automatic memory management. The garbage collector attempts to reclaim memory which was allocated by the program, but is no longer referenced; such memory is called garbage. I realize that if you're new to programming, you may not yet understand how this fits in, but I'll also be referencing this concept throughout this course. What you need to know is that unlike lower‑level languages, you don't have to control the lifecycle of the memory that is storing your variable. The JavaScript engine uses its own internal tools to do that for you. Now there are many techniques that you will learn over the course of this learning path to help you optimize your code so that you can avoid some of the common traps when it comes to memory and performance in JavaScript.
Now, we're going to talk about the different data types that we have available to us in JavaScript. Now, as a reminder, and I know I've already mentioned this, but we do deal with dynamic typing in JavaScript. So we can look at it this way, JavaScript is a dynamic language with dynamic types, and variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned and reassigned values of all types. So unlike if you're using a strongly typed language, like let's use Java, for example. In that case, you might have a variable that is of type string, and you could only then assign string values to that particular variable. But that's not the case with JavaScript. You could assign it to be a string, and then assign it to be a number, and then assign it to be something else, so we need to understand that aspect of dynamic typing within JavaScript. Now, it is worth asking the question, well, where is this information stored? Well, memory in JavaScript, we generally have two different places where we're going to be storing the data types that we create, and we have the stack and the heap. Now, I realize this doesn't make a ton of sense to you yet, I'm just going to introduce this concept here within this clip, but we'll be covering this more over this course. So let's talk in general, though, about the two different types of JavaScript data types that we have, so these are kind of the overall types. First of all, we have our primitive types, and I'll go through in a minute and explain what primitive types we have available to us in JavaScript. And then everything else in JavaScript is an object. So, let's take a minute and dive into each of these categories a little bit more deeply. So, first of all, we have primitives. So in JavaScript, primitives are immutable, meaning they cannot be changed. So these values have no methods or properties, and their data is stored directly on the stack since the engine knows exactly how much memory to allocate for that piece of data. And primitives are passed by value, and that's something else that I will be demonstrating here within this module. Now, let's talk about this for just a minute. You might say, oh, well, they can't be changed. That means when I create a variable, it has to stay the same value. No, that's not what I mean in this case. So, let's say that we create a string which we've done so far. I could assign a new string to the particular variable, and that would be just fine, but that's going to be a different piece of memory that is actually allocated for that new string. Now let's talk next about objects. So in JavaScript, objects are mutable, meaning that their contents can be changed without creating a new object. So objects can contain a collection of properties, and they are passed by reference and stored, not on the stack, but on the heap. So we'll give some examples of that here within this module as well. So let's just look at the different data types that we have available in these two overall categories. So when it comes to primitives, we have Boolean values, which again are true/false values; we have number; we have BigInt, or big integer; string, and it's important to note here that in JavaScript, string is a primitive. That's different than a lot of other languages. Also, we have Symbol, Null, and Undefined, and we'll be covering most all of these here within this module. But as I mentioned, everything else in JavaScript is an object, so that includes just plain objects that we've created, functions, our collection types, which would include Array and Map and Set, as well as things like dates that we've utilized so far any class instances, things like errors that actually pop up in our code, and promises. All of these things would be categorized as objects. So it's important to note here that all primitive types except null and undefined have their corresponding object wrapper types, which provide useful methods for working with the primitive values. Now, let me give you an example of this, because this seems like it goes against something that I said earlier. So I mentioned earlier that primitives have no methods or properties, and if I look here, I'm going to give an example. I could utilize this code. So I'm going to create here a new string, in this case David, and I'm going to assign it to the variable name. Then I'm going to create another variable called upperCaseName, and I'm going to call the method toUpperCase on my name variable, and this will convert that David to be all uppercase. Now you might look at that and say, well, I thought name wasn't supposed to have any methods associated with it because it is a primitive value. And you are correct, and it is stored as a primitive value, but JavaScript has some utilities that are provided for many of these data types, where at runtime it's able to substitute in these wrapper methods so that you can interact with that particular data type a bit more easily. But it is important to note here that the way that this works, for example, when I call toUpperCase, it is actually creating a new string, and it's passing that in this case to the variable upperCaseName. It's not changing the value, because, if you remember, in our case, primitives are immutable.
So now, we're going to walk through the process of creating and using strings, and unlike some of the previous examples, we're going to spend most of our time just in the code editor inside of VS Code. Now, as a reminder, I showed you earlier the documentation site that I recommend, which is the MDN Web Docs, which is the Mozilla Developer Network. So everything that I'm going to be covering here about strings inside of JavaScript is covered here in this documentation as well. But, let's go ahead and dive into VS Code. So here within VS Code, this is pretty much the state that we left it in the last time we were in the editor. Now, as a reminder, I have already configured this particular workspace to have a launch.json file, which enables me to be able to execute the current file that I'm in with Node.js. You can go back to the previous module to look at how to configure this for your workspace if you haven't done that yet. Now, as another reminder with that, if I go here under the Run and Debug options, and I want to launch if I see here in the tooltip that comes up, and that might be a little bit small for you to see, but I can use the F5 keyboard shortcut to run whatever script I'm currently in without having to continually switch back and forth between different side nav options here, so I'll be using that over the course of this demo. So, let's go ahead and close this out, and I'm going to go ahead and create a file called strings.js, where I will be storing kind of our experimentation with strings in JavaScript. So here, I have created a string, much like we have already done many times throughout the course of this course so far. So here we're using double quotes to create a single‑line string, but, as I've mentioned, we could certainly do the same thing with single quotes. Now there is a third option that I haven't shown you yet, and I can utilize what we call backticks to also create a string. Now there are some interesting capabilities with backticks that you don't get with the other options, and I'll be covering those shortly. Now, as a reminder, strings are primitives, and so that means they are immutable, but at any point if I use the let keyword to create my string variable, I can go in and reassign a new string to that variable. Okay, so that is single‑line strings. Now let's talk about something else that's important, and that is knowing how to bring multiple strings together to form a new string. Now, one way we can do that is with this operator, the plus operator. When we use that on strings, it will join them together. So here I'm bringing together the firstName, I'm adding in a new space, and then I'm bringing in the lastName to create the fullName. Now I also could do the same thing with those capabilities we can use with backticks, and here we're specifically talking about template literals. So you'll notice inside of this string I can use a dollar sign and curly bracket notation, and then I can put in any JavaScript expression. Now in this case, I'm just using variables, so I'm bringing together the firstName and the lastName, as well as that space, just like I did in the previous example, but I could, again, add in any expression that I wanted beyond just bringing in variables. Now here, I'm going to go ahead and log this out so you can actually see this in use, so I'm going to go ahead and press the F5 key, and when I run this, you can see there that it does bring up David Tucker. So I've pulled together my firstName and lastName into a new variable called fullName. Now, moving on, we're going to talk about multi‑line strings, because there are times when we actually want to have multiple lines within a single string. Now, I'm going to show you one way to do this here. I want to point out here that we're using some special characters. Now these special characters within our strings start with a backslash, and in this case, we have \n, which represents a new line. So here, if I run this, what do you think I'm going to get? Well, I'm going to go ahead and run it and you'll see that I do get Line 1, Line 2, and Line 3 all on separate lines in the console. So, okay, that's great, that gives us what we need, but to be honest, in a lot of ways that's not a very readable way to work with a multi‑line string. So here I'm going to show you another option that we have when we're using backticks. Here, we can create a string and we can actually just have it take up multiple lines. It becomes a lot more readable and we actually don't have to put in those new line characters. It will do that for us. So here, I can close out a string, just like this. Now, the next thing we may need to do is to actually escape characters. Here, in this case, I'm using double quotes inside of a string that I have defined with single quotes. And you can do it this way, you can nest quotes together, as long as I'm not trying to nest single quotes inside of single quotes or double quotes inside of double quotes. Now if there is a situation where I do need to nest double quotes inside of double quotes, for example, I can utilize the special character to escape, so I can use the same backslash here and say, okay, I want this to be treated not as a syntax quote, I want this to be treated just like a regular quote that you would find within any string, so here we can escape it utilizing the backslash character. Now another approach that we can take here is if we utilize backticks, we can use both single and double quotes inside of our strings. But, what happens if you need to use a backslash in your string? Well, in this case, you're going to have to escape your backslash, so here you actually would see two different backslashes together. But, if I were to go in and actually log this out to the console, which I'll go ahead and hit F5 and run this, we can see here in the line that comes up at the bottom, it only shows one backslash, and that's because we escaped it by using another backslash so that it knows, again, this isn't a syntax backslash, instead this is just a normal backslash we're using within our string. Now the next thing that I want to talk about is every string has a property, and this property is length. Now, if you remember, I talked about our primitive object wrappers. These wrap around our primitive values and give us the ability to interact with our strings with some different properties and methods. So here the length property will let us know how long our string is in terms of the number of characters. So here I could also go through, I'm going to use a template literal inside of console.log, and if I were to run this, we can actually see that our Quote Length here is 46 characters. Now the next thing that we can do is we can actually look at specific characters within our string. So in this case, let's say we want to look at the second character in the quote we had created earlier. Well, in this case we can utilize a square bracket syntax and then pass in an integer to say where we want to look. Now you might be saying, wait a minute, you're saying second character, but you're using the number 1. And this brings up a great point that you need to understand when working in JavaScript, and that is that these values are zero indexed. That means the first item in the list is going to be 0, the second item is going to be 1. So if we were to go in and log this out, we should see that if we look at our string, the first character is a capital I, the second character is a lowercase n, so when I run this and I hit F5, we should see that it brings out the letter n, so we're doing what we wanted to do there. Now the next thing here, we can also change case. And we've also done this before, so I'm just going to briefly cover this. We can call the toUpperCase method on a string, which again is there because of that primitive object wrapper, and we could do the same thing with our lowercase value, so we could say toLowerCase. And if I were to run after logging out both of these, I would see both an uppercase DAVID TUCKER and a lowercase david tucker. Now, next, we also can look at a specific substring. So here I'm going to use a function called indexOf to try to find the value of Dav in our fullName. Now, again, that's the first three letters of my name, so if we're looking for where that happens, we should see it return a 0, because that is the first spot in the string, the first character is where that starts. And next, we're going to go in and we're going to say that we want to find the index of ker. Well, that should be at a much higher number because that occurs at the end of my name. So I'm going to go ahead and run those, and indeed, we can see that Index 1 is 0 and Index 2 is 9. Now the last thing we're going to do is we're going to use indexOf to try to find a value that doesn't exist. And when this happens, in most cases, we're going to see that JavaScript will return a ‑1, meaning I didn't find it. So if I were to run this, we would see that this last one returns a ‑1. Now there's also another way that we can check for this. We can check and see if a string contains a substring. So we're going to use here the method includes, and I can see if my fullName includes the letters Dav, and in this case, we know that it should, and so if I run this by running F5, I'll see that it returns true. And that actually helps set up our next clip, where we're going to be talking about true/false values in JavaScript with Booleans.
So next, we're going to be talking about how you use Boolean values within your JavaScript applications. And while we had a huge amount to get through with strings, we don't have nearly as much for Boolean values. But I want to remind you that there is documentation available for Booleans on the MDN Web Docs if you want to go even deeper than what I'm covering here. But for now, let's go ahead and jump into VS Code. So here within VS Code, I need to first go in and create a new file. And now I want to start the process of creating some variables that have Boolean values. So first, I'm going to use the let keyword, and here I'm just going to assign this first one to be true. Now, note here, I'm not using a string, there are no quotes, there isn't a capital T, right? It's lowercase t‑r‑u‑e for true. So now if I go ahead and log this value out, we should see that it will indeed return true. So I'm going to hit F5, and I can see that it does return true. Now, if I want to do false, it works in a very similar way. I go in and say it's equal to false, and then we can log that out and verify it as well. Great. So we've seen how to create Boolean values, one for true, one for false. Now I'm going to introduce you to another operator, and this might not seem super important yet, and you might not yet know when you would use this, but this is something you'll be using. So I want to show you how to use the not operator, and this will change the result that we get back. So, every time you see the not operator, just think the word not in your head. So, in this case, we're setting our variable notTrue to be equal to not and then true. So if we were to go in and log this value out, what do you think we would get? Well, here if I run this with F5, we'll see that we get false. And then we can do the same thing with a notFalse value. So here I can log this out, and we should see that this one is true. And indeed, that is what we get. So while this may seem simplistic and you might think, oh wow, I totally get everything about Booleans, once we get into the next module where we're working with type coercions and when we get to working with conditionals later, you'll see just how important Boolenan
So now we're going to talk about how we store numeric values within our JavaScript code, and to do this, we're going to be talking about not one, but two different data types. So to start with, we'll be talking about the Number type. Now, the JavaScript Number type is a double precision 64‑bit binary format IEEE 754 value, like double in Java or C#. Now, wait, wait, don't leave just yet. I realize that for most of you that made absolutely no sense. The next point, though, is what I really want you to notice. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. This means there's a limit to how big of a number can be stored inside of the Number type, or how small of a number can be stored within the Number type, and that will be important as we look at the other data type that we have as well. So, with that being said, I do want to remind you that we do have documentation on the MDN Web Docs. So here you can follow the link on the screen to get to the documentation for the Number type. Okay, now that we have all of that out of the way, let's get in to VS Code. So I'm here within the editor. I'm going to go ahead and create a new file, and what we want to do here is something that, to be honest, we've already done a few times. We're just going to create a basic number value. In this case, we'll say num1 is going to be equal to 6. That's just a small integer. Well, for num2, we'll do a negative number, and you can see that we can do it this way. For num3, let's do a decimal, in this case, 1.234567. So all of these can be represented just fine with the Number type. But let's talk about what happens if we start getting to some really big or some really small numbers. I want to show you here first that we're going to try to store a really large integer inside. Now you'll notice immediately we have some little dots that appear underneath, and it says here that numeric literals with absolute values equal to 2 to the 53rd power or greater are too large to be represented accurately as integers. Well, we'll see those minimum and maximum values in just a bit. But for the moment, let's pretend like we didn't see that warning and let's just keep moving forward. I want to go through and log this out because it's probably not going to come out the way you would think. So here you'll notice that we get an e notation value. Now, in this case, what this means because it says e+ is that we take the number 1.56, and we move the decimal point 21 places to the right, and that would give us the full number. This is just a shortened notation for representing this. We also could see this if we're going to do a small number. In this case, we'll do a very, very small negative number, and if we log this out and then I run it with F5, we'll see that we see ‑2.1 and then e‑18. That means we take the number ‑2.1 and we move that decimal point 18 places to the left, and that would give us the number. Now, we get to also use this notation if we so desire when we're creating our JavaScript numbers. So, in this case, we could go through and say that we're going to create something num6, which is 1.2e+10. Now, if we wanted to, we could also log this out. Now, JavaScript will, by default, only use e notation when numbers get to a certain size, either, again, big or small. So what's funny is when we actually write this out down here to the console, we'll see that it's just showing us the full number. But again, I just wanted to showcase you can use that notation as well. Now let's start to get into some of the specifics around how big and how small of numbers can be properly represented with the Number type. So, one of the cool things is we have some values provided by JavaScript that we can utilize to help see what these minimum and maximum values are. So we're going to be looking at Number.MIN_VALUE, Number.MIN_SAFE_INTEGER, and then we'll do the flip of that with the maximum. So, Maximum Value, and then Maximum Safe Integer, and we're just going to go ahead and log all of these out to the console. Now these numbers are going to be represented for the most part in e notation, so I wanted to be sure you were familiar with that before we actually ran this code. So now I'll hit F5, and you can see here that we have values that are presented here. The minimum value is shown in e notation, but our maximum and minimum integer value, which, again, are just kind of mirrors of each other, one is positive and one is negative, those are shown without e notation, but then we also have e notation for that maximum value. So you can see here the limits of what can be contained. Now, you might say, okay, well, what do we do? If for some reason we need an integer, let's say, bigger than what is shown here, what do we do? Well, that brings us to our next type. So here we have BigInt, which is short for big integer, and it represents numeric values that are too large to be represented by the number primitive. Now, it is created by appending the letter n to the end of an integer literal, or by calling the BigInt function without the new operator and giving it an integer value or string value. Before we get too far, I want to remind you that we also have documentation for BigInt on MDN Web Docs, so you can follow the link on the screen to get access to that documentation if you need to go even deeper than what I am presenting here. Okay, with all that said, we'll get back to VS Code. So here within VS Code, I want to actually create a couple of values with BigInt. So here I'm just going to go ahead and create my first one. Now, you might be surprised. I just put the number 1 and the letter n. Now, because the type can handle very, very large integers, it doesn't mean you have to have large integers. We could, in this case, choose to represent a BigInt with just the number 1, but we also could create something really big if we wanted to. So if I scroll back up, for example, and I look at num4 that we had to find up here, the one that gave us the warning, what if I wanted to actually make that a BigInt? Well, I can do that down here, but I'm going to do it in a way that probably surprises you. So here I'm going to go through, and you'll notice that I'm using these underscores. Now this might seem like, oh no, this is something completely new. Really here, this is just something that exists for us and not for the JavaScript engine. In between these digits, those underscores are going to get completely ignored, but this can help if we're dealing with large numbers and we want to actually have this represented in a way where we can read it. So here this is going to be another BigInt. Now, unfortunately, when you're creating BigInts, you cannot utilize e notation when you're creating it, so you'll need to actually write the number out. Now, this gives us two types that we're working with, Numbers and BigInt. I need to tell you here that you always need to use the Number type unless you know of a specific use case that requires you to use BigInt. A vast majority of the numeric operations and some of the tools that are provided by the engine really are designed to work with the number type and not BigInt. BigInt is actually a more recent addition into JavaScript, but it is there if you do have use cases that require larger integers than the Number type supports.
So now we're going to be understanding both null and undefined, and this will factor in quite a bit to the code that you're going to write in JavaScript. So, at a high level, you need to understand JavaScript undefined and null both represent something without a value, but for different use cases. So if you were to define a variable, but you didn't assign it a value, that is said to be undefined. But if you want something to not have a value on purpose, you can choose to assign it to be null. So before we dive in and look at this in VS Code, let me just remind you that you can visit the Web Docs. So here I have the link for undefined. If you scroll down to the bottom of this page, you'll see that there is a link to get to the page on null as well. Now these don't have the kinds of properties and methods that were used to seeing on some of the other data types, but I do want to have this here so that you can review it. But, as always, we want to get to the code, so let's pull up VS Code. So here, within VS Code, the first thing I'm going to do is I'm going to create a new file. So here we're going to start off with one particular use case. So here we're going to go in and ask the question, what happens when you don't give a variable a value? Now this is not something we have done yet. Every time we've used the let keyword or the const keyword, we have given a variable value. But if you use the let keyword here, you can choose to initialize it and then, at a later time, go in and assign it a value. So what happens though, if we were to go in and actually log out the variable at this point? Well, that's exactly what we're going to test out. So I'll hit F5, and we can see here that we end up with undefined, right? Now this is the description of the type that we have right now for this variable. A matter of fact, we can utilize a new kind of global function we haven't talked about yet called typeof, and it will actually tell us the type of a particular variable. And in this case, if we were to go through and run this, we would also get that to come back as undefined. So that is the type. However, because we did use the let keyword, we could go through here and give this a value. And then if we went through and logged it out, it would no longer be undefined, but it would be the value that we assigned to the variable. So that is undefined. But we also have situations where we want to actually purposely set a variable to be nothing or an empty value. So let's use the example here of our employee directory that we're going to be building out over the course of this course. Well, here, let's say you're talking about the CEO. Well, everyone else in the company will probably have a manager listed, but the CEO doesn't have a manager. So in this case, we would assign their manager to be null because it's empty, they don't have one. So in this case, we could then go through and say, okay, let's actually log out manager and let's see what the value is. So if I run F5, here we get back null. Now, we'll also go through, and I'm going to show you and explain one of the quirks that we occasionally see within JavaScript. If you remember, way back in Javascript: The Big Picture, I mentioned that JavaScript is always backwards compatible. It's one of the thing that makes JavaScript a bit different than other languages, and it also is kind of required because JavaScript is the language of the web. So here one of the things we're going to see is when we say typeof, we would expect it to return null. But in this case, it's actually going to return the typeof as object, and this is one of the big quirks that you'll see. It really shouldn't be object here, you can go do some research online, but because this was what it said at the very beginning of JavaScript, it is actually preserving that so it doesn't break anything that is dependent on this returning object. So again, it's not really an object in this case, but because JavaScript is consistent with itself over time, that's the value that we get back here. But just as a reminder, we have two different things we're considering here. First, if you have something that hasn't yet been assigned, it is undefined. But if you want to purposefully set something to have an empty value, you would leverage null.
So now we're going to talk about JavaScript objects. Now, as a reminder, just as with everything we've talked about so far, here we do have the documentation on the MDN Web Docs that's going to walk you through JavaScript objects. So again, you can dive in here if you have any questions after I finish going through the demonstration utilizing JavaScript objects. But let's go ahead and jump into VS Code. So here within VS Code, I'm going to create a new file. Now here, I want to show you a couple of different ways to go in and create a JavaScript object. Now, the first way that I'm going to do here is what we would actually refer to as an object literal. So here, obj1, and we just use this curly brace format. Now, the other approach that we could take is to actually use what we would call the constructor approach, which is going to use the new keyword. So here we can say new Object and then just put parentheses and our semicolon. Now, with this, I would say that the first approach, the object literal, is what you will generally see, and it's what I would recommend you use whenever possible, and I'll show you why here in just a minute. But let's now talk about how we actually add some values onto our JavaScript object. So here I'm going to go in and add a string. So we'll say firstName, because, again, we're going to eventually build out this employee directory. So here we're just going to say, well, this object represents an employee. So here we'll say .firstName, and this is using dot syntax. We'll then add in our value, which, in this case, would be David. Then we could go in and do the same thing for lastName. We could then go in and add another data type. Let's say we'll add a Boolean. So we'll say, okay, is this an active employee? We'll say true. But we don't have to just stop there. We could do a date as well, which you've seen me do already in this module. And we could even go in and add in a number, let's say the number of vacation days this particular employee has. Now, all of these are now part of the JavaScript object. So if we were to go in, we could say let's just log this out. Let's see what this looks like when we actually run this. So I'll hit F5, and we'll see here it basically adds this in in between those curly braces, we can see all the different values. We see the property name, colon, and then whatever value it is. So, that's really what we need to know to create an access properties on an object. But what we can also do is we can actually populate an object when we create it, if we're using that object literal syntax. So here I'm going to keep the curly braces open, and I'll go in and say, okay, firstName, and I'll give it the value, and then I'll add a comma, and then I can do lastName, give it the value, and add the comma. Then I can go in and say isActive, startDate, just like we did before, and you'll notice here that I can just enter in all of these in line so that as I'm creating the object, these different properties are getting populated. And what you'll notice here when I run this, if I hit F5, is that we get the exact same thing as what we had before. Okay, now let's talk about how we can get to those properties once we create an object. So, first of all, we can go in and get the firstName by just saying obj3.firstName. That's using the dot syntax. We also could go in and utilize this other syntax, which is our square bracket syntax. Here we put the name of the property that we want to access inside of quotes. So if I run this, just as you'd expect, I get the correct first name and the correct last name from my object. You can use either of these different ways to access those properties. Now, as a note, you can actually put spaces inside of your property names because it will take any valid string. But in this case, if you do that, if you put spaces in, you have to utilize the square bracket syntax. You can't use that with dot notation because that would be invalid JavaScript syntax. Now let's talk about how we delete properties from an object. So if we want to do that, we can utilize the delete key word and then just say, you know, what we're actually trying to delete. So in this case, obj3, which is the name of our variable that's holding our object, and firstName. So now if I go through and log it out, we'll notice that it starts with lastName. It doesn't start with firstName anymore because we have removed that. Now, another thing that we can look at here is what happens if we try to access a property that we don't have, like middleName, for example, which I did not enter in. Now, what do you think it's going to return here? I'm curious to get your thoughts because we just learned something in a previous clip that might give you a hint. So here I'll run it, and we see that this comes back as undefined. And that's what we would expect here because this value hasn't been defined. You might say, well, I thought it would actually throw an error and blow up the particular execution of our JavaScript file. Well, in this case, with objects, that is not the case. Now you are correct, if you just picked some random value and you were just saying that this was a variable that existed and we had never even initially created it, then yes, it would throw an error, but in this case, with objects, it won't; it will just return undefined. Now let's talk about the difference between passing by reference and passing by value. So objects are indeed passed by reference. That means that when I create a variable, like my obj3 variable, for example, it isn't the variable itself is actually just a reference to a block of memory. So let's see how this plays out. So here I'm going to say obj4 is equal to obj3. And you might say, okay, that makes sense. So now we have two variables that are both the same object. So what would happen then if I said obj4 and I set the lastName to be Smith instead of Tucker in this case? Well, what do you think this would return? We're going to go back and get obj3.lastName. Do you think it's going to be Smith or Tucker? Let's run it and see what happens. Well, now you can see it returns Smith. And you might say, well, wait a minute. We said obj4.lastName should be Smith, but you're telling me obj3.lastName is now Smith. Why is that? Well, the reason is, is because obj4 and obj3 are both pointing to the same block of memory. And so when we choose to update one, it is going to update the other, and this is very different from working with primitives where we actually pass the value. So, in the case of a string, we're actually passing the string around, and if we do that, we can change it on one variable and it wouldn't affect another. But when we're passing by reference, because it's pointing to the same block of memory, we would affect the other, and that's what we mean by the fact that objects are passed by reference.
So now we're going to talk about working with dates within our JavaScript code, something that I have only introduced up to this point. Now I want to remind you, we do have documentation for the Date object JavaScript, and you'll be coming to this page quite a bit if you're doing a lot of JavaScript code. Now as a note here, it does let you know on this page that the TC39 committee, which, again, is the committee that manages the ECMAScript specification, is working on a new Date/Time API. So you can dive in and click on those links and learn more about what the future of dates in JavaScript is going to be. But as a reminder, JavaScript is always backwards‑compatible. So, everything I'm showing you today will always work even once this new Temporal API is put into place. So, let's jump in to VS Code. So I'm here within VS Code, and the first thing I'm going to do is I'm going to create a new file. Now here within this new file, I first want to start off by demonstrating some different ways that we can create dates within JavaScript. Now, as a note, when you create a date, it represents both a date and a time. So, this value is a specific point in time, not just a given calendar date. Now you'll see that if I run this, this is going to be F5 here to run it, and you're going to notice that something strange happens. I included the date of 2023‑01‑01. You would think this would be January 1st, 2023. But in this case, we see it return of value of December 31st, 2022 at 7 p.m. Well, why is this? Well, it is assuming that I am passing in values for UTC. And when I actually log this out, it's going to convert this to my current time zone, which is the Eastern Standard Time Zone. And so because of that, it's going to move it back 5 hours because I'm 5 hours behind GMT. Now, let's look at another way that we could create a date, and this is the way that we have used up to this point. So here, I'm going to pass in a date string like you would write it if you were writing it somewhere. And in this case, it's going to assume that that is already in my current time zone. So if I were to run it here, we could see that that does return January 1st, 2023 at midnight. Now there's another thing that you'll need to do when you're creating JavaScript applications is you'll sometimes need to create a date for the current time. If we use this new keyword and we say new date and we don't pass in anything, then it's going to give us the date for the current time. So if I run that, you'll see January 27th, 2023 at 9:54a.m., and that's the time I'm actually recording this clip. So another approach here is that, to be very specific, we can utilize some standard formats for date strings. So here is a standard format that gives us the date and the time and the time zone all within one string. And so if we use a string like this, we can be sure that it's going to return the exact value that we specify. So you can see that down in the debug console. But we can also do it a different way. We can utilize the date constructor and pass in values for all the different elements of our time. So, for example, if I ran this, you could see that this returns January 1st, 2023 because I've passed in 2023, 0, and again, that is the zero‑indexed month. So in this case, zero would mean January. One for the first day, 2 for 2 a.m., 30 for 30 minutes, and 4 for 4 seconds. So, that shows you how to utilize the constructor and pass in each of the elements individually. Now, if we have a date, we can take advantage of some of the methods that are provided by JavaScript to access the pieces of data that are contained within that date. So, for example, we might want to get back the full year with getFullYear. Or we might want to get back that zero‑indexed month with getMonth. Now again, that means for 0 it's going to be January, and December would be 11. Now next, we could get the particular day of the month. So if we want to get back that value, we can call getDate. Well you might say oh is that zero‑indexed? No, that's not zero‑indexed. That would be a bit too confusing. So, in this case, if it is January 1st, this value would return the number 1. So next, we can also do something like getHours, so the current hours. So if it's 2 a.m., this would actually return to us the number 2. So if I run all of this, you'll see all of these values return just as I mentioned. Now, these are not the only methods. You can go through and look on the documentation page and find all the different methods that you can execute on a given date object, and this will actually return all the different elements that make up your date. But we need to have another conversation, and that is we need to talk about how dates are actually represented within JavaScript. And the way that JavaScript stores this is milliseconds from the epoch. Now the epoch is, in some ways, an arbitrary date that was chosen in the past, January 1, 1970, and JavaScript tracks the number of milliseconds from that point, from midnight on January 1, 1970, until the date that you have. So, if you had an earlier time, then it would be a negative number. If it's after that, it would be a positive number. And you can get this number of milliseconds by calling the getTime method on your Date object. So if I run that here, we can see a pretty big‑sized integer that is going to be the number of milliseconds since January 1, 1970. Now I can prove to you that that's actually what it's calculating from because let's create another new date. We'll call this one date6, and I'll pass in the number 0 into the date constructor. Now what this is going to do is this is going to create a date that is 0 ms from the epoch, so exactly on the epoch. But I'll need to get back a string that is actually for UTC. Again, for Greenwich Mean Time. So I'm going to say date6.toUTCString. Now if I run this with F5, you'll see that it returns January 1st, 1970 at midnight with Greenwich Mean Time. So this is how JavaScript actually stores the dates is by calculating those number of milliseconds from the epoch.
