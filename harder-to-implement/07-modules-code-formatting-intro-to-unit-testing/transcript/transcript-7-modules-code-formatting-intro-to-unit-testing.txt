If you have done any exploration of JavaScript on your own since you've started this course, you have likely seen that JavaScript applications don't exist within a single file, like some of our examples. So let's look at a few of these scenarios. First, you may want to split your application up into multiple files, and most all applications do this. You can organize your code around areas of the application and then export specific functions and variables to be available outside of that file. And we will walk through how that works within this module. Second, you may want to leverage some of the great code that already exists in the JavaScript ecosystem. Node.js has its own package manager, npm. This eases the process of integrating third‑party code into your JavaScript applications. I cover the concept of package managers in JavaScript: The Big Picture, so if you want to understand more about the concept of the package manager and what options you have in the JavaScript world, feel free to head back and watch that clip. Now using Node with npm, you can install any of the third‑party packages that exist that cover common scenarios that you may run into. If we take a concept like data validation that we included in our application earlier, that is actually solved by a handful of npm packages that have already been written by other developers. All of this is possible because JavaScript has the ability to work with modules. And we have seen the capabilities increase in this area as JavaScript has matured. I want to introduce you to two different module standards, ESM and CommonJS. The first one that I want to discuss is CommonJS. This standard was created specifically for Node.js since JavaScript didn't have its own module implementation at that time. It uses the require method to load in modules, so if you're working with Node.js code, you will likely see this used quite a bit. This was the standard in Node.js for a very long time. It uses an export variable in the module to determine what is exported outside the module code. Next up, we have ESM, which is short for ECMAScript modules. This is the standard that is now a part of the ECMAScript specifications. Instead of using the require method, this approach uses the import keyword, and instead of using an export variable, we use the export keyword to define which elements should be exported from the module. This is now the standard in Node.js, although CommonJS modules can still be used. Since ECMAScript modules are the standard moving forward, we have been using them, and we will continue to use them throughout the course. With that being said, let's look at an example of both in action. First up, let's look at a CommonJS example. Here, we're using the require method to pull in the system library from Node.js. In addition, we are also importing a local file that contains JavaScript and a JSON file. If I wanted to export the function I have defined, I can specify that this function is a member of the module.exports object. So, that's CommonJS in a nutshell. Next up, we have ECMAScript modules. Here, we can use the import keyword to pull in third‑party modules, as well as local files. One of the differences here is that we can specify what specifically we want to pull in using this approach. There are some variation to the types of imports we can do, but I'll cover that more later in this module. I can also pull in some JSON using an import statement. If I wanted to export a function, it is as simple as using the export keyword to indicate that it should be available outside of the module. Now that you have a basic understanding of modules, let's jump to what will become a superpower for you, using third‑party modules.
So next, we're going to dive into this essential topic of using third‑party modules. Now I want to introduce some terms and concepts to you that I mentioned all the way back in JavaScript: The Big Picture. First of all, we have the package manager. And in terms of software development, a package manager is a tool that enables you to install and manage software written by other developers into your own software projects. Now when we're talking about package management within JavaScript, we really have two different pieces of this. We have the client that we use to go and search and fetch the projects that we want to integrate in, but we also have the registry that actually hosts those projects. So when we're talking about the clients, what we're referring to is npm, which comes with Node and what we will be using and have used already in this course, and we have others like yarn and pnpm. But in terms of registries, there's really one that we look to, and that is npm. Now they do have their public registries, and organizations can also have their own private registries that you can leverage. Now over the course of this demo, we're going to be doing a few things. First of all, we're going to be searching for available packages in the npm registry via the npm website. Then, we're going to be creating a package.json file using the npm CLI. And finally, we'll actually be installing and using a third‑party module using the npm CLI. So let's dive in. So I'm here on the npm registry website. Now as a note, npm is actually now owned by GitHub, which is now owned by Microsoft, so Microsoft actually controls this ecosystem. So here, if I want to look for packages, let's just say I've heard of a package called chalk. Now this package enables me to be able to go in and do some cool things in terms of styling the things I output to the console. Because to be honest, up to this point in our project, our outputs have been kind of pretty bland, all just a single color and hard to maybe distinguish certain things from others. So let's take a look and see if this project could help us in that way. So here, if I click into chalk, we'll be able to see a listing for it. In addition, we can go and actually view the documentation that's included in the README file for that repository here on the npm site. Now, you can see this is a pretty popular library with over 242 million weekly downloads. But here, you can get a sense of what it enables you to do. You can get a basic sense of the API and how to work with it. Great, I think this is what we're looking for. So let's figure out how we can go to a completely blank project and integrate this into a JavaScript application. So I'm here in VS Code, and I don't have anything yet in this project other than just my .vscode directory. So the first thing I want to do is I want to create my package.json file. Now we could create it by hand, but that's not recommended. Part of what is included with the npm CLI tool is the ability to initialize, or init, a new package.json file. So here, I'm going to type npm init, and now it's going to walk me through some questions. So first, we'll give a package name and I'll just hit Enter, which will leave the default as examples. And then we can enter in a version number. In this case, I'll leave the default of 1.0 0. Then I'll give it a description. Then we can leave the default entry point, and I'm not going to enter in a test command or a Git repository or keywords or an author or the license right now. I'll just accept the default. And it gives me a preview of what my package.json file would be. I'll just go ahead and hit Enter, and we will see that our package.json file has been configured. Great. Now the only thing I'm going to do here is I'm going to go in and do what we did earlier. I'm going to make sure that for type, we actually have this listed as module because this will enable us to use ECMAScript modules, which is what we want to be doing for this project. Okay, great. That is the first step. Now from here, I want to install the library that we just looked at, chalk. So to do that, I'm going to run npm install chalk. Now, I'm going to do one more thing here because I want this to actually be listed in the dependencies in my package.json file. So I'm going to specify that I want to save this because I'm not just installing this for the moment. I want this to actually be included with my project. Now that I've done that, you'll notice that my package.json file is updated to list the dependency that we just installed. And now that we have that installed, which we can tell because we have both a node_modules folder and a package‑lock.json file, we can now use it within our project. But I want to talk to you a minute about how these different files and folders interact with your source code repository. Now, if you were creating a Git repository for this application, you would check in your package.json file, you would check in your package‑lock,json file, but you would not check in your node_modules folder. So you would need to configure your gitignore file to handle those appropriately. Now, the next thing I'm going to do is I'm going to create a new file, and we'll just call this index.js. Now here within this file, the first thing I'm going to do is I'm going to actually bring in this third‑party library. Now in this case, this uses what we would call a default export, and so this would be the way that we import it in. Now, the next thing I want to do is I actually want to use this. So in this case, I'm going to do a console.log statement, and then I'm going to specify that I'm going to use a blue.bold logging statement here for First Name and then we'll just use the normal output for David. And then I'll do something similar here for the next line. We'll do Last Name, and in this case, we'll do green.bold just to help you see what's possible with this particular library. Great. So I'm going to save it, and then I'm going to go down to the terminal, and I'm going to go ahead and run my file. And you'll notice that I do indeed have blue and green in the output in the console. Now, I'm not going to walk you through how you would integrate this in with the project we've been building. You can absolutely use the knowledge that I've given you here through this and other modules to be able to do this yourself. And you can go and look at the documentation for chalk on the npm site or on the GitHub repository for that project to learn how to do even more with this library.
So before we can move forward with creating a multi‑file JavaScript application instead of the single‑file application that we're dealing with currently, we need to have a conversation about exporting values when working with ECMAScript modules. So let's just jump right in to VS Code. So I'm here in VS Code, and this file is exactly at the state it was in at the end of the last clip. Let's say that we want to use this new third‑party library, chalk, that we've brought into our application. And let's say that we want to isolate some of our logging functionality into another file, so it doesn't have to be in our index.js file. Well, we can do that. So the first thing I'm going to do is I'm going to just simply comment out this code because we're not going to be using it. The next thing I want to do is I want to bring in some sample data, so I'm going to bring in a sample employee. This was actually pulled out of the sample JSON file that we've been using up to this point. Now, the reason I'm doing this is because I want to create some logic that will loop over an employee object and log out the data to the console, but utilizing some of the colors that we can use with chalk. Now again, you can go through and do a lot more with this than what I'm going to do, but I'm showing you here how we can isolate this logic in a different file in our application. So now that I have that in place, I'm going to create a new file called logging.js. Now the first thing I'll do within this file is I'm going to bring in our library, chalk, that we've been using in this application. Now the next thing I'll do is to create a function, and this is going to log out an employee object. Now this should look somewhat familiar to you. This is very similar to what we're doing within the log employees function of our custom JavaScript application. Now with this being said, we're going to use this in our index.js file. However, if we try to go and import this now, it would fail. And the reason is because this function is not included in the exports from this JavaScript file. We can fix that by adding in the export keyword here at the beginning of this definition. Now that this is in place, we can go back to our index.js file, and beneath our chalk import, we can actually add in the import for logObject. And we're specifying that it's coming from our logging.js file. Now that we've brought that in, we can actually use it. So I can go down here below where I'm defining that employee object, and I can add in a call to logObject. Perfect. So if I go down to the terminal and if I were to run the application, we can see that indeed it does output the way that we have intended. The keys here are listed in blue, and the values are listed in a bold gray color. Perfect. Okay, now that we have that in place, I'll tell you that we don't have to just export and use functions. We can also do variables as well. So what I'll do is underneath my import, I'll go ahead and add in a variable called numEmployeesLogged, so this will keep track of the number of employees that we've logged out here within this application. And then I'll simply increment that value at the end of the logObject function. So now if I go back over to my index.js file, I can't use that yet because I haven't included it in the imports. In this case, if I add in a comma, I can see that it's going to suggest that I bring in numEmployeesLogged, which is what I'm intending to do here because that is included in the exports. So now what I could do is I could maybe log out another employee. It'll be the same data, but we'll use this just as an example. But then after that, we can go through and add in another logging statement that will tell us the number of employees logged, and we'll output that in red, and then we'll do the gray bold for the actual number that will come back from that variable. So now if I save this and then run the application, we can see that indeed it does output the two different employees, and then it tells us we have logged out two different employees. Now with this information on how you can export functions and variables for use in multiple files, in the next clip, we can jump over to our application and begin to add some organization.
So now we're going to create a multi‑file JavaScript project out of our currently single‑file JavaScript application. And I hope that you've seen that as we've built more and more into this application, it becomes a little trickier to navigate that index.js file. I wanted you to see that first hand so that you could understand much of the value that comes with dividing your application into multiple files, where you take common concepts and apply those into a single file and then pull them into whatever main file you're executing. So let's dive into VS Code and see this in action. So I'm here in VS Code, and the first thing I'm going to do is to run npm install. Now this application is in the exact state it was in at the end of the previous module. Okay, I'll close the terminal for now. We'll come back to that in a minute. But if we look through this file, there's several areas that jump out as good candidates for isolating to their own file. The first that we'll take a look at is how we load and write data to the file system. So let's go ahead and create a new file called data.js. Now, within this file, we're going to take everything that we've done so far in terms of loading and writing data, we'll remove it from our index.js file. In addition, the import statement for bringing in the node:fs module, we're going to remove that as well. Now, I'm going to move over to my data.js file, and we'll start by bringing in that import for the node:fs module, and then we'll go ahead and paste in those functions that we had from our index.js file. Okay, now that we have these functions in place, the first thing we need to do to make them available outside of this file is to mark both of them with the export keyword. Now that we have that in place, we need to think a bit about inputs and outputs. So here our loadData function is accessing the employees variable. Well, that's not in scope here in this file. So what we'll do instead of actually assigning that variable here, what we'll do is we will just return the parsed values from our JSON file. Okay, that's one thing. But now in the next function, here we're also using the employees array to write the data to the JSON file. So here we can simply include that as a parameter that we'll need to pass in. Okay, now that we have this in place, let's go back over and take a look at our index.js file. So another area where we could probably isolate some of our logic is around how we're dealing with the currency data. So here we have two functions, getCurrencyConversionData and getSalary. So I'm going to take these and I'm going to cut them as well. Then I'm going to create a new file called currency.js. Now here within this file, we can also bring in those functions that we pulled from our index.js file. Perfect. So now that we've brought these in, we need to designate them both as exports. Now, in addition in thinking about inputs and outputs, we have the same situation here. We can't assign currencyData at this point because that variable is not in scope, so we will simply return the result of our HTTP request. Okay, now if you look down at our getSalary function, you'll notice that it's telling us that currencyData is not currently in scope. So here, we need to include this by making it a parameter that gets passed into the function. Okay, so now that we have these two additional files in place, let's use them within our index.js file. So here, I'll go to the top of the file, and we're going to bring in the functions that we've just created by using import statements. Great! Now if we scroll through, there are a few areas where we will need to update the application. First, if you remember, we now need to pass our currencyData to our different getSalary calls. So here, we'll go ahead and add that in. Now as I scroll, the next thing that we'll need to do is when we add an employee, we'll need to be sure that when we call writeData, we pass in our employees. Great. Now the next thing that we'll need to do is actually update the way in which our application starts up. If you remember, we have a promise chain that executes. We call loadData and getCurrencyConversion data simultaneously by using Promise.all. What we need to do is take the results of those and actually assign those to the appropriate variables. Now, when you're calling Promise.all, it will return an array of results, and that array will correspond to the order in which you passed those promises into Promise.all. So in this case, we're going to assign employees to the result at the 0 index and currencyData to the result at the index of 1. Now, after this, we'll return the result of our main call, which will keep the promise chain going and will catch any errors that happen in any of those functions. So now that we've isolated these two areas of our application, let's test it out. So now, I'm going to run search by ID, and we'll go ahead and search for ID 55. And in doing so, you can see that we do successfully pull back an employee from the directory. We can see that we have successfully been able to isolate the logic around loading data from the file system and writing it back to the file system, as well as getting all of our currency conversion data because we're seeing everything properly represented here in the console output.
So next, we're going to implement a very common use case when you're programming in JavaScript, and that is we're going to choose to change from working with our local file where we're storing everything as JSON, to moving that data into a relational database. Now, specifically, we're going to be working with SQLite here, because that's going to give us a very simple way to set up a database quickly and get to working with it. However, if you're new to working with relational databases and SQL in general, don't worry, there's a great course here on Pluralsight that will help get you up to speed if you have any questions about the things we're going through. So here in this demo, we're going to do several things. First of all, we're going to be installing a third‑party module, and technically two different ones here, to work with SQLite, and then we're going to be converting our persistent data storage in our application to use SQLite instead of that local file. And then we'll be verifying our ability to store and access the data in SQLite, so let's get right to it and let's jump into VS Code. So I'm here in VS Code, and the first step I'm going to take is to install the two modules that we'll need to interact with SQLite, and those two modules are sqlite and sqlite3. Now, I realize the naming is a little confusing here. SQLite 3 is the actual driver that we'll be using to interact with the database, while SQLite is a wrapper that goes around that driver. Now, if you're not interested in using SQLite, you can find modules to work with about any relational database that you can think of, MySQL, SQL Server, Postgres, you can find npm modules that will help you interact with those databases, whether they're local or whether they're on a server somewhere else. But I'm going to go ahead and install these modules. We can see that those have been added and installed, and so now I'm going to close the terminal so we can start working with SQLite. Now the first thing I'm going to do is I'm going to create a new file because we want to isolate our database logic into a single JavaScript file. Now, here within this file, we'll need to pull in some different imports. First of all, we're going to need to import the SQLite driver. That's what's really doing the hard work of interacting with SQLite for us. And then we're going to pull in one method from the sqlite package, which is open. Now the first thing we're going to need to do is to create a table, and we'll actually check this every time we're interacting with the database to be sure that our table has been created. So here, we'll create a new function that's going to be an async function, and it's going to take one parameter, which is going to be the connection to our database. And then we're going to create a SQL query that's going to say, if this table doesn't exist, we need to create it. Now these fields should look very familiar to you. They're pretty much the data that we have been working with throughout a vast majority of this course when it comes to our employee database, with everything from our ID, which will serve as our primary key, and then we have our email, first name, last name, our USD salary, the local currency indicator, the start date, and then whether or not the particular employee is active. And what we'll do is we'll actually run this query at the end of this function, and so if we wait for this to complete, it will verify that our table has been created. Now if you notice here, we're using the phrase IF NOT EXISTS in SQL, so it will only create this table once. It won't write over our data if it already has been created. Great, now the next thing we need to do is we need to create a local variable that's going to store the connection to our database, and then a function to get that connection, so we'll call this _db. Now, I want to point something out here, you might have noticed this that I'm not exporting any of the things we've created so far in this particular JavaScript file, and that's intentional. All of these are things that are meant to be executed only within this particular JavaScript file. We'll get to some exported functions here in just a minute. Now if you notice here, we're passing in a file name when we're opening our connection to SQLite. It will actually store all the contents of our database in a file here within our project directory, and you'll see that work here in just a minute. But just as we open the connection, we also need to have a function to close our connection to the database, and you'll notice that all of these are async functions. These are all things that need to go interact with the database and then report back once they've completed. Okay, so this is really all of the behind‑the‑scenes plumbing that needs to happen for us to interact with SQLite. Now if you think about it, there are two things that we need to program this to do. The first is to get all employees and the second is to insert a new employee. So let's start off by getting all the employees from our database. So I'm going to go ahead and create another async function, but I'm going to specify that this one needs to be exported. So here, we're going to go through and get a connection to our database and then we're going to run a query that will get all of the employees from our employees table, and that's the table, again, that we created at the beginning of this file. Now, we need to go through and do some adjustments here. So one of the things is is that SQLite doesn't have a native Boolean data type, it's going to just store it as an integer. So when we get that back, we're going to need to convert that integer back into a Boolean. So here, since we're getting back an array of rows, which is basically an array of employees for us, we'll actually utilize the map function on our array to go through and create a new array where we've converted that isActive value into a Boolean. Then we'll close the connection and return the employees. Okay, now we've got one more function to create here within this file, and that is going to be how we insert a new employee. Now, I'll go ahead and tell you that this function is pretty long, but that's because of the way that we're defining our SQL statement to actually insert that into the database, so don't be scared by this. If you understand how SQL works, you'll be able to understand this. So here, we're going to create another async function called insertEmployee, and we'll take in that employee object, the same employee object that we've been working with before. Now here we're going to specify that we want to insert this into our employees table, and we need to first go through and list all of the columns that we want to insert this data into, and these will be all the properties on our employee object that we've been working with so far. And then we need to specify that we're going to insert parameters when we run this for each of those values. Now, we need to say what those values are. So here we're just going to list them out in the same order that we listed them out in the SQL query above. So we'll go through id, email, first name, last name, that salary, the localCurrency code, the employee.startDate, and notice we're converting this to a string here instead of a date, and we're converting that isActive property to a number. Okay, we'll then get our connection and then we'll run our query with all the parameters that we've entered, and then we'll close our database connection. Okay, so we've done a lot here to enable our interaction with a relational database, but we're only going to have to tweak a few things to have this work within our index.js file. So I'm going to click into this file, we're going to go ahead and go to the top, and the first thing we're going to do is we're going to actually write over this import statement because we don't need it. We're going to be using our database instead of the local file. So we'll import the two functions that we created, getAllEmployees and insertEmployee, and remember, we had to mark both of these exports for them to be available for us here. Now, the next thing we need to do is we need to modify one function. Now, previously, when we called getNextEmployeeID, we made the assumption that we already have some data, but in this case we don't have any employees in our system yet, so we'll need to account for one additional condition, and that is if we don't have any employees yet. If that's the case, we'll simply return 1 for the first ID. Okay, now the next thing we need to do is we need to get the employee's email address when we're adding in a new employee. We actually haven't entered in that prompt yet. So I'll go ahead and add this in as well. Now we could create a custom validator to truly check if it's a valid email address. We're not going to do that in this case, but if you want to build that out yourself, feel free. Now the next thing we need to do after this is we need to change what we're doing, because we're not going through and actually writing the data utilizing the same function that would store it to a JSON file. In this case, what we're going to do is we're going to add in a new call to our insertEmployee function, and here we'll pass in the employee object that we've entered in. Okay, we're almost done. We need to do one more thing. So I'm going to scroll here to the bottom to our startup, and instead of using our loadData function, we just need to change this out for the function that we just created, which is getAllEmployees. We actually don't need to change anything else because it's going to return an array of employees just like the loadData function did. Okay, so with just those few changes, we should be able to see our application work just like it did before. So let me go ahead and bring up the terminal. So I'm going to start by running the add command. Now one of the things I want to point out is that our database was just created, because it initially tried to fetch all of the employees, and it did that successfully, but we just didn't have any employees in the system yet. But you'll notice that we now have a data.sqlite3 file in our project folder. Okay, so now let's go through and create our first employee. We'll say David Tucker, and we'll specify an email, david_tucker@globomantics.com. Now we'll set the start year here to be 2003, and we'll say that the start month was March and the day was the first. We'll say that this is an active employee who makes $67,000 a year, and their local currency, we'll say, is Japanese yen, so we'll say that this particular David Tucker is working out of the Tokyo office. And it actually completes without throwing any errors. So, we should be able to go back and list all of our employees. So I'll go ahead and run the list command, and we can see that, indeed, we get back a David Tucker with an id of 1. We can see that we get back our USD salary, our local currency, we can also see our start date and the isActive status, and we can see the salary properly formatted in both U.S. dollars and Japanese yen. So here we have successfully implemented data storage using a relational database with third‑party modules to manage the connection between our application and SQLite.
Congratulations on making it to the final module here in JavaScript Fundamentals. I want to introduce a few concepts to you in this module that come into play once you are actually building JavaScript applications. As we get into teams to build solutions, we need to make sure that our code is consistent and that our application works as intended. Now as you likely suspect, we have some software best practices and tools that can help us address these two concerns. Now here in this clip, we'll be addressing the second concern, making sure our application works as intended, and to do this, we're going to explore the concept of unit testing. Now unit testing is where individual components, or units, of an application are tested to make sure they behave as the author intended. These tests are usually written for a specific unit testing framework and it is common for these tests to get executed every time code is committed to a project to ensure that the new code does not break application functionality. And unit testing is just one type of testing that complex software projects may leverage. Now, one of the concepts that I introduced in this description was the unit testing framework. And in JavaScript, we never have a shortage of frameworks, and this is just as true when it comes to unit testing. We have popular tools like Jest, Mocha, Jasmine, AVA, and Vitest. Now here within this learning path, we will be providing an entire course to help you learn unit testing for your JavaScript application with Jest. Gabriel has a great course on this topic, and I highly encourage you to check it out. Now, I have to break some news to you. We aren't going to be writing any unit tests here in this clip, but I didn't want to leave you empty‑handed. If I were to open the browser here, I have a personal project called lambda‑micro that I created as a part of another Pluralsight course. Now this code base has tests built into it that run every single time that I check code into this repository, and this helps me make sure that I am not breaking anything before I release it into the world. Now I have my local copy of this project pulled up in the terminal. To use Jest to execute this entire collection of unit tests, I can simply run npm test. Now if you want to see how that was configured, you can take a look in the package.json file. Now, once the tests have completed running, you can see that it ran 64 individual tests organized into 7 different suites. Now there is another concept I will also introduce as a part of our discussion around unit testing, and that is code coverage. Now, code coverage is a metric designed to tell you how much of an application is actually tested by the collection of unit tests that have been written for it. Now there are different approaches for calculating this metric, but it is generally assumed that a higher code coverage number is better than a lower one, as it means that more of the application is tested by the unit tests. Now, if I were to go back to the terminal, it calculates the code coverage for each individual file, as well as the project as a whole, using four different criteria, statement coverage, branch coverage, function coverage, and line coverage. Now we won't dive into the specifics of any of those, but I wanted you to be aware of why there are different numbers listed here in this report. Now in addition to lambda‑micro, most popular open source projects also have a collection of unit tests, and you can find a repository that you're interested in and see how they wrote their tests. That's one of the many benefits of open source code. Oh, and don't forget to go in and check out Gabriel's course. He spends over 90 minutes covering this topic in depth, as opposed to the 4 minutes that I'm spending here introducing it.
In addition to unit testing that we covered in the last clip, we also need to think about how we can help our code to be consistent. Now, I've mentioned at several times throughout this course that JavaScript enables you to do things in different ways. Think about defining variables with let and const versus the var keyword, or using single quotes or double quotes for strings, or function expressions versus arrow functions, and the list goes on and on. And if your development team has everyone doing different things, it's going to be really hard to have a consistent code base. But there are tools to help you with this, and this generally falls under the category of what we would call code linting. Now, linting is the automated checking of your source code for programmatic and stylistic errors, and this is done by using a lint tool, otherwise known as a linter. Now, a lint tool is a basic static code analyzer, and it's important to reduce errors and improve the overall quality of your code. And using lint tools can help you accelerate development and reduce costs by finding errors earlier, and that sounds like a very good thing. Now when we're talking about JavaScript, there's really one tool that rises above all the others in this area, and that is ESLint. Now, ESLint statically analyzes your code to quickly find problems, and it's built into most text editors, and you can run ESLint as a part of your continuous integration pipeline. Now, we haven't talked much about continuous integration, but if you remember, I mentioned that you can run your unit tests every time code is checked into the repository. Well, you can also check your code style with the linting tool in the same way, and this helps make sure that somebody's not checking in code that goes against the styles you have agreed upon as a development team. Now, let's look at integrating ESLint into our application, so let's jump over into VS Code. Now one of the things I want to mention is that there is ESLint support directly built into VS Code if you're using the ESLint extension. So you can go under the Extensions tab, and you can search for ESLint, and you'll notice that we have one from Microsoft here that comes up right at the beginning. Now, I already have this one installed, but if I didn't, I could install it here with just the click of a button. And one of the great things about this is once we have our rules configured for ESLint, it will show us all of our errors directly in our code editor. We don't have to go run them separately, which you'll see what I mean by that here in just a minute. But I mentioned something here about rules, and ESLint comes with some default rules. But developers can publish their own set of configuration rules for ESLint as an npm package, and several companies have done that, and one of those, just to give an example, is Airbnb. Now, Airbnb's configuration is called eslint‑config‑airbnb, and we can see that it's fairly popular at 3.8 million weekly downloads as well. But you can see that we have one command here that we can use to install this, and so let's go ahead and head back over to VS Code and let's put that in place. So I'll go ahead and paste in the command that we saw, and I'll go ahead and install this particular package. Now you don't have to understand everything that's going on behind the scenes with this command to be able to use it in your project, but we're actually using another npm package called install‑peerdeps, or peer dependencies, to help go through the process of installing all the packages we need to utilize this. Okay, now that we have that in place, we're now ready to start working with their config. Now, we could use ESLint to generate a config file for us, but in this case, I'm just going to create one. And it can actually take multiple formats. In this case, we're going to use the eslintrc file. So here, I'll go in the project and I'll say New File, and we'll call this .eslintrc. Now here, we don't have to do a ton of heavy lifting to make this work. We simply need to specify that we're going to extend that airbnb configuration that we have already installed into our project. And that's all we need to do for now. Now what we can do is we can go in and actually run ESLint against our code base. So here, I'm going to run npm eslint, and I'm going to specify that it should use the current directory. Now, we're going to see a bunch of output here, so don't be startled by that. And here we can see we have 123 problems, and if we look here, there's several different examples. Some of these might make sense and some of them might not, and that's okay. We can see, for example, that this ruleset prefers that strings use single quotes instead of double quotes. Also, we get warnings here for using console statements. Now some of these things we care about and some of them we don't. Some of them are just about style, for example, whether or not we put a space before and after our square brackets for creating an array, and some of them directly have to do with functionality, but we can go ahead and we can fix a vast majority of the issues that we're seeing. If you notice here in the terminal, it says that 92 errors are fixable with the ‑‑fix option. So here, I'm going to run eslint, but pass in the command line option to fix the errors that it can fix by itself. And, indeed, we can see that that has completed, and now we see that we only have 30 problems left. Now, we can adjust the rules here to some extent, because we heavily use things like console logging, so we can configure within our eslintrc file what rules we want to actually utilize and which ones we don't. So in this case, I'm going to specify that there are a few things that we're going to turn off in terms of the rules that come with the Airbnb configuration for ESLint. Now if I were to go back and run eslint, we can see that now we only have 7 problems. So, let's dive in and take a look at those problems, because I want you to see how ESLint is supported within the editor here in VS Code. So first, we'll go to our index.js file, and if I scroll down here to the bottom, you'll notice that we have an error here because it says I should use something called array destructuring. So, I'll show you how we can do that. I just didn't show you this particular syntax yet. We could rewrite the two lines that we have there this way. We can remove the two lines that we had previously and do it all within a single line of code. And this is just another way of creating variables based off of data that's contained within an array. Now, the next errors that we see here are on lines 43 and 50, so if I scroll up, we'll actually see those, and if we look in the sidebar, we also have a representation of those warnings presented here so we can easily see at a glance where the problems are. Now here, it's preferring that we would use an arrow function in this case instead of an unnamed function expression. So here we'll simply replace these values, and then we'll save. Now, we'll notice that as we do that, it's giving us yet another issue here, and that is that basically we don't need to use a return statement, we can put this all in a single‑line arrow file. Now I'm not going to fix this just yet, because this is something that ESLint can actually fix itself. The next thing I'll do is head over to the next two files where we have errors, and that is our database and currency.js files. We'll start here in database. Now, the first thing it's going to say here is we don't need to actually use the await keyword when we have a return statement that is returning a promise, that it's actually redundant. There's actually nothing wrong with including it, but we don't need it here, so the ruleset says we should remove it. Okay, so that's one thing. The next thing happens here on line 28, and in this case we actually chose not to use this parameter. We're instead using that local variable that we've defined, _db, so I can remove that. Now we have one more thing to fix. If I go under currency.js, you'll see here that we also have another redundant await keyword, so I'll remove that. Now with that being said, I should be able to go in and run eslint ‑‑fix, and it should fix that one arrow function that it wanted on a single line, and we can see that now we don't have any errors or warnings included in the output, so that even though we had over 100 issues to begin with, we have quickly integrated in the fixes that we needed for those. Now, I want to show you something else that I think is pretty powerful, and that is that ESLint can actually run ‑‑fix every single time we save our files. So here what I want to do is I want to create my settings file for VS Code, and here within this file, I simply need to add in the following configuration. We're going to say that on save we want to run ‑‑fix for ESLint, and we want to specify that this is for JavaScript files. Okay, let me show you this in action. So now I'm going to go back to my index.js file, and let's say for example here this logging statement that I have, let's say that I'm using double quotes, and it's going to tell me, hey, this prefers single quotes. Well, now all I have to do is actually save the file, and in doing so, it will automatically be fixed by ESLint for any of the types of errors or warnings that ESLint can address by itself. So hopefully this just gives you a small window into what's possible when using ESLint to make sure that our code stays consistent to rules that we've defined.