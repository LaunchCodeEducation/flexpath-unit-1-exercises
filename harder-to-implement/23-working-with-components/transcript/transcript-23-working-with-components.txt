Course Overview
Course Overview
Hi, I'm Peter Kellner, and welcome to my course, Working with Components in React 18. I'm a part‑time docs writer for Microsoft, part‑time author, part‑time conference organizer, and full‑time learner. This course is all about working with and designing React components. The right design ensures that your components will efficiently communicate with each other, handle errors gracefully, and only render when they have to. Good design means less bugs and lower maintenance costs. You will learn the techniques and develop the skills needed to make sure your components have that right design. Some of the major topics we will cover include passing data, props and state, between components, handling errors thrown in components using error boundaries, improving React app performance, including what's both actual and perceived from an end user, and how the new server components will affect your component design going forward. Before beginning this course, you should be familiar with programming in modern Javascript and especially working with functions. I also recommend you have completed an introduction to React course or have equivalent knowledge. By the end of this course, you'll feel comfortable designing full featured, real world, high quality React components. I hope you'll join me on this journey to learn all about React components in this course, Working with Components in React 18.

Implementing Components in React Apps
Welcome
You may be wondering, should I spend the next couple of hours watching a course on React components? Components seem simple enough. Well, I can absolutely assure you that the way that I built components many years ago is very different than the way that I build them now. For example, how do you pass props between components? Do you use the spread operator? Do you pass them by individual value? Do you not pass them at all? Maybe you should use context instead. Those are the kind of questions that we'll answer in this course. What about handling errors in components. Do you use error boundaries? Do you pass UIs with your error boundaries? Again, things we'll talk about in this course. How about optimizing components? Do you optimize your components? Should you optimize your components? What does optimizing components really mean? Again, we'll talk about that in this course. I'm Peter Kellner, and my goal in this course is to share with you what I know about working with React components. Let's get started now in this course, Working with Components in React.

What Are Components?
Before starting, there's some important version information you need to know. First, this course was created using React 18, and second, it's 100% applicable to React 18. Components are independent bits of code that each serve some special purpose. They typically can be brought together to form a complete application and in the context of React, a web app. In addition, components are often designed to be reusable, meaning that they can be used over and over in the same app, as well as used in multiple apps, leading to efficiencies in coding. In React, their purpose is typically to render some HTML. In addition, because components come together in a hierarchy or tree, they can also be used to render other components. A React app, by definition, always launches a single component, and that component may or may not have one or more children components. Those children components can also have children and so on and so forth. In this course, we are ultimately going to build a React web app that manages a to‑do list. The component hierarchy for that app is going to be something like this. It will have a root element called ToDoApp that will have a single child component, Layout. Then, as children to layout, a Header component, a general purpose container, and a StatusBar component. The rest of the component hierarchy is something like we have here that represents our full ToDoApp. Of course, our app itself doesn't look like a tree of components, but instead a fully functional UI‑friendly web app running in a browser. Comparing the hierarchical view of components to the running Web app is somewhat intuitive, but not completely obvious where all the component boundaries are in the web app. Roughly, the ToDoApp component is a full running web page. Directly inside that is the layout component, which has three components inside it, first the header on top, then in the middle the ToDoContainer, which itself contains a toolbar, a form for adding new ToDoItems, and the ToDoList itself. The final component in the layout is the status bar. It contains as children the ToDoList stats, as well as a component that is used for clearing the completed ToDoItems. How we make this app work, including all the UI details of every component and the communications between them to make our app function, will be covered throughout the rest of this course. For now though, let's take a step back and really look at what makes up a React component, as well as the very basics of how components work together to share both data and functionality.

Deep Dive into a Single Component
The React ToDoApp manager that we will ultimately build in this course is composed of, as you'd expect, a full hierarchy of React components. Let's talk in detail about just one component in this app to help better understand what components in React really are and how to use them. Specifically, let's look at the ToDoItem component that is just a single entry in the ToDoList that has both the functionality to toggle a to‑do item from not completed to completed, as well as rendering the HTML that indicates what the status of that to‑do item is. In other words, when we click on any ToDoItem component, the text toggles between showing normally and showing with the strikethrough font, meaning the task is completed. Let's build a single component now, which is just contained in a JavaScript file named ToDoItem.js. Start with the simplest implementation of a function component I can think of, which is just a function defined with a name that returns some trivial JSX. JSX is a special React syntax that when the React app builds converts to real JavaScript. If you're not completely familiar with JSX syntax and how it works, I suggest heading over to my course here at Pluralsight, What is React, where you'll learn more about that. Adding some functionality to this component, let's start out by creating a simple, primitive JavaScript variable named text and assign it the value, Wash clothes, then add it to our return JSX as a simple JavaScript expression that renders that value. After that, create a second Boolean variable named completed and assign it to false, meaning that the single ToDoItem has not been completed yet. In our CSS, we have a completed class that simply adds the text‑decoration: line‑through to any font that is displayed. Let's assign that completed class conditionally to the div surrounding our text using a ternary expression. Only assign it when the variable completed is true. Now, we've got a simple component with two hard‑coded values that render a single ToDoItem with an arbitrary text value and completed status. This component now by itself is not very useful. To make it more useful, we need to have it receive, as passed‑in values, our text string to display, as well as the completed status of the ToDoItem. The way React works is that function components, by definition, receive a single parameter, typically named props, that is a JavaScript object. It has properties that represent each of the passed‑in values. From a coding perspective, we can replace our hard‑coded values we assign to the constants, text and completed, to props.text and props.completed. This way, we now have a completely generalized React function component that takes in what we will going forward refer to as receiving props. We can easily change these two assignment lines to one using JavaScript destructuring syntax and then take that one step further by replacing our variable name, props, passed in with two receiving props inlined in the function definition. That's it for creating a simple standalone React function component that renders a single ToDoItem and shows it with the strikethrough font to represent if it's completed. Sometimes people will refer to components like this as a pure function component because they are guaranteed to render the same output based on what values or props are passed in. However though, the definition of pure starts to get a little vague when introducing a local components state to a component, which is what we'll talk about coming up shortly.

Multiple Ways to Pass Parameters to Components
There are multiple techniques available to you when calling a component, as well as how you receive those attributes basically as the props parameter in the call component itself. In the previous clip, we started out by specifically using the variable name, props, as the single parameter passed into our ToDoItem function component. We then ultimately replaced that with two destructured values, text and completed. To help explain parameter passing better, let's add another passed‑in value, another Boolean, to our ToDoItem function component named important. In the rendering or JSX of this component, let's preappend an asterisk to our render text if important is true. Now, let's take a brief look at what it looks like to include our ToDoItem component in a component hierarchy. Create a new bare‑bones function component named Index, then have it return as JSX a rendering of our ToDoItem. Pass, as separate attributes, a string value for text, a Boolean value for completed, and also now a Boolean value for important. That's pretty much as simple as it gets for a parent to render a child component. Notice also that in this render we have explicitly referenced every attribute that we can possibly pass to our ToDoItem component. If, for example, we had left out the important attribute, then in our ToDoItem component, important would be received as undefined, and then when our ternary expression, important ?, is processed, it would take on a different meaning. That's because of the untyped nature of JavaScript. Our check for important is no longer for a true/false, but instead the evaluation of important will return undefined, which will cause our empty string to render. In this case, that functionality is correct, in other words, desirable because likely if we did not pass in an attribute to our ToDoItem in JSX, we would not want the item to be displayed as important with a pre‑appended asterisk. However, this is somewhat a precautionary tale because there may be cases where undefined or false mean completely different things. So it's really important you understand your code and what to expect from it in order not to introduce unexpected bugs. Moving on from that, let's look again at how we pass the three attributes from our parent component. You can imagine that if we had a lot of attributes, this code could get really complex and overly messy. One way to work around that is to instead of passing every attributes separately, create a single JavaScript object, let's call it ToDoItem, and then assign each property value, which would correspond to each attribute. Then, using the spread operator, pass all the values at once. That's simply {...toDoItem}. No change is needed to the ToDoItem function component itself, as the spread operator effectively passes the values in the exact same way as before. One thing to be very aware of when following this pattern for passing attributes is that it's easy to accidentally pass in to the function component data that you did not mean to. Say in your ToDoItem object, you had a property named secretData that you may not have meant to pass into your ToDoItem component, but it would be there anyway. If in the case of passing secret data by accident into your component had you used the non‑structuring syntax that is just props as the passed‑in parameter, had you accidentally rendered something like the JavaScript expression, JSON.stringify(props), you would have accidentally exposed secret data to the browser. That's never a good thing. Incidentally, that's also a good reason to use destructuring syntax for receiving props when you build your own function components. That way, you're less likely to expose secret data. There's certainly no guarantee of security by using destructured values as receiving props, but it certainly is a better practice for the reason I just explained.

Adding Time Travel (State Changes) to a Component
React is more than just about simply rendering static HTML from a function component that depends on passed‑in props. That is the reason React is called React is because components need to be able to change what they render when things happen. I get that things happening to a component is a vague statement. Sorry about that. Let me explain. The component we built so far that renders a single ToDoItem as completed or not is basically timeless, meaning that the HTML rendered from the component will always be the same for any given combination of passed‑in data, props that is. The way we can make our component change what it renders is to introduce a changeable value that we'll call local component state to our component along with a method that changes it. Then, we need a way for our component to execute that new method. Because our React app is running in a browser that already has an event model associated with it, we need simply to figure out a way to plug into events fired from our browser. For this example, there are two different events we are going to plug into. The first will be the event that is fired after a browser page renders, that's the same as the DOM load event, and the second is to hook into an event listener assigned to an onclick event. Let's talk about the after render situation first. Let's say we want to append the current time to a ToDoItem right after the component first renders. The way to do that is first to create both a new state value associated with our todo text property passed in and also a setter method to change it. That's exactly what the built‑in React API call, useState, does. We call it passing in an initial value we want to set our new state to, and then it returns to us in array whose first value is the new todo state, and the second value is the setter method that we call to change that. Then, we update in a render section text to textState so the changing value renders. Internally in React, when we call that setter method, React senses that this component needs to rerender, causing that rerender and the component to return new HTML based on the current state value passed to the setter. Now that we have the ToDoItem text as changeable, we can write the code that gets executed after the component renders. To make that happen, we call the built‑in React method, useEffect. We pass to that, as the first parameter, a function that we want to execute after the page renders. For the second parameter, we put a dependency array, but by leaving it empty means the function only executes when the component first renders. In that function, let's just put a simple call to our setter, setTextState, that appends the current time of day to our existing todo text. Now when this component gets executed, it will first show the ToDoItem text just like before, then immediately after that it will render again with the time appended to that text. Our React app is no longer timeless. As soon as we launch our app, which we'll call time 0, the HTML renders with just the passed‑in text. A moment later, which we'll call time 1, the React engine replaces that rendered HTML text to include the current time. Let's now move on to our second case, that is the case where the component rerenders based on an event. As our component only has three values, the text of the ToDoItem, its completed status and its important status, let's take a look at changing the completed status. Just like for textState, let's replace our completed status, which doesn't change with one that does by creating completedState and setCompletedState as returns from useState. Also, update the return or the render to use that. Let's add to our div container an onClick event listener that toggles the value of completedState. That way, later, after our ToDoItem component renders, a browser user can click on the ToDoItem itself, and we can execute some code that will cause our component to render with a toggled value of the ToDoItem's completed status, in other words, text with a line through. This is what the running component would look like. Clicking on the text field, the text gets replaced with text with a line through. Clicking it again, it goes back to normal. That's all it takes to convert a timeless component to one that has a time factor built into it, in other words, one that has state.

Course Expectations
Let's talk about what to expect from this course. Components are the building blocks of all real‑world React web apps. Link components are just associated JavaScript functions tied together. That is, they are good coding design patterns in JavaScript implemented with helper functions provided by the React library. The intention for this course is to improve your abilities and techniques for working with components in React apps, making your apps easier to build, easier to maintain, and most importantly provide a better experience for your browser users. Coming up after that, you'll learn all about a To‑do List manager React app built specifically to demonstrate component patterns in React. The course will cover details regarding the specifics of how that app is currently coded, as well as how it's built with the React toolchain, Next.js. The todo manager app is currently written with primitive and unoptimized code. That will be the starting point in this course for improvements. Following that, in the module titled Global State Sharing and React Context, you'll learn all about improved ways to share React state between components and specifically how React context gives us a great way to share data across different application parts. Apps don't always work as expected. In the module, Handling Errors and Debugging Components, you'll learn how your apps should handle those unexpected errors, and you'll also learn techniques for debugging your components along the way. Although React apps may be functionally perfect, that is they meet all the requirements laid out and technically they may be good enough for our browser users, they still might not meet user expectations, that is in terms of how they perform with your customer's browsers, as well as how the user perceives that performance when parts of the app do things that just can't be sped up. To provide users with a better experience in all cases, there are things that can be done in the UI to make the experiences better like, for example, adding progress indicators. In this module, Improving Component UI Performance, you'll learn techniques to do just that. Finally, in the module, Introducing Server Components, you'll learn what server components are in React and how they can significantly improve the performance of React apps. Specifically, server components take advantage of the new concurrent rendering engine in React such that different parts or components in apps can be rendered from the server after other components are completely rendered. In other words, with server components, React apps can partially render HTML directly from the server with no client‑side intervention. And then when slower or more complex components are ready to render, they also can be rendered directly from the server. Server components can make a huge difference to browser user's perceived React app performance. Let's move on now to exploring our todo manager React app that we'll use throughout the course.

Exploring Our React Application
Introduction
Hi, this is Peter, and welcome back to this module, Exploring Our React Application. As this course is all about improving how you use React components in your app, I'm assuming you already know the basics of components. We're starting now with a completely built out and functional To‑do List manager app that includes a full hierarchy of React components. In the previous module, we have already talked some about the app. Specifically, we've talked about component communications that support marking todo items as complete, as well as displaying their updated status. We also talked some about the relationship between components, showing them in a tree view to get an idea of how all the components in the app are connected. Let's move now to the actual React code that this todo app is built with. The tree view showing here is close to the actual component hierarchy, but not quite right. Going forward, any time you want to know about the component hierarchy, I strongly suggest you use an object viewer like the one in Visual Studio Code that we will use in this course, and then you'll know from the source code exactly what the hierarchy is. By the end of this module, you'll not only have a good understanding of how our todo app fits together, but also assuming you want to code along with me, you'll be able to easily build this app and continue to enhance it throughout the rest of this course. You don't need to code along to get a lot of value from this course, but if you do, you'll have everything you need.

The App Source in GitHub
All the source code developed in this course can be found in the GitHub repo at the URL github.com/pkellner/pluralsight‑working‑with‑components‑in‑react18, separated by dashes. Navigating to any of the modules, for example, m6, we have folders that represent the code at the end of each clip in the module. At the start of each module, there's a clip 000, which represents the starting point. Typically, that's the ending point of the last module. A shortcut that is relatively unknown and very useful in GitHub is that when you have navigated to a folder, you can press the period on your keyboard, and you will quickly be taken into an online view of the repo. That is basically Visual Studio Code online. From there, you can easily view all the files. You must be logged into GitHub though for this to work. Next.js does assume you have installed the latest version of Node, which you can get at the node.js.org URL. Make sure you have the LTS version installed, which is recommended for most users. The easiest way to get these files from GitHub onto your local computer is to click on the Code button on the repository page and then the menu choice, Download ZIP. That ZIP file will expand on your local hard disk with the same file structure as is in the repo. You, of course, can also use git clone to make a copy of it.

Up and Running with Visual Studio Code
When you have the source code copied to your local computer, you can use any code editor you are comfortable with to work on it. Throughout this course, I'll be using Visual Studio Code, as it's free to download and use. You can find it at the URL, code.visualstudio.com. Let's bring up VS Code and open one of the folders in our downloaded source. How about m3‑clip‑000? There are a lot of extensions in Visual Studio that help with programming in React and especially working with components. If you browse to the Extensions menu that's on the left sidebar, then type react into the search, you'll find lots of them. Personally, I prefer to just use what is built into VS Code rather than any of the extensions, but I can see where many of them could be really useful. There is, however, one that I do use a lot, and it's not so much about coding, but more about viewing your component hierarchy. It's not perfect, but it does add a lot of value, and I will be using it occasionally throughout this course. It's called the Sapling extension, which you can find again by searching, and I suggest you install it. Its single purpose is to give us a visualizer into the React component hierarchy. I've already installed it, which is why at the bottom of my left‑side menu, there's a picture of a tree view. Clicking on that prompts me to choose a file from which to start viewing the component hierarchy. Let's choose App.js, which is in our src folder. As you'll see coming up, when we talk about what minimally you need to know about the Next.js toolchain, app.js is basically the root element of our React app. Once done, it shows us our app component, which we can drill into by pressing the right arrow next to it. That takes us directly to whatever file is holding our app component. In this case, it's just /src/app.js. Expanding the app tree with a plus symbol, then expanding all the nodes below that, we get a view directly into our full component hierarchy. This is similar to the tree view I showed earlier in the course, but the nice thing about this is it's 100% accurate because it's looking into our actual source code. Clicking on any right arrow button takes us directly to the source of any component. You can also see what file that particular component is in by looking at the breadcrumb view below the tabs. And, of course, you can change the file viewer any time by clicking it in the sidebar menu. The Sapling extension gives us a great way to look at our app. Instead of having to figure out where things are based on the files we put some place in our project, we can navigate to them directly by how they are inherited throughout our app.

The Next.js Toolchain Basics
To be successful in this course, you do not need to know much about the Next.js toolchain. In the React 18 path, there is a dedicated course titled React 18 With the Next.js Playbook where you'll learn a lot more details about integrating React with Next.js. What is helpful to know about Next.js is that basically it connects React, which is just a JavaScript library, to what's necessary to debug and publish React apps to a browser. You don't absolutely need a toolchain to build React apps, but it's highly recommended that you use one as the details necessary to put one together yourself will take up a lot of time and likely not add much value to your end product. For this course, rather than starting from an empty project and coding all the React components from there, I'm going to start with a built‑out React app that was initially created using the recommended command from the Next.js docs. That command works because I installed the latest version of Node from the URL node.js. I was able to execute the command npx create‑next‑app@latest to scaffold out a basic Next.js app that includes the necessary files like package.json and others. When I did that originally, I had to answer this series of questions. It's very important that for the examples coming up, that the question titled Would you like to use the app router? (Recommended) was answered No. That implied that I was using the page router in our examples going forward. Had I answered yes, that would have implied that I wanted to use the app router, meaning that all my components would be, by default, server components, which, by the way, can't manage React state or DOM events like click events. They are very useful though, and I'll talk more about them near the end of the course. For now and all the code coming up, we are focused on react client components that do work directly with the browser DOM and can manage local component state. So, back to VS Code and our project viewer that points at the starting point of our to‑do manager React app. Specifically, that's the path in our GitHub repo and your local file system /m3/m3‑clip‑000. Next.js builds based on what's in package.json in the next.config.ks files. Looking at package.json first, notice that in the dependencies are the two React libraries, react and react‑dom. But more importantly, next, which is our Next.js build chain. Notice also that we have four predefined scripts that we run by typing npm run and then the script name. For example, to run our app in development mode, here is what we need to‑do. First, open a terminal prompt inside VS Code. That's just by choosing the menu Terminal, then New Terminal. Just like any other Node app, we need to install the Node packages by typing npm install. And then, after a few seconds, to run our app, we just execute the first script name dev. And we do that by typing npm run dev at the terminal prompt. It lets us know that we now have a local web server running at localhost:3000 serving our React app. Browsing there, you can see our running to‑do app. As you'd expect, since we are running in development mode, any changes we make to our source code in VS Code will immediately be reflected in the running app in our browser. The scripts build and start are used for creating production builds of our app, and lint is just to optionally check the quality of our code. The other file Next.js uses is next.config.js. This is basically a way to override and add features to the build process in Next.js beyond what is there by default. In our case, we are just making sure StrictMode and swcMinify are set to true. What's important to understand when using Next.js for the first time is that the JavaScript files at the root of the /pages folder are meant to be standalone default exported components. They get rendered as the root element of our React app that is launched when the browser is directed to the URL localhost:3000/ and then the file name without the .js of what's in the pages folder. Looking, for example, at the file /pages/demo1.js, it has just a single default exported component named app, and it renders a simple page. After we've run npm run dev in our browser, we can enter the URL localhost:3000/demo1, and that component will render. If we leave out the file name, let us just browse to the URL localhost:3000, then the file index.js is what becomes the root element of our app. Notice all we have in this file is a redirect to the component app in our /src folder. It's simple as that. That's really all you need to know to run our to‑do app using the Next.js toolchain. There is a lot more to Next.js, but for now, this should get you started.

Review How the Todo App Works
Let's take a couple of minutes and briefly review the UI of the todo app. When the app first loads, it's set to the light theme, which we can toggle by clicking on the theme button. The search field is empty, the three‑way toggle is set to All, meaning all todo items are displayed, and the Important checkbox is unchecked, meaning show all items. At the bottom, there's a refresh button used to reload the data from the persistent store, a JSON file, and a button to clear all todo items. On the far right are some useful counts. To add a todo item, enter into the text field with a placeholder text saying Enter To‑do, then press the ADD TASK button. That action dynamically creates a new To‑do item and added to both the persistent store, as well as the To‑do list below. To edit a To‑do item, you click on the pencil icon, and that copies the current To‑do text into the input form above, which has a text field and a button. Pressing the UPDATE ITEM button replaces the item in the todo list with the new values. Before updating, you also have the option of updating both the important and completed Boolean values stored with each todo item. You can also toggle a todo item by clicking on the item itself in the list. Finally, clicking on the trash icon removes the current item. That's basically it for using the UI. Next up, a brief code walkthrough, including the component layout.

Code Review of Our Todo App
Because our plan for this course is not to develop a full React app from the ground up, but to instead start with a running app that is reasonable in size such that when we enhance it with new capabilities and features, it's just not a simple demo kind of app. That is, this app will likely be similar to something you might build in real production yourself. To that end, let's review this app so as we extend it through this course, you understand how it all fits together. Let's start at the App component, which we can think of as the root element. As we have some common state that is used throughout the app, we'll declare that right up front so we can pass the state values and their setter methods to children components as necessary. The three state values we are tracking are the displayStatus, which represents what todo items to show based on whether they are completed, the important state, which is a Boolean indicating whether only important todo items should be shown, and lastly, some text, which matches todo item descriptions for filtering just those. As of now in our app, the only React context we are using is the TodosDataProvider. That gives us full access to a REST server that incidentally is built into our app here that provides the full CRUD, create, read, update, and delete data services in our todo app. In the clip after this, we'll do a code review of how that provider is implemented, but for now you can think of it as just a black box of data services for our todo app. Let's start out with our layout component first. Our data provider surrounds our complete UI by way of the Layout component. Navigating to Layout, notice it returns or renders a Header component, children components, which in this case is just one, ToDoListWithToolbar, and a footer component. The header is very simple with just a toggle theme and a title and the footer, though a little more complicated because of it having to count the items in different statuses, it's nothing complicated, just more detail work. Back to our App component. The children of Layout is only one component, ToDoListWithToolbar. The reason it's organized like this is so that the toolbar, which contains filter criteria for the To‑do List, needs to share that with the To‑do List itself, which is included inside the todo manager. Navigating to that component, you can see it includes an edit form, which is what we use to add and update todo items and below that, the todo list itself. Viewing that component, it's the workhorse of the app in that it renders all the todo items. There are a lot of details here I skipped, but again nothing complex and certainly nothing I'd expect you to have difficulty understanding, I suggest you take some time and review on your own the inner workings of this app so that as we modify it going forward, it all makes sense how things come together.

Understanding the Todo Apps Data Layer
For the purpose of learning components in our todo manager app, you absolutely do not need to understand how the data layer that manages our todo list itself works. All you really need to know is how to call the external interface to our data management layer. Let's head back to VS Code and specifically our App component. Notice that every UI component rendered is wrapped inside the TodosDataProvider element, which gives access to a context that contains everything needed to manage our todo app's data. Navigating to where TodosDataProvider is exported, that's our TodosDataContext.js file, notice what gets exposed from our context is todoList, which is an array of todos, the three CRUD methods, createTodo, updateTodo, and deleteTodo, as well as the status state, isPending, and an extra function, reFetch, which allows any component to refresh the todoList data from wherever it's stored, in our case, a JSON file, but that could just as easily be a database. To see one example of where this ToDosDataContext provider is used, navigate back to ToDoManager, and near the top, ToDoList is accessed with useContext, as well as all three CRUD methods. Without going into a lot of details regarding our full data layer of our app, let me quickly give you a high‑level overview of it. All the code is here, and if you are interested, you can dig deeper. Starting out, our context is a pass‑through layer to our useToDosData custom React hook. Let's navigate to it. That hook is also a thin layer to a more generalized React hook named useGeneralizedCrudMethods. All the hook useTodosData does is it adds a REST URL /api/todo, in our case, and then it renames the return data to todoList. Doing that makes it easier to have multiple uses of this generalized CRUD method in the same component. Though, in our case, we just have one, so it's really not necessary. Let's navigate now to useGeneralizedCrudMethods. Looking at the start of this code, you'll notice that it uses the popular npm package, axios, to retrieve and update data from a REST service. It also uses both the useEffect and useState React hook to do its work. If you review this code and don't completely get it, I suggest taking a look at one of my other courses here on Pluralsight, Using Hooks in React 18. I have a complete discussion around building custom React hooks that you'll find helpful. The only other thing to mention is that built into the Next.js toolchain is a technology called API Routes. What this does for us is it lets us define custom routes to the running server that are completely independent of our React app. That is, Next.js creates its own web server as part of what it does, and then API Routes allows us to have entry points that can be used to make our own custom services that run off of that server. If you look in the folder, /pages, /api / todo, there are two files there that completely create a REST server that our React app can use. To show what I mean, while our app is running in the browser, we can type into the URL localhost:3000/api/todo. And just like you'd expect, the built‑in REST server sent a get request to Next.js, then in return it responded with a full todo list as a JSON array. Also, as you'd expect, PUT, POST, and DELETE work the same. What is actually doing the server processing for the get request is in the file /pages, /api/todo/index.js. And the code that does PUT, POST, and DELETE is in the file /pages/api/todo and then {id}. Incidentally, those two files both update the db.json file on our server, and that is our persistent datastore. That means you can restart the Next.js server, and any changes you've made while you were running the todo app will be saved. In summary, the custom hook, useGeneralizedCrudMethod together with axios makes calls to our built‑in REST server, making our app able to run completely standalone without having to start a custom REST server someplace else.

Takeaways
I hope now you feel comfortable with the todo app that we will be working on for the rest of this course. As I said at the start, we have no plans to create a new React app to work off of, and at the same time, we want an app that you can learn from that's not just a simple toy app. I want to make sure you are building an app that is similar to something you might build in production. If you don't completely understand how this app works, don't be concerned. The rest of the course does not require you to completely get all aspects of it. This module was just meant to give you a running start to help make things more clear going forward.

Global State Sharing and React Context
Introduction
Hi. This is Peter, and welcome back to this module, Global State Sharing and React Context. A big part of building React apps is, without a doubt, sharing React state between components. As we've already learned, all components in React have the ability to store their own state or what we typically refer to as local component state. State updates in React are what drives our apps to update when actions like button clicks or render events happen. Let's talk about our todo list React app and specifically what happens when the theme toggles. That's when the input control at the top of the header component is clicked. That causes a function to be called that updates the local component's state in a root component, App that is. That makes the app theme state itself available to the App component, its children, and the children's descendants. We've shown this already in our app because, as we know, it's straightforward to pass data and functions through props. As an example of this, to make our theme available inside our TodoItem component, we pass down the theme prop from our App component to the ToDoManager component and then from there to the ToDoList component, and finally, to TodoItem. A possible reason we might want to do that is say in our TodoItem component we have a fancy animation that only works when the theme is in light mode. For that to work, we would, of course, need to know the theme state. That all takes care of propagating the state through our App component hierarchy, but what about changing the state itself in the first place? Since our input control, actually the button click event listener, that needs to fire, causing our state to update is in our ThemeToggle component, and our theme setter is in our App component. We need to connect those two to make the theme state update. We do this by passing the theme setter function from App to Header, then from Header to ThemeToggle. Now, our ThemeToggle component can cause a theme state update, which changes that state in all our other components. That does work obviously because our theme changed when we click the ToggleTheme button. However, there are multiple ways to improve our coding to cause that theme state in our app component to be triggered and thereby allowing all the components in the hierarchy that need that theme to have access to it. That's what we'll cover for the rest of this module.

Three Ways to Propagate State Between Components
Let's talk about three ways to propagate state changes between components. The first is by far the simplest and, as we'll continue to talk about, is to simply pass data and functions between components as props. That's exactly how all data passing works in the todo app we've already talked about and demonstrated. This often is the most straightforward and often the best choice. The second way is by using React Context, which gives us a really straightforward way to access data and functions to find in any React component and access by any of its children or nested children. It does this by not having to explicitly mention attributes when rendering children components, as well as not having to include them as the receiving props either. The third way to share data and functions is basically by using the technique known as higher‑order components, or HOCs for short. This works by creating a new component that you can share across your app. The component, by convention, usually starts with the word with, and the easiest way to use it is to replace your default export in your component with a call to the HOC first that passes in the component as its first and only parameter. This effectively wraps the component with our HOC. What this does for us is it creates invisible props that are now passed into our component that you can use as if they were passed in. Coming up, you'll learn what we need to know about these three techniques, as well as the benefits and drawbacks of using each one.

Passing State as props Between Components
You might be thinking that this module is all about better ways to pass state between components than simply using props. That is simply by passing state values and state setter functions through a component hierarchy as attributes, then in pairing components, getting them as receiving props. As is often the case, doing that can add a lot of complexity to your code, causing code maintenance and updates to be harder. Later, when you change your code, you may need to remember to include all those values and setter functions in components that are between the original parent component that pass the attribute values and the child components deep in the component hierarchy that uses those values Often, this is referred to as prop drilling, which doesn't sound like something you should be doing. However, it is the simplest way to pass props, and often the simplest way is the best. Let's talk about a way to make this easier and less error prone by taking advantage of the JavaScript spread operator. Let's start by looking at how in our todo app we pass both the current theme state, as well as the toggle function that changes that theme state. Our actual state value is instantiated along with that setter function in our app's root component, App that is. We also have defined here a toggle function that changes the state between light and dark. Then, when rendering our Layout component, we intentionally pass both the toggle function and the theme value as attributes. Of course, in our Header component, we ultimately consume both those values. Navigating to our Layout component, those values are received as properties of a single passed in object, props, then explicitly passed to the Header component as the attribute's toggleTheme and darkTheme. This is somewhat problematic for our toggleTheme function in that this component doesn't use that. It just passes it through. Often in hierarchies, none of the props get used as they pass through a component, and that's the classic case of prop drilling where it's easy to make mistakes in code by inadvertently forgetting to mention certain values passed through. Now, let's navigate to our Header component and look at our receiving props. DarkTheme is used to display the value of the theme toggled, and toggleTheme gets executed when the input control's onChange event is fired. How can we make this better? That is specifically by avoiding having to mention toggleTheme in our layout control. Let's navigate back to Layout and see what we can do. In Layout, rather than explicitly mentioning each prop we pass through, we can use the spread operator and pass all props received in our layout control to our header component. That's just by replacing the current attributes with {...props}. Now, all our passed in prop objects are passed to the Header component. It does, however, have a downside that we may be unintentionally passing props into our Header component we don't want, but it does make our code simpler. These are the kind of tradeoffs you need to make for yourself. Say in our Layout component, we want to pass more than just the props passed in as attributes to our header. Say, for example, we had hard coded a layout version number in this control and we wanted to display that in our Header component. All we need to do is first create a constant that holds the string value for our version, then just add it to our Header element defined as an attribute. There's no issue with passing all the props received in this Layout component, as well as new additional ones. Navigating to our Header component, we just add LayoutVersion as a receiving prop, and then in the render, add that value to display below our theme toggle input control. Bringing up our running app, we've now got this message in our header below our input control. And then toggling that control, the theme changes as expected, just like before. And the good news, we did not have to explicitly pass the state setting function toggle theme through our intermediate layout component. As you've seen now, maybe passing state as props is not so bad. And I'd argue that in many cases this is the best way to pass state between components, even when your components go beyond a single level of nesting.

Sharing State with React Context
The React Context API is a main part of the React library and is designed to share data from a component to all its descendant components. That is, all components, no matter how deeply nested, can share common data from a common parent component. The main benefit of React Context is that it provides a mechanism for sharing that data that does not involve passing information as props all the way down the component tree to where it's needed. You can think of React Context kind of as a global data share that you can instantiate at any level of a component hierarchy. Then, every level below that, in other words, all the children of that component and the children's children have access to the global data you assigned to that context. A powerful feature of React Context is that you can declare as many contexts as you want in an app, then children of those components have access to that particular context. Contexts can be overlapping, as they are completely independent, and also, you can easily have one context pick up data from another that is at or above it in the component hierarchy. React Context is very powerful and can significantly reduce the complexity of React apps by avoiding passing props through your component tree. It does, however, come with some drawbacks that includes promoting information hiding in that you have to remember what contexts are available to what components based on where the contexts are declared. It also can cause unexpected component rerenders possibly impacting your app's performance. Just mentioning a context in a child component can easily cause a component to rerender that otherwise would have no reason to based on your app's logic. In our todo app, we will only be adding a single context. That context will instantiate in our Layout component, and it will give access to our theme, that is whether the app should show a light or dark theme in every child component of Layout. In this particular case, that only means that the theme is not available to the root element, App, but is available every place else in our app. Coming up, we'll code this.

Implementing React Context in Our Layout Component
Now that we have a good understanding of what React Context is, let's implement it in our Layout component. We are, however, going to start out in our App component, which is the root element of our app. The reason we are here and not in the Layout component itself is that in order to give our Layout component access to our new context that we'll create is that we need to enclose the Layout component itself with a context provider element created from our context. If this sounds confusing, it will become clearer in a moment. Start out by importing the createContext entry point from the react library. Then below our imports, but still above our App component creation, call and export a call to createContext, making the new variable, ThemeContext, available to all components in our app, including this one. Since our plan is to create a global of sorts that includes the values we are currently passing into Layout, toggleTheme and darkTheme, first remove those attributes from Layout, then create a new object named value and design them as its properties. Scroll down to the render section of our component to where Layout is rendered, and surround Layout with our ThemeContext.Provider child element. Assign it the value, value. That gives Layout and all layouts descendant components access to both darkTheme and toggleTheme. The attribute value={value} is kind of weird, so let's replace that by not creating an intermediate object, and it's simply assigned to the attribute value the property's darkTheme and toggleTheme directly. Then, since we don't need the constant value anymore, remove that declaration. Also, ToDoManager currently takes in the attribute darkTheme, so let's remove that as we can easily access it from our ThemeContext if we need to. Having now our ThemeContext available, let's navigate to our Header component where we currently use both darkTheme and toggleTheme and get those values from our context instead of from the component's receiving props. Add the context imports at the top, that is useContext from the react library, allowing us to access a context and then ThemeContext itself that we previously exported from our App component. In our Header function, call useContext to get both our theme properties and remove them from receiving props, as we already now have them defined. I wouldn't say that this change made our Header component itself any simpler, but by not having to pass darkTheme and toggleTheme through our full component hierarchy does make this app feel simpler. Let's do the same thing to our Layout component. Navigate to it, add the same imports at the top for our ThemeContext, and then just like in Header, call useContext to get just our darkTheme value. Then from the use of darkTheme, remove the props prefix. Because we are destructuring the return from useContext, our code is simple because we only need to mention the context values we will use. However, keep in mind that if any value in our useContext return independent of what we are destructuring changes, React will force this component to rerender. That's the primary disadvantage of including context in our apps. It can easily negatively affect our app performance in a browser. Continuing refactoring this component, remove the passed through attributes derived from props to our Header component, as we now get those directly from our ThemeContext. The last refactor, though technically not necessary, is to destructure just the receiving prop, children, meaning replace props.children in our rendered div container with just children. I would say now this component is much simpler and cleaner than it was before. The real benefit though is not having to be concerned with what props are coming in and what props are used and passed through components to their descendants. Bring up a browser now to make sure our theme still toggles as before, and, of course, it does. We've now successfully added a theme context to our Layout component and both used it in that component, as well as our Header component without having to pass any theme info as props.

Move React Context into a Dedicated Component
In the last clip, when adding React Context to our App component, that component became pretty complex. Not only was it responsible for rendering the full app, including the layout, it also had to track the theme with state and provide the functionality, toggleTheme, to manage that state. Managing themes is pretty simple, but you can imagine with more complex scenarios putting all that into just a single component can get kind of crazy. Let's fix that by extracting the theme and toggleTheme into its own dedicated component that we'll refer to as a context component. Let's do the extraction, that is the refactoring out of our ThemeContext, from this App component. We already have a contexts folder, so let's add this new component there and name it ThemeContext.js. We're in the VS Code editor in side‑by‑side mode to make it easy to copy between windows as we create our new context component. Our plan will be to refactor the element currently declared as ThemeContext.Provider that receives as an attribute the single parameter value to a new component named ThemeProvider that has no attributes, but instead has code internally that stores local component state, the theme that is, as well as the management of that state, in our case, the toggleTheme function. Start out by scaffolding the ThemeProvider component, just like any other React component. Move over the export, ThemeContext, as now we want that in our dedicated context component. Move over our import of useState and createContext from React into our new component. Most importantly, copy over our state and state management logic. That means making available to the render of this component darkTheme and toggleTheme. We don't expose setDarkTheme. That's just used internally by toggleTheme. The next step is where the good part happens. We simply render the same as we rendered in our App component, and that's now ThemeContext.Provider, assigning the same value as was in App, an object with the properties darkTheme and toggleTheme. We now get to take advantage of the built‑in receiving prop, children. So, we need to explicitly add children as a destructured receiving prop and then return children as a JavaScript expression so that whatever component renders this will also have its children inside and rendered. Here's exactly what I mean by that. Just replace in our App component the element ThemeContext.Provider with the element ThemeProvider we created on the right. We don't pass value anymore, as ThemeProvider takes care of managing state for us. Since that is the case, we can remove the attribute darkTheme from the ToDoManager since we'll now be getting darkTheme from our context. We can remove from our App component the exported ThemeContext, as that's now in the ThemeProvider component, but we do now need to import ThemeProvider into our App component. Also, we no longer need createContext imported here, so remove that. That's all we need to do to fully extract our theme management from our App component. All that's left is a single rendered component, ThemeProvider that is, that fully now handles the state management for us. We do have two components in our app that use our ThemeContext. Now that we've moved the context into its own provider, we need to fix them. First, the Header component that has the themeToggle input control. Just change the location of the ThemeContext import, and that's all there is necessary here. Moving over to our Layout component, same thing, just the location of the import. That's it for extracting our ThemeContext into a new ThemeProvider component.

Promote Context Creation to Where It Is Used
I'd still say that our App component should not have to have any reference to our theme, as the only place the theme is needed is in the Layout component itself. The only reason we use our themeProvider in App is that in Layout, we reference our theme using the useContext React API call. Let's fix that by promoting or maybe easier to think of as lifting our theme context provider directly into the Layout component or at least the file, layout.js. Let's do it, and I'll explain what I mean by that. First thing, here in our App component, let's assume that we're going to get rid of the dependency on ThemeProvider. To that end, remove the ThemeProvider element in the return or render and also remove the import at the top. Now, our App component is even simpler and has one less thing to be concerned about. Navigating to our Layout component, let's naively go ahead and just put the ThemeProvider back here. First importing it at the top, then wrapping our Layout component, seemingly doing the same thing as we were previously doing in our App component. Let's see what happens when we run our app. Bring it up in a browser, toggle the theme, nothing happens. Our App theme does not toggle. Let's bring up the debugger console. Nothing there either. Very disappointing. The reason this failed is that the return of useContext is undefined. Unfortunately, our code here does not check that and because of the non‑typed nature of JavaScript and I have to admit maybe a little coding that could've been more defensive on my part, when darkTheme is undefined, data‑theme resolves in our ternary expression to light. Why does useContext return undefined? Think about the order the code executes in this Layout component. UseContext is called before the component returns or renders, meaning that our new ThemeProvider element that surrounds our div has not run yet. Now, I'm sure you understand better why I originally put the ThemeProvider element in our App component. That way, by the time this Layout component rendered, the ThemeProvider element had run in App. Luckily, there's an easy way to solve this without having to put our ThemeProvider back in our App component. It involves creating a simple passthrough component that wraps or includes all the returns of this Layout component wrapped in the ThemeProvider. That is, we'll create a new component hierarchy like this with a brand‑new component that we'll call in our layout because its purpose is to just be the part of the layout that is wrapped inside our ThemeProvider as a child component. The conventional way to solve this in React is to create a component inside our existing component file, layout.js that is. And since we don't plan to export it, we can simply name it Inner instead of InnerLayout and still be safe because it's not exposed as a JavaScript global. Here's how we can change our code to make this happen, Rename our Layout component to Inner, then create a new Layout component, as this is still the name being exported, and have it return our ThemeProvider element with just one child element, Inner, and use the spread operator to ensure that any parameters passed into this Layout component get passed to Inner. Lastly, remove the element, ThemeProvider, from our original component, which is now renamed to Inner. Back to our browser, toggling our theme, as we've done before, and it toggles as expected. Personally, I use this pattern a lot because I like keeping the React element, ThemeProvider, or whatever element I use to wrap my context in the same JavaScript file as the logic and rendering code of the component that needs the provider.

Enhance Components with HOCs (Higher Order Components)
When first learning components, it's easy to put too much programming detail into each component. It takes time to get the hang of building lots of small components and sharing state data between them using both React props and React Context. Another very useful technique we can use to share component state is to leverage higher‑order components, also known as HOCs. What are HOCs? They are simply just React components that instead of taking in a props object, they instead take in another component, a React component that is, as the first parameter. The return is just a copy of that same component with extra receiving props added. I'll explain what that means in a moment. How do HOCs enhance a component? That's really straightforward. They do that by adding invisible properties to the props object passed in to the new enhanced component. Let me explain by creating a simple example of an HOC that enhances a root App component to manage whether that component should display with a light or dark theme. Since we are using the build chain, Next.js, let's create a file named demo2.js in our pages folder. That way, we can browse to localhost:3000/demo2 to see it running. First, let's create a simple React functional component that allows us to toggle its theme between light and dark without any special code that is not using an HOC. Start out with just a simple component that renders a Bootstrap div container and export it, letting Next.js know that this component is the one we want launched when the browser browses to localhost:3000/demo2. Since we know we need to store local component state to indicate whether the theme should be displayed in light or dark mode, add a call to the hook, useState, to create a Boolean value, darkTheme, which if true, means to display the theme in dark, otherwise light. Have it return the theme setter as the function, setDarkTheme, and initialize the starting value of darkTheme state to false, meaning not the darkTheme. Add to our div container a CSS attribute, data‑theme, that our CSS understands to mean that if it's set to true, then our div is in dark mode, otherwise it's false, meaning light mode. The JavaScript expression takes care of that for us. Let's check to see if it works. Browse to localhost:3000/demo2. And you can see that since darkTheme is by default set to false, the theme is in our light mode. Changing that default value to true and saving the file, our theme automatically updates to dark. To add logic to our browser to handle the toggle, add an onClick event to our same div tag that passes an anonymous JavaScript function that changes the theme from light to dark or dark to light by calling setDarkTheme with the negated value of the current darkTheme. We can verify that works by now clicking anywhere inside the Bootstrap container. And sure enough, the container toggles between light and dark. The downside of writing a component like this is that we've got the local component's state management embedded in the component along with the UI that renders with the correct theme and also exposes a UI click event to toggle that theme. Wouldn't it be nice if we could easily separate out the component state management from this component? That's exactly what a higher‑order component, an HOC, does for us. The way all HOCs work is that they enhance any component such that the new values can be passed in as incoming props. That is, it figures out those new values and invisibly makes them available as incoming props. Let's for the moment start out by assuming our App component has been enhanced with an HOC that manages our app theme for us. That means we can remove or comment out for now our call to useState and instead move those two values useState returned, darkTheme and setDarkTheme, to our App component as receiving props using destructuring syntax. To enhance this component with an HOC and ultimately export that enhanced component, let's rename App to EnhancedComponent. Then, create a new App component that calls a yet‑to‑be‑built component named withTheme, passing in EnhancedComponent as its only parameter. Since we are already exporting the name App, what that means is that our new withTheme component, we'll write that next, will return a component that we export and is essentially enhanced.

Code a Higher Order Component (HOC)
Now that we have our call to our withTheme HOC, let's build the component that will take care of doing what's necessary that makes this withTheme HOC work as we expect. Let's move back to Visual Studio Code and do that. Scaffold out the new component, taking in the single parameter, Component. Then to start, create a new component named Func with a capital F that simply returns a new component that is exactly the same as the one passed in. Notice that we're passing through the props by using the spread operator. The app will work exactly like it did before, but still with no enhancement. Two things to notice here. The first is that instead of simply returning an anonymous function, I'm creating a name function, Func, and returning that. The reason for doing that is that there is a React rule that ESLinter is enforcing that would complain if I just returned an anonymous function instead of one named Func. The app would still work, but we'd have to see the linter complaining, and that's just not desirable. The second thing to notice is that I've named the function Func with an uppercase F. The normal JavaScript convention is functions always begin with lowercase, but here we are using uppercase to again keep ESLint from complaining that this function is not a legitimate React component. For the linter to validate that this is a component, the function name must begin with a capital letter. The final step to make our app work again, as we've commented out the useState call in our original component, is to have our new withTheme component add the two new values, darkTheme and setDarkTheme to our EnhancedComponent. This means we need to move our commented out useState call in our original component to our withTheme HOC. Then add to the return component those two return values, darkTheme and setDarkTheme, as attributes. This would work as is, but let's improve the code a little by instead of adding setDarkTheme as a return from our HOC, let's instead return a function named toggleTheme, which does not need to have knowledge of the original theme value. The idea is just to have it every time flip to Boolean value. To that end, let's change the listener associated with onClick in the main component to just toggleTheme. Change the code in withTheme to instead of adding setDarkTheme as an attribute to the return component, change that toggleTheme and assign it an anonymous function that does the toggle for us. And lastly, rename the receiving prop, setDarkTheme, in our EnhancedComponent to toggleTheme. We are completely done, but I do want to make one small change to how we export our default app. Typically, you don't explicitly create a new name component like I did here for EnhancedComponent, but instead keep the original component name. Change the name EnhancedComponent back to App. Then at the bottom, consolidate these lines to just export default, then call withTheme, and pass in the App component as the first parameter. This is how you usually see HOCs called. That's really all there is to HOCs. It's just a very simple programming pattern that allows us to create a reusable component that we can essentially use to inject props into an existing component. In this example, we made our App component theme‑aware by enhancing it with our own withTheme HOC.

Share Component State with HOCs
Let's modify and integrate the withTheme higher‑order component, HOC we just built into our todo manager app. We built it to persist the current theme with React local component state. That is to say we call useState to create that state, and it returns darkTheme and setDarkTheme to access and manipulate it. Earlier, I stated that a benefit of HOCs is that they allow us to create reasonable code to enhance existing components. In our example here, we've enhanced our App component to include theme state management; however, if we enhance other components in our app using this withTheme, each of those components is going to have its own assigned theme. That really doesn't work for us, as we want one common theme across the full App component hierarchy. To solve this, we can easily combine the themeContext we developed earlier and use that to allow our withTheme HOC to manage a theme that covers our full todo app. Let's navigate to our Header component and replace our code that returns darkTheme and toggleTheme from our ThemeContext with code that enhances this component to do the same thing using the HOC withTheme. Since we know that HOCs add invisible receiving props to components, let's move both darkTheme and toggleTheme up to the component parameter line and add them to the existing receiving prop value, layoutVersion, then remove the call to useContext and also remove all the imports at the top we don't need anymore. At the bottom, just like we did in our last clip, let's change our export of this component, Header, to be enhanced by the withTheme HOC. At the top, let's assume we have a dedicated file for that and import it. Now, let's create that HOC, add it to our components folder in its own subfolder named hocs. Go back to the code we wrote previously in our demo2.js file and copy it to our paste buffer, just the HOC withTheme that is. Now, back to withTheme.js and paste it here. Since it's now a standalone HOC, we need to add the export keyword to make it available throughout our app. Like I said a moment ago, we need to update this code to instead of keeping its own local component state management for the app theme, replace that with code that gets those same return theme management values from our ThemeContext. And, of course, at the top do the necessary imports. The only change left now is to replace the anonymous function assigned to the attribute toggleTheme with the toggleTheme function returned from our useContext call. If you remember, we did that same logic earlier directly in the ThemeContext component, that is we assigned to toggleTheme an anonymous function that did the darkTheme toggle and then returned it as a value to the context itself. To confirm now that the changes we made to our Header component work, let's bring up a browser, toggle the theme by clicking on the layout manager input control in the Header component, and the theme toggles exactly as before. Our Header component now enhanced using the withTheme HOC is working as expected. So we've enhanced one component to be able to manage state using the withTheme HOC. We could now use withTheme to enhance other components to share the same theme state. What's extra nice about this solution is that if we look, for example, at our layout control, notice that it's using the same context as our withTheme HOC does. The beauty of this is that we can use our app's common or global theme state in components that are enhanced with an HOC, that is using our theme context indirectly, as well as components like Layout that use the ThemeContext directly. HOCs have been around practically since React was invented and continue to be a valuable technique for enhancing React components.

Comparing Ways to Share State Between Components
Except for the simplest possible app you can build with React, sharing data and state between components is always going to be challenging, and how you do it can have a big impact on your final product. In this module, we work through the details of three common methods available for passing data and state. The first of the three is simply by passing attributes when rendering components that then get received as an object with properties into the called component. Then, using the React Context API, we showed how to use that to share data and state through complex component trees easily. Finally, we showed how using higher‑order components gives us yet another way to have our apps share data and state. Just like in all programming, choosing how you do the sharing is going to come with tradeoffs. Let's talk a little bit about the tradeoffs between these three. Start out with passing data by props. Primarily, the reason to use props to pass data between components is that it is just plain simple. There is no magic, no invisible fields involved, basically what you see is what you get. That makes things like debugging really straightforward. When you look back at your code, it's easy to read, and it's straightforward to update. Keeping on the positives, it's great for simple component trees that are not too nested. The negatives though are significant, mostly around larger apps that require more intense passing of data and state between components. Passing props like this can cause lots of simple JavaScript code, making it easy to introduce programming errors. That is, if you need to, for example, pass data through a complex tree with lots of hops, it's easy to forget to pass the data through just a single hop, and your React app will stop working. This can also make it difficult to add new features to existing apps, as well as maintain the code you've already written. Moving on, passing data and state using React Context. Certainly, a big advantage is that it can significantly reduce the amount of JavaScript code that needs to be written, primarily because it easily skips through a deep component tree, giving you direct access to the data across multiple hierarchical levels. It's also easy to maintain for the same reason. You don't need to be concerned with in‑between components when passing data and state. It just seamlessly skips those layers and makes the data available. There are negatives, however. First, it involves a lot more complex JavaScript. The pattern itself is straightforward, but it's hard to argue with the simplicity of passing props, which are just simple JavaScript functions called with parameters. Another negative is it's hard to keep track of what components have access to what data. That is, it's not at all self‑documenting. Often, it can be a mystery to unravel why a component is not working as you expect, especially if you refactor components a lot moving them around in a component tree. Lastly, it's easy to cause unintended consequences relating to app performance. It's very easy to think that you are including data in a component that does not change while at the same time inadvertently bringing in data that does, causing your component to excessively rerender. The last of the three is by using higher‑order components, also called HOCs. Like context, HOCs reduce the amount of JavaScript code you need to write. It's been around though for the longest time, so there's a lot of code out there already that uses HOCs that works quite well. Also, using HOCs is very simple. The programming model though is more complex, and you may find that when writing HOCs, it can get confusing how to pass in initial values, as well as how to return calculation results. Another downside, though we did not talk about it, is that because props are added to existing passed in props invisibly, it's easy to cause naming collisions between existing passed in props and ones added by the HOC, causing results that are often hard to debug. Going forward, you likely will not see a lot of new code written with HOCs because for the most part, you can do the same thing with React Context, but nonetheless it's still a very viable pattern to use for sharing data and state between React components. No matter how you pass your data and functions through React, all that really matters is that you keep track of what you are doing and, of course, everything works. There is no right and wrong way to pass data and state around your app. As one of the React core team members says, do whatever feels right.

Handling Errors and Debugging Components
Introduction
Hi, this is Peter, and welcome back to Working with Components in React 18 in this module on Handling Errors and Debugging Components. Up until now, you've learned a lot about how to build components that work together well. In this module, we'll look at how to see what's going on inside our components, how to make them perform better, and how to handle the inevitable production time errors that often are out of our control. We'll start out going through the component‑related features in the React debugger extension. Those include how to view React components, how to see all the data associated with them, as well as what they render to the browser. You'll learn how to analyze a very common performance problem that happens in many React apps. It's when a component gets rendered multiple times when only one time is necessary. The app works just fine, but the experience the browser user sees is often not good, as it makes the browser do more work and potentially slows down the ultimate app's rendering. Finally, we'll look at what happens when something in your React app goes wrong. Sometimes, it's because of an error in code, or sometimes it's because of some external event. The example we'll look at is what happens when some JSON downloaded from a REST server is incorrect. You'll see how React allows you to show better errors to your browser users when something goes wrong. Instead of the full React component recrashing, you'll learn how to have just the components that have problems render their own messages.

Motivation for React Debug Tooling
The Facebook React team builds and supports a browser‑based extension called React DevTools that gives us developers a clear view into what's happening when running browser‑based React apps. It works directly with Chrome‑based browsers that include Microsoft Edge and also with Mozilla's Firefox. If you use another browser, you can still use these tools in standalone mode by installing the dev tools with npm. Why do we need a clear view into the browser? It's because the browser does not know anything about React code, same with standard debugging tools typically built into the browser. These tools typically only speak HTML. That said, a React app does ultimately render HTML. Trying to understand how to map React code to what the browser renders is extremely hard and without the React DevTools almost impossible. Let's take a look at our ToDoManager component here in our todo app and talk about it. Let's specifically scroll down and talk about the component's return, its render that is. What's great about this section is that because of the JSX syntax built into React, we can seamlessly mix what we typically think of as HTML elements and React components together. The difference between the two is simply that the components like ToDoAppForm, ToDoEditForm, and ToDoList all start with a capital T. In the primitive HTML, just the div here starts with lowercase. The syntax and rules for using them together are identical. To us, both are just building blocks or, as I like to refer to them, React elements of a page being rendered. Once React renders the page, all the React component definitions are lost, and primarily what we see through our debugger tools is just HTML. Let's now take a look at that. Bring up our ToDoManager app, right mouse‑click on the page, and then choose Inspect Element, and that takes us into Chrome DevTools, inspecting the HTML on the page that we were looking at. So what actually is this? It's an HTML div tag with a class name of tasks. Under that is a nested list of div tags with the class, single‑task, with some having the attribute completed. How can we possibly relate these back to the actual React component that rendered them? That's exactly why we have the React Developer Tools.

Working with the React Dev Tools Component Tab
If you've not installed the React DevTools and you are running the Chrome or Edge browser, I suggest doing it now. It's available in the Chrome Web Store, which you can get to by browsing to the URL, chrome.google.com/webstore. Search for React, and up will come the React Developer Tools extension. Then, simply install it. In order for our debugger to debug a React app, we need to have one running in the browser. Go to the URL, localhost:3000, and that brings up our ToDoManager app. After that, open the DevTools by either going to your settings icon on your toolbar, selecting More Tools, then Developer Tools, or you can execute the shortcut command usually by pressing F12. This should give you two tabs that you didn't have before that were contributed by this React extension. They are Components and Profiler. Let's look at the Components tab first. As we've already been working on this app together, the structure of the app should make sense. Ignoring the base components, which are provided by the Next.js framework and also ignoring the Context.Provider components, let's look first at the App component. We treat that as the root element of our app. Notice it has Layout as its child. Ignore the extra Context.Providers in between. Layout has nested under it ToDoManager, and under that are the components ToDoAddForm, ToDoEditForm, and ToDoList. As a side note, if you hover over any component in the list, the corresponding component rendered in the browser is highlighted. Double‑clicking on any component lets you zoom in, double‑click again, and it zooms in further. Often though, you need to go the other way. That is, you want to see what component rendered the one you are looking at. You can click on the rendered by over and over and walk up the component tree to the root of the app. Notice also you see the passed in properties as you go. At any point, if you want to see the source code of a component, click on the braces in the upper right, which the DevTools calls View source for this element, and you are taken directly into the element's JavaScript. Going back to the Component tab, you can click on the eyeball, and that takes you to the DOM inspector for what the component actually rendered. There are two more features of the component viewer in the debugger that can be very helpful. The first is clicking on the debugger icon automatically logs the selected component to the console, giving you all the drill‑down capabilities you'd get with any JavaScript object in the Chrome debugger. Also, under the Settings gear icon, you can filter the components you see, which means if you have a huge component tree, you can narrow it down to something that is manageable to look at. The second feature of the Components tab to talk about is that included in it is a very nice props editor. Though, what you see in the props display does not look like something you can edit. You actually can. Click on the props value, and you can change it directly. That change will be instantly reflected in the browser. You can also add some new props to a component that can not only be primitive values, but also any parseable JSON object. Something like this, for example. That's basically a quick overview of what you can do with the Components tab in the debugger. Unfortunately, the React team has not given us a lot of documentation for DevTools, but if you search the internet, you'll find a lot of good writeups, though often they may be outdated or just wrong. For me, I found that exploring the options here directly in the component viewer is the best way to learn.

The useDebugValue Hook Basics
In React, there is a built‑in hook named useDebugValue that is designed specifically to expose data in custom React hooks. Not only that, it also only helps us when we are running our apps with the React Devtools. Let's say you have a simple custom React hook like shown here that has two state values that track increment encounters. Also, we have a simple app component that renders two buttons and consumes that custom hook, giving our button state management. Browsing to our app, in this case, localhost:3000/demo3, we get the two buttons. And as expected, their labels are 101 and 201, representing the two state values tracked by our custom hook. Clicking the buttons increments each value by one. Bringing up the Chrome debugger and specifically the React DevTools component viewer, let's drill down to our App component. Notice it tells us what hooks are included in this component, only one at the moment, CountTracker. And drilling into that, it shows us our two independent state values being tracked. Notice also that there is nothing that tells us which of the two states track which variable. That's basically because React does not know. It only keeps track of the order the useState hooks are called in and therefore can only report to us in the debugger based on that order. What makes this even worse is that if you noticed, I created count2 and setCount2 as the first call to useState and count1 and setCount1 as the second. That's why in our dev tools component debugger, the second state, the one that initialized to 201, is listed first. That's clearly a bug waiting to happen. This is where useDebugValue comes in and hopefully keeps us from confusing those two state values. Start by adding useDebugValue to our React imports. Then, in our custom hook itself, call useDebugValue and pass it a string as the first parameter that includes the name of the state, count1, as well as its value. Next, call useDebugValue again, this time passing it the other state, count2. Calling useDebugValue multiple times is not a problem, as you'll see momentarily how the component viewer takes care of that. Refreshing our browser, and now notice even before drilling into our hooks, CountTracker, our custom hook, shows the return of our calls to useDebugValue. Because we called it multiple times, we get an array of values displayed; however, if we called it only once, it would just be a single value. Drilling down still shows the state values as defined in the order instantiated, but and most importantly the value displayed next to CountTracker leaves no doubt what value is count1 and what value is count2. That's a big win for us.

Integrating useDebugValue into Custom Theme Hook
Let's integrate useDebugValue into our ToDoManager app and specifically the app's light and darkTheme manager. The goal is to make our overall developer experience better when using the React DevTools component viewer. Let's start with a quick review of how our theme toggling works that we developed previously in this course. We are looking at our Layout component, which imports our ThemeContext and ThemeProvider. Our Layout component wraps a component named Inner with our ThemeProvider element, giving that component access to a value assigned to the ThemeContext. That value includes the Boolean property, darkTheme, which is assigned to our container div, determining whether the app renders with a light or dark theme. Next, navigating to our ThemeContext component, notice we make a call to useState to give us both the darkTheme state and its setter, setDarkTheme. These two values are what are assigned to our ThemeContext.Provider React element, which encloses the ThemeProvider's passed in children elements. That gives all the descendant components access to this app's theme. Let's now view our theme toggling experience through the React DevTools to better understand how the components are behaving. We have our todo app running on the right in a browser at localhost:3000, launch the Chrome DevTools and onto our React DevTools Components viewer tab. Scroll to the ThemeProvider component, and notice in the component detail in the hooks section, we have just one state value, and it's set to false. Obviously, that corresponds to our darkTheme state returned from useState. Though, the only reason it is obvious is because our ThemeContext component has only one state value. If there were more, which is usually the case, you'd have to figure out which hook is referenced in the component detail based on its relative position in the component itself. The running React app only keeps track of useState calls by the order in which they are declared and not the variable names used like darkTheme, in this case. To confirm that this is the darkTheme Boolean value, toggle the theme in the running app's header control. Notice the hook's state value changes. We can make what is displayed here in the hooks detail better by taking advantage of the useDebugValue React hook. Unfortunately, we can't use it here in our ThemeContext component because it's not a custom React hook, and useDebugValue only works in custom hooks. That's easy to fix though. We can easily encapsulate the state values and functions we assign to the context into a custom hook. Let's do that. In our hooks folder, create a new JavaScript file, useTheme.js. Import useState from React at the top. Export out a React functional component, then go back to the ThemeContext and cut out the code that creates our state, as well as the toggleTheme function. Back to our new useTheme hook, and paste both of them back here. From this hook, return two values our ThemeContext needs, darkTheme and toggleTheme. This is everything we need for a custom React hook, so it will allow us to include useDebugValue to display in our component viewer. Back again to our ThemeContext. Remove the useState import from React, as we don't need that anymore. Then below that, import our new useTheme hook. Call that hook from before our component renders. That's where we had all our state logic before, and simply return a constant value, which we can assign to our ThemeContext.Provider element, as it's just an object that holds the two properties, darkTheme and toggleTheme. Let's now look at our component viewer and see how things have changed. Toggling our theme control in the header, our component viewer looks almost identical to before. The only difference is that now we have a custom hook named Theme in our hooks detail section, but we still have an unlabeled Boolean state value, which, of course, is what is assigned to darkTheme. This we can fix because we now have a custom hook. Back to our useTheme hook, and let's start out by importing useDebugValue from React at the top. Then, add a call to useDebugValue, passing it a string that evaluates to theme:dark or theme:light. Now, instead of having to figure out what the unnamed state value means, we have a meaningful expression that shows us. We still have our ordered list of unlabeled state values, but our call to useDebugValue makes it really clear what our current theme is, dark or light. This covers most scenarios that we would use useDebugValue for in our React apps.

An Advanced Use of useDebugValue
If you need more programmatic access to what useDebugValue outputs that is more than a template string or ternary expression gives us, there is an additional advanced feature of useDebugValue that can be used. It's accessed by passing a function as the second parameter to useDebugValue. That function takes in, as its first parameter, the first value passed to useDebugValue and then what it returns is what is displayed in the component viewer. Let's go back to the code we built in our custom theme in the previous clip and add to it this advanced usage. Add a second parameter to our call to useDebugValue, and while we're here, remove the theme: prefix from our first value, then check it for being light or dark. Depending on that, return a nicely formatted string saying the theme is light or the theme is dark. Toggling again the input control, sure enough our message is now displayed as a full sentence just as we expected. What's special about using the second parameter as a function like this is that this function only executes when the DevTools are loaded. Say we had some complex calculation in this function. It would only happen when we are doing our development and not when React DevTools is unloaded. Hopefully, you can see the benefits we get from calling useDebugValue. It makes it really easy to show meaningful information in our components viewable in the React DevTools. This is something certainly to think about when you're deciding whether or not to extract your state management into a custom hook like we did here with theme. It's often easier to just leave simple state management directly in the component that uses it; however, if you want a better debugger experience, this gives you another reason to extract your state management into custom React hooks.

Working with the React Dev Tools Profiler Tab
Now that we've covered the Component tab of the React Developer Tools, let's move on to the Profiler tab that is the second of the two tabs in the Chrome debugger provided to us by the React Developer Tools. You should, by default, be on the Flamegraph tab underneath that. To do our first profile, the easiest way is to press the Reload and start profiling button. Then, after the page refreshes, press the Stop profiling. That's the same button again. That gives us our first flamegraph. It's a breakdown of our components that rendered from our root component all the way down to the furthest away child. The root component spans the full length of the browser because it's always running. Scrolling the profile to the right, things get interesting when we get to our ToDoManager component, which contains our ToDoList component that, in turn, contains all our individual ToDoItem components. Hovering over any component here on the flamegraph tells us the component name along with how long it took to render. That amount of time corresponds with the length of the bar. To get the same information, you can also click on any component, a ToDo component in this case, and the name and detail are displayed in the right panel. Clicking back on the top, our root component, takes us back to the full flamegraph. Similarly, you can drill down to any component in the flamegraph and see its children. Now that you have the basics of using the flamegraph and know what it takes to get the page loaded for the first time, the next logical step is to profile some user interface scenario. Let's take a look at what happens when we toggle a todo item between completed and not completed. We want to create a profile session that covers from before we click on a todo item to after. To do that, begin by pressing the Start profiling button, then click on one of the todo items to toggle its completed status and Stop profiling. That's the same button we started with. We've got our same flamegraph again. It looks to me like everything below the ToDo list component rendered, including every todo item. What makes me say that is the ToDo components are not gray. The fact that they're not gray means that they rerendered. You'd think that the only todo item that should've rerendered was the one we changed, but that doesn't seem to be the case. Let's confirm that's really what is happening. Go back to Visual Studio Code and the ToDo component. At the top, add a console message every time this component renders. Just have it showed the todoItem.id and the todoItem.text. Putting a log message like this at the top of a component is a common way to validate whether a component is rendering or not. Going back to our running app and refreshing the app again to make sure our console message tab is empty, click on just a single todo item, and now you can see for sure that all the todo items rendered. Actually, they all rendered twice. That's because in development mode, React is running in strict mode causing this. The reason for this is it helps flesh out possible bugs and state updates, though it can make output like this confusing. At any rate, all the todo items did rerender, which is not what we really want. Why did all these components rerender? Here again is where the React debugger tools can help us. Click on the gear or Settings icon, select the Profiler tab, and check the box titled Record why each component rendered while profiling. It's not set by default because it can unnaturally slow down our app. That slow down can make it hard to debug our apps for UI issues. In our case though, there are no adverse effects, and it's okay if our page renders slower. Let's profile our app again. Press the Start profiling, click on a todo item, and then Stop profiling. Now, if we hover over any ToDo component, we can see the reason why it rendered. For this one, it says the reason is the props changed and specifically handleToggleCompleted, handleDelete, handleEdit, and idUpdating all changed. IdUpdating makes sense because the value of that does change every time a todo item is clicked. The other methods changing are not as obvious. The reason those methods are causing the ToDo component to rerender is that when a method is passed to a component as an attribute, a copy of that method is created, and React does not know it's not the same as before, therefore React forces a rerender. The reason we profile React apps like this is so we can see where the performance bottlenecks are and based on that, fix them. React provides several API calls, including Memo, useCallback, and useMemo to help modify our React code to reduce the unnecessary rerenders in our apps. Coming up later in the course, specifically in the module, Improving Component UI Performance, we solve this over‑rendering problem using these React API calls.

Inspecting Component Renders with React Dev Tools
Now that we have the basics of how to profile running React apps, there's another very useful function in React DevTools to see components as they rerender in our apps. In other words, our flamegraph shows us which components rendered by colorizing them and leaving the others that did not rerender as gray. That's great, but sometimes it's helpful to see in the app itself if the components are rerendering. Normally, when we are running our apps, there is literally no way to tell if a component rerendered. There is nothing visually that triggers us to know it happened. Certainly the browser will be doing more work when the component rerenders, but visually, nothing. Let's demonstrate now a feature in the React DevTools that shows a component rerendering. Navigate from inside our Chrome debugger from the React DevTools Flamegraph tab to the React DevTools Components tab. Clicking on the Settings icon, that's the gear symbol, and under the General tab, select the checkbox, Highlight updates when components render. Refreshing our browser to make sure that setting takes effect, then let's interact with our app and see what happens. Toggle the checkbox on the toolbar for showing just the important todo items. Notice a green box flashed around the components that rendered. One problem with this feature that I find is that the flash happens so quickly, it's often hard to figure out which components really rendered. Luckily though, in this video, I can freeze frame the green highlights and explain better what's happening. Click the Important checkbox again, then freeze frame the video. It looks like practically every component, including the header and the footer, rerendered. I'm not going to even attempt to fix that, but if that made the app feel slow or unresponsive, you might want to look into that. Let's try something else. How about toggling the theme? Doing that and then my freeze‑frame trick, notice that not so many components rerendered. Specifically, it looks to me like the header and the footer rerendered, but the individual todo items did not. Well, the reason for this is our todo items are totally based on CSS classes and not React elements changing. We could've changed the todo item theme itself using React JavaScript expressions and explicitly changed class names, and that would've caused each todo item to rerender. Because we took advantage of CSS, the app performs better, something to keep in mind for yourself when building React apps. The more you can do directly in CSS, likely the better your React apps will perform for your browser users. That's about it for the React DevTools component viewer and profiler. Next, onto handling errors in our app and how that ties into the built‑in React error boundaries.

Adding Error Boundaries for Catching Errors in Production
We've all had the experience when writing single‑page apps where something goes wrong in the JavaScript and either nothing comes up on the screen, which is the worst case, or something with no meaning comes up. That can be really frustrating. Error boundaries in React are designed to keep that from happening. Let's add one now to our todo manager app. Back to VS Code, and let's look at our ToDoItem component. This is the one that gets rendered for each item in our todo list. Previously, we added a console log message to confirm it rendered, but since we now know how to use the React DevTools flamegraph to get the same information, let's remove that line of code. Since our plan is to catch an error and display something reasonable to our browser, we need to do something that will create the error. Let's do this for the render of our todoText property, which is off of our todoItem object. Let's limit it to displaying just the first 60 characters using the slice function. Now, if todoText is undefined, this component is going to throw an error saying something like cannot read property, todoText. Turns out that's pretty easy to simulate. Let's navigate to our JSON file that holds all our todo items, that's db.json, and then rename the first item's todoText property to todoTextXX. That way, for one item in our todo object retrieved from this JSON file, the todoText property will be undefined. Let's verify that. Bring in our running browser to display all todo items before making the change to the JSON file, refresh our browser, and sure enough, up comes exactly the error we expected, cannot read property, todoText. The reason we get this error telling us exactly what the problem is is because our app is running with npm run dev, meaning it's running in development mode, and all the source maps and debugging tools are loaded so that we can get a nice error message. What might we see in production? Well, let's try. Bring the terminal up, do a production build, that's just npm run build, then launch the app with just npm start. Refresh the browser, and now we get a worthless message, Application error: a client side exception, basically no help to us and no help to our users. So let's stop our production app running, reload npm run dev so we can go back to running in development mode. To make this experience for our browser user better, let's add an error boundary around our ToDo component, the goal being to display something different inside the error boundary if something goes wrong. In other words, the rest of the app will work, but just the problem todo item will be showing an error. In the React docs at this URL is everything needed to make our error boundaries work. More specifically in scrolling down, there is code for a new component called ErrorBoundary, which incidentally is a class component, not a functional one, along with an example of how to use it. Let's copy the code for the class component into our paste buffer so we can recreate it in our todo manager app. But to create that file in a new folder called common and a file name ErrorBoundary.js, and then paste it in. There are a few things that need to be added and fixed to make this class work. First, since React class components extend component, we need to import React at the top Then for now, remove the logging of errors since we don't have a service to log to. Lastly, at the bottom, since we put this class in a standalone file, it needs to be exported so it can be used in our other functional components. So, back to our todoItem component. Let's import our new ErrorBoundary class. Since we know we want to enclose our current ToDo component inside an ErrorBoundary element, let's start out by renaming our current ToDo component to just the name Inner. Inner now is basically the same component we had before that was named ToDo. Scroll down to just above where we exported ToDo, and let's create a new ToDo component that renders Inner inside an ErrorBoundary component. Since ToDoList does pass properties into our todoItem, we need to pass those properties through to Inner, otherwise our component will not work. That's it. Let's see how we did. Refreshing our browser, and now our top component, instead of saying what it did before, we broke the JSON file, that is replaced the property name of our first todoText with todoTextXX. It just says something went wrong with absolutely no styling, so it looks kind of odd. It's hard to even tell that it originally was a todo item. Notice also at the bottom, we still have our two errors generated. That warning is because we're running in development mode with npm run dev. If we were to build it with npm run build, then run npm start in production mode, you wouldn't see this error at the bottom saying two errors. Coming up next, we'll fix that so what gets rendered as an error is more consistent with the rest of our UI.

Improving Our React Boundary Error UI
We ended the last clip with a really basic error message replacing our failed todo item. Let's improve on that. Rather than letting the ErrorBoundary class display something went wrong from a hard‑coded string when it catches an error, let's instead pass as an attribute to ErrorBoundary the UI we want rendered. That is, we'll essentially pass a component in the form of JSX to ErrorBoundary as an attribute. How about this? ErrorUI equals a JavaScript expression that represents a simple component with a div that wraps the ID of our failing todo item. Of course, by itself that's not going to work because our ErrorBoundary class knows nothing about the attribute error UI. Let's fix that. Navigate to ErrorBoundary. In the render section, check and see if our errorUI is available as an incoming prop, and if so, return it or actually render it. Refreshing our browser, well something went wrong is now replaced with the string, 1 Errored. Still not so interesting, but we can take this one step further and make it really useful. Going back to our ToDo component, let's replace our inline attribute definition, that is the one with a div tag, to instead be a named component. Let's call that component ToDoErrorBoundary. Pass to it all the incoming props available to todo, spread just in case we need them. Then, let's create our new component as a function in this file named ToDoErrorBoundary. Scaffold it out as usual, and now have it return a nicely formatted div with the appropriate classes that are just like the ones wrapping all the other todo items. This time, however, make a nice error message and concatenate that with our props object in JSON format. Now, we'll know exactly what the data looks like that caused the error. Refreshing our browser again, and now in red, because of the text‑bg‑danger Bootstrap class we assigned to our div, the full todo record in JSON format that caused the problem is shown. Notice the property name, todoTextXX, is wrong, as it should just be todoText. One more thing to think about, do your users really want to see JSON? I don't think so. Let's assume you have access to either a developer mode flag or debugging flag. I'll create a debug variable to simulate that. To start, I'll sign it false, meaning we don't want to see all that JSON. Create an inline ternary expression in our rendered content, and only if debug is set to true show the full JSON, otherwise just a nice, simple, friendly message. Refreshing our browser. And because debug is false, we now have a non‑techie message to show our users when something goes wrong. The final thing to mention, as part of more advanced error handling, is what to do if you want to send to some external bug tracking system like either Bugzilla, LogRocket or even the open‑source project, Sentry. Navigating back to our ErrorBoundary class and looking at the componentDidCatch class method, here is where you can call some function to do whatever you want with the error message generated. Uncomment the code that calls logErrorToMyService. Then at the top, create a simple global function with that name to simulate something really happening and then simply log the error to the debug console for now. That way, you have a good way to monitor errors happening in your customer's browsers. By way of cleaning up, let's navigate back to our JSON file, fix our property todoTextXX back to just todoText, refresh our browser, and everything is back to working, and our app now is handling any errors thrown from the ToDo component.

Takeaways
There are two main takeaways from this module on handling errors and debugging React components. The first is that there are tools available to us developers to make our debugging experiences better when building React apps. The second is that the React library support catching errors in our components, as well as both displaying those errors to our browser users in a meaningful way. It also allows for logging errors that happen while apps are executing. More specifically, you learned about using the two tabbed panels that the React DevTools added to the Chrome debugger. The first tab, the Component Viewer, which allowed us to see static details of a component, including things like its props, how it displays to the browser, as well as how it fits into the component hierarchy with other components. The second tab is the React Flamegraph where you learned how to visualize your component tree, including finding problems where your components are rendering more times than they need to. Lastly, you learned how to use the React ErrorBoundary class to wrap your components and gracefully show errors to your users when things go wrong. The programming pattern you learned to handle errors that come up will make your apps easier to build and easier to maintain going forward into the future.

Improving Component UI Performance
Introduction
Hi. This is Peter, and welcome back to Working with Components in React 18 and specifically this module on Improving Component UI Performance. React, in general, does a great job of efficiently manipulating the browser DOM such that your browser users have a great experience without you as the developer having to do any special programming. The React team has optimized the concurrent rendering engine around expected browser workloads, which in general is what your app will be doing. That is, it's reasonable to expect that in a combo list you'd not put hundreds of entries. However, there are many times that what you want to do is not expected from the React rendering engine. And in those cases, the good news is that the React team has built into the React API special function calls you can use to ensure your apps still deliver great performance for your browser users. Typically, the problems you run into when building React apps can be broken down into two categories. The first category is when components over render, meaning that when local component's state updates happen, React believes certain components need to rerender when in truth they do not. We'll address this problem in this module by first learning how to recognize when it's happening, and that involves how to use the flamegraph in React DevTools, and then how to solve the over‑rendering problem, and that usually involves the React API memo call. You'll learn how to best use memo in your apps to avoid over‑rendering scenarios. The second category usually has to do with React local component's state updates. It's not unusual to have many different local component states being tracked. And for the most part, the order in which they update does not really matter. JavaScript and the browser DOM are usually fast enough that everything that needs to be updated gets updated, and the user never notices the order in which that happened. However, that is not always the case. Sometimes, especially with long‑running tasks that may or may not be computationally expensive, it becomes important to prioritize these multiple state updates between renders. There are two React API calls that help us with that, useDeferredValue and useTransition. You'll learn in this module how to use both, as well as when one makes more sense than the other. Again, and most importantly, I suggest not spending any time optimizing your React apps until you recognize there is a problem. React on its own does a great job, and the less code you create, the more likely your apps will run bug free, as well as be easy to maintain and extend.

Fixing over Rendering Performance Problems
Though usually over rendering is not a problem in React apps, there are cases where it is, and dealing with those cases is what we'll do in these next few clips. What makes React apps react is local component state changes that lead to React components rerendering with updated data. In general, React is very efficient at how it updates the browser DOM such that even though components may rerender more times than necessary, the user browser experience is still excellent. Unfortunately though, this is not always the case. When over rendering causes the browser experience to be less than adequate or sluggish, the React API gives us calls to keep our React apps from over rendering. The React API call, memo, is the most common call we make to solve this problem. There are cases where the built‑in React hooks, useCallback and useMemo, can help, but memo is usually all that is necessary. In a previous module, we showed using this flamegraph that when we updated a single ToDo item component to reflect that it was completed, all the other ToDo components rerendered when obviously nothing changed causing that to happen. Reviewing that quickly, here is what we did. We pressed the Start profiling button in the Flamegraph tab. We updated a single todo item by clicking on it, and then pressed that same profiling button again to stop it. Hovering over multiple todo items, you can see that they all rerendered. Anything here in this flamegraph in gray means the component did not rerender. The reality in this example is that there are only 10 or 20 todo items. The browser user would never know about all these extra rerenders. Therefore, any fix we might do is just creating extra work for us and even worse, creating the possibility for future bugs that might be related to the extra code we added, that is we've added engineering debt to our app, which is never a good thing. However, if we did have hundreds or even thousands of todo items, that could impact our app's performance negatively. Fixing that problem by eliminating the over renders could make our apps more responsive. Our flamegraph is representing a full component hierarchy that looks something like this. Notice on the flamegraph the bottom three lines all rerender when toggling a todo item between completed and not completed. The three components that were involved in that are the ToDo component, which is where the click event took place, the ToDoList component, which directly calls it, and above that, the ToDoManager component. That's where the local component state is referenced from. Let's isolate just these three components and talk about what is happening inside the React rendering engine when that button got clicked. That button click causes an event to be fired in our ToDo component. That event references a function that has passed from our todo list as a receiving prop to the ToDoManager component that houses that event. Likewise, ToDoList gets that same function as a receiving prop from ToDoManager. When ToDoManager changes a Boolean value in the ToDoList data, that, in effect, causes a local component state update that makes our children and our children's children rerender. Hence, that is why the last three rows of the flamegraph rerender, including every instance for all of our ToDo components, one for every todo item on our list. As is often the case, there are multiple contributing factors to why these ToDoItem components all rerender. Hovering over any of these displays, why did this rerender? And then the reason, because props changed. It lists as the properties changed, handleToggleCompleted, handleDelete, handleEdit, and idUpdating. Three of those are functions, and one is a straight integer variable. What it doesn't say is props change because its parent rerendered. If we could somehow fix this component so none of the receiving props changed, then we would be disappointed to find out that it still rerenders. The reason would be changed to it rendered because its parent component rendered. Coming up, we'll fix both of the reasons for this ToDo component over rendering.

React.memo Can Solve over Rendering Problems
When you have identified that you have an over‑rendering problem in a React app, React.memo is usually the first API call in your performance toolbox that you reach for. The problem it specifically attempts to solve is the one we just finished talking about in the previous clip. That is what happens when a child component is called by a parent component and that alone causes the component to rerender, independent of whether any passed in props changed. That seems unintuitive. How about if we have a simple React component like the following? It simply takes in a number as a receiving prop and then renders it. I'm claiming that even if we don't change the number passed into this component, the component will rerender anyhow. Why does React do this? The reason is say we add a side effect to this component. We create a const at the top that gets assigned the current date and time, and then it just renders it. Now do you see why React always renders components even when the props don't change? If React were to only rerender this component when the receiving prop changed, then passing in the same prop over and over would cause the component's render date and time to never change. That would be very undesirable. Let's now create a parent/child relationship similar to this in our todo app. Let's go back to the component hierarchy in our last clip. ToDoManager is the parent of ToDoList, and ToDoList is the parent of ToDo. Let's refactor the ToDo component to create a simple scenario like the one we just showed in sudo code such that we have a parent component rendering a child component where the child has no side effects. We'll show that when receiving props don't change, but the parent renders, that the child component also renders. Let's refactor our ToDo component into two components with ToDo still being the top level, or parent component, and adding a new child name, ToDoItemText. That new child will simply render our todoText and the ToDoItem important value. Let's navigate back to Visual Studio and specifically our ToDo component and do the refactor. Extract the JavaScript expression in our ToDoItem component that displays the todoItem text, as well as an icon indicating whether this item is important. Notice we have two properties received from our received prop todo object, the Boolean value important and the string, todoText. Cut this into our paste buffer, this JavaScript expression, so we can paste it shortly into a new component. Then replace this with a call to a yet‑to‑be‑written new component named ToDoItemText and pass the attributes, both important and todoText. At the top, assume this component will be in the same todo folder, as we are in now, and import it. Create that new file to hold our new component, and name it ToDoItemText.js. Scaffold out a standard functional component that takes two destructured values as incoming props, the Boolean variable important and the string variable todoText. From our paste buffer, paste in the JavaScript expression we previously copied from our ToDo component and remove the todoItem prefix, as we now have our two values destructured. And lastly, export this component. This is about as simple a component as we can get. It has no context, no local component state, no side effects, and it takes in two simple values as receiving props. It renders strictly based on both of these values. This truly is a pure component, meaning what is rendered is 100% of the time based on the props passed in. Let's now run our app again and see what happens in our flamegraph when we toggle just one item's important flag. Click on a single item's edit button or icon, toggle the Important checkbox on the selected item. Then, before pressing Update, start the profiler, press the item's update button, and then stop the profiler. Notice now that multiple todoItem text components rendered, even though it's definitely a pure component and only in one case, that is the one todo item, should this component have rerendered. The reason all these other components rendered is exactly what we've been talking about. The flamegraph display tells us that. Hover over any of the todoItem text components, and it shows the reason, the parent component rendered. Exactly as we expected. We do have an over‑rendering problem.

Implementing React.memo to Solve Our Re-rendering Problem
Assuming we've decided that our ToDoItemText component's over rendering is a problem, that is there are enough of these todo items that it's dragging the performance of our app down, we can fix it with the React.memo API call. What does React.memo do? Essentially, it takes in as its first parameter a React component and then returns a memoized version of that component. What memoized means, in this case, is that the first time we call memo with a passed in component, it caches or remembers the return based on or keyed off of the passed in props. However, it's important to keep in mind that React.memo only looks at the properties directly off of the passed in props object. So, for example, if we passed in the object todoItem, which has its own properties, then React.memo will never recognize the properties of todoItem as changing. It's just the first level that it compares. You can think of this as a shallow comparer. Let's go back to Visual Studio Code and navigate to our ToDoItemText component. And in that, implement React.memo to specifically memoize the return of this component. To start, since we know we're going to use React.memo, let's import it at the top. The easiest way to memorize this component is simply go to the bottom of the file where we export it and then instead export a call to memo that takes the original component as its first parameter, and then what actually gets exported is the memoized version. Remember, it's up to us to know that there are no side effects in this component. We are telling React specifically not to rerender this component if the receiving props don't change. Let's go back to our flamegraph and see how we affected our app. Start the profiling session, update our Important status, and stop the profiling. Now notice all the ToDoItemText components, except for one, are grayed out, meaning that they did not render. And for the one that is grayed out, hovering over it tells us that the reason it rendered is because the prop, Important, changed. That's exactly what we expected and wanted to happen. We've successfully optimized the rerendering of our ToDoItemText component.

Advanced Usage of React.memo with a Custom Function
Let's now talk about an advanced usage of React.memo. You may be wondering why in the last two clips did I focus on keeping from over rendering just a small component, ToDoItemText? Remember, it's just a child of the ToDo component that receives as props the Important Boolean and the todoText string. Navigating to our running app again and looking at the new flamegraph, it does show the ToDoItem component not over rendering, but the ToDo components themselves mostly over rendering. We can confirm the reason by hovering over each of them, noticing that the reasons they rerendered is because of the changed pass‑in functions, as well as the value of idUpdating. Keeping that component from rerendering is not as simple as just calling memo. Regarding the functions being passed in, they are top‑level properties, meaning React.memo will compare them, but that still leads to a problem. When a function is passed into a component from its parent component as an attribute, each time the component is rendered, a new copy of that function is created. That does help us in the case of passing extra data wrapped enclosure, but not so much for functions that don't change. What I mean by passing data enclosure is that we might have something like this that we are signing to a component attribute. In this case, we do want a new function created and passed to the child component, but that's not our case here. There is a React API call named useCallback, which you can use to solve this problem, but it's a little tricky to use, and it's easy to get wrong. If you do want to learn more about this, you can head over to my other course here on Pluralsight focused on React hooks called Using Hooks in React 18. Meanwhile though, the React.memo API call provides us a very clean way to solve this problem. We can pass a second parameter to the useMemo call. Remember, the first parameter is just the component itself. That second parameter is a function that takes in as the first parameter the previous props received by this component, and the second parameter is the next or the new props being passed in. Then, we can do some programming logic based on the previous and the current properties being passed in, whether the component needs to rerender, and if it does, we return true, if not, false. This way, we can completely ignore the fact that the functions are being passed to the component. Let's navigate to our ToDo.js file that holds our ToDo component and make the necessary changes with React.memo to keep this component from over rendering. At the top, since we know we're going to use the React.memo call, let's import memo from React. Scroll down past the Inner component. Remember, we built that as a component to wrap our ErrorBoundary around previously. Then, like we did with ToDoItemText, change the component we are exporting to one returned by the React.memo call, passing ToDo as the first parameter and now adding a second parameter, a new function that takes in the previous props and the next props as parameters. For the function's code, return either true or false, depending on a calculation that takes into account multiple things. Did the todoItem's complete property change between renders, or did the Important property change? Also, did the idUpdating prop passed in equal the current component's ID being rendered? If so, that would mean that this component should show a busy indicator or a spinning icon, in our case. If all that logic evaluates to true, then force this component to rerender, otherwise it should return false, and it doesn't rerender. I call this clip the Advanced Usage of React.memo because it allows us to programmatically determine whether the component should rerender based on changing props. React.memo without this function is much simpler to use, but it makes the assumption that it just does a simple shallow compare of props. Let's see how we did. Navigate to our flamegraph, start the profiler, do the same update process as before to update a single item, and then stop the profiler. Sure enough, only one todo item renders, and all the others, as you can see because they're gray, did not. Another takeaway here is that had we done this optimization first, then adding the React.memo call to our original ToDoItemText component, as we did in the previous clip, would provide no value. That's because todo would never render when it's not needed, and therefore, its child, ToDoItemText, would also not over render. This is a good reason not to optimize until very late in your development process. That is, wait until you have a problem with your app, and then go back and optimize your rerenders. Otherwise, like we did here, you may do extra work and add engineering debt to your project where you really didn't have to.

Deferring UI Updates with useDeferredValue
React automatically optimizes how components render based on what the concurrent rendering engine believes needs to be updated. In other words, it makes an educated guess on how to rerender components in React apps. It is often the case though, especially when a lot of data is changing, that React gets it wrong. The result can be a poor experience for browser users. In this clip, we'll look at deferring some updates in a UI using the useDeferredValue React API call. For example, in the todo app that we've been building, we have a search field at the top of the list of todo items. As we type into the search field, the todo list itself rerenders with all the newly filtered todo items. With just a handful of todo items, the list will have no problem rerendering as the user is typing into it. However, if we end up with thousands or maybe even hundreds of todo items, we may find that typing into our input field starts to feel slow. Let's think about what is happening here, that is think about the UI as two separate parts. One is the input field with the search text, and the other is the list itself. At a high level, the input field UI has associated with it some local component state that gets updated by an onChange event in the input field. That is, on every keystroke, the value associated with the input field needs to update. At the same time, as each onChange event is processed, the full list of todo items also needs to rerender. Just like our input, the list of todo items is maintained also based on that same local component state. The React concurrent rendering engine has no idea that we prefer that when the user types into the search field that that state value for search gets updated immediately, and it's okay if the list itself does not update as quickly. That is, when the user types into the browser, it should feel responsive. At no point when the user is typing into that input field should there be a delay in the value showing. The React API provides a library call, useDeferredValue, that lets us tell the React rendering engine to defer the state change of a certain value to essentially let other state values update first. Let's start out by looking at some code that would solve the problem presented in the app we just showed. Then in the next clip, we'll move on to fixing our actual todo app we've been working on throughout this course. Here is a very simple app that represents our todo list with a text string filter. It just has two local component state values, one for the search text and one for the list of todo items, and the render is a simple input field that maintains and shows the search text's local component state and also a call to a component not implemented named ShowTodoList. Just assume that component renders the full local component state, todoList, filtering it by the local component state, search. In this example, both the search input field and todoList render with equal priority. Our goal is to make our todoList update on a deferred basis, that is only after the input field updates. We do that by creating a new local component state based on our old one. We just have const deferredSearch = useDeferredValue and pass it our original search state. To make our todoList display based on that value, pass that new value to ShowTodoList instead of the original search state. Now the part of our UI that shows the input field will update quickly, making our app feel more responsive to our browser users.

Implement useDeferredValue in the Todo App
Let's now implement the React hook, useDeferredValue, in our full todo app that we've been working on throughout this course. We have exactly the same scenario we just talked about, and that's a search input field that filters our list of todos. The only file we need to update is our app.js, so let's navigate there. Remember, our goal is to create a deferred state value based on the user typing into the search input field, then use that deferred state value to render the list of matching todo items. That way, our text input field will feel responsive, and the render todo list may slightly lag behind it in getting updated. Let's code it. Start out at the top of App.js and add the import from React of the hook useDeferredValue. Then, lower instantiation of the searchText state with useState, let's create a new deferred state named searchTextDeferred and return it from a call to useDeferredValue, which gets passed in the original searchText state. Then, literally all we have to do is replace the searchText passed into the ToDoManager component, that's the one that renders the todo list, with searchTextDeferred. Now our app should be more responsive to typing into the search input field. Let's see. Browse to a running app, type some characters into our input field to be matched in our return and rendered list, and it's pretty clear that both the input text field is responsive, and the list is updated practically in real time or at least it feels that way. With only a dozen or so items in the list, I can promise you that adding useDeferredValue to our implementation here is not going to make any difference. However though, if we had a lot more entries in the list or we had a more complicated search calculation to do to render the list, useDeferredValue would be a big help.

Prioritizing State Updates in Components with useTransition
UseTransition, just like useDeferredValue, gives us a way to help keep React apps responsive to our users. Ultimately, both hooks have similar results. UseTransition just gives us more control. It is different than useDeferredValue in that it gives us an explicit way to lower the priority of a local component state update, so other updates in a given component can run at a higher priority. It also explicitly gives us a Boolean that we can use in that same component to know when the lower priority updates have completed. That basically means any higher priority updates are also completed. Previously, we showed some simple React code that implemented in a React app a searchable list of data. That is, we had a simple input field that drives the search of list items that dynamically changes based on what's typed in. Here's what that code looked like before we made our changes. Let's now do the same thing, but instead of including useDeferredValue to make our app more responsive, let's include useTransition instead. Unlike useDeferredValue where we passed a state value into the hook as a parameter, when we call useTransition, we pass it no parameters, and it returns to us an array whose first value is a status flag. That flag indicates whether all the state updates ran in this component have finished changing. It's typically named isPending, meaning that if isPending becomes false, then all the state updates in the component have completed. You can treat isPending like a state value in that when it changes, that forces React to rerender the component, and any conditionals you render that are based on isPending will render correctly. The second array value returned by useTransition is a function that you set in your component that marks state setter functions as low priority, meaning any other state setter functions you call in your component will be considered high priority. Obviously, this only helps when you have both high and low priority state in your component. For useTransition to help us, we need to create another state variable for search. Let's do that by calling useState and returning searchHighPriority and setSearchHighPriority. This will be our high priority state, and our plan will be the original search state will be the lower priority one. Now, in our input control, instead of calling setSearch directly, which is our low priority state update, let's call startTransition instead and pass it a function that calls setSearch with what we typed in to our input field. That takes care of our low priority state update. Let's call our setSearchHighPriority state updater outside of our startTransition call. Finally, because we want our input field to reflect the value of our high priority state, we need to change the value to searchHighPriority. You can see that useTransition takes a little more effort to add to our React apps, but the benefit is that it gives us very fine‑grained control over which date values update at high priority and which ones update at low. It also gives us an isPending flag, which can be very useful, as you'll see in the next clip, when we update our full todo manager app to show a progress indicator when updating is not instantaneous.

Implement useTransition in the Todo App
Implementing useTransition in our todo app is a little more complicated than we just did with useDeferredValue. The result, however, gives us a little more flexibility, so there is a benefit. Let's make the necessary changes from how we implemented useDeferredValue to implement useTransition. Start out in App.js. Remember, that's the only component we needed to update for our useDeferredValue implementation. At the top, chain the React import to useTransition. Remove the call to useDeferredValue and replace it with one that calls useTransition that returns an isPending Boolean flag, as well as a function, startTransition, that we'll use to mark state changes as low priority. It's important to notice that both of these return values become part of the local component's data, App that is, that is isPending and startTransition are both like local component state in that regard. Unlike our implementation with useDeferredValue, we are not going to create a special state in this component and pass it to the ToDoManager component to display the list of todos. Instead, let's pass both isPending and startTransition into our ToDoListWithToolbar, which is where our search input field ultimately gets updated from. We'll use the onChange event that's assigned to the actual input field to mark changes in our search text as low priority. To complete the update of this component, replace searchTextDeferred in our call to the ToDoManager with just searchText, as we no longer have the value searchTextDeferred. ToDoFilterToolbar is really just a pass‑through component that ultimately calls ToDoFilterToolbar, so let's navigate there. Add startTransition and isPending as receiving props, then pass them through to ToDoFilterToolbar. We are doing classic prop drilling here, but it's just two values, and it's just not that complex. So, I'm good with that and not introducing some context to do the sharing. Navigating now to ToDoFilterToolbar, add the two values as receiving props, and finally, use them. Replace our call in our search input fields onChange event to instead call startTransition, passing it an anonymous function that calls setSearchText just like before, but now causing the change to happen in our component at a lower priority than other local component state changes. Since we do need a state value that changes at normal priority, let's introduce a new state value and its setter and call it searchTextResponsive that also becomes a local component state to this ToDoFilterToolbar component. Make sure to add useState as an import at the top. Outside of the startTransition call, but still in the onChange event, update our state, searchTextResponsive, with the typed‑in value to the input field. Then, to make that value display immediately, replace what's assigned to value with searchTextResponsive. That is everything we need to do to make our app more responsive, as now typing into the input search field will update the input field itself practically in real time while the todo list update lags slightly behind. We do have an isPending Boolean that lets us know when the input field is updated, but the list has not. So we can take advantage of that by showing a spinner right next to our input field that will show just when the list is out of sync with what's typed in to the input field. This is one of the major benefits that comes with useTransition that we did not get with useDeferredValue. Let's add a spinner that shows when isPending is true. Scroll down just past the search input field, then add a new nav item that shows a spinning icon when isPending equals true or a blank space where the spinning icon would have been. That way when the page renders, there'll be no balance when that spinning icon is showing. Let's see how we did. Bring up a browser window, load our app, type into the search field some letters to search for, and notice the list does update, and there is a spinning icon popping up really quickly next to the search input field. Did you notice it? I barely did. In the next clip, we'll take it frame by frame and explain exactly what's happening.

Verifying setTransition Is Working as Expected
As we typed in a search in our previous clip, the spinning icon flashed so quickly that we could not tell what was actually happening. Say though, for example, our search function that did the todo list filtering was compute‑intensive, meaning that once we type something into our input field, it would take a while for the list to update. Let's simulate a compute‑intensive search, and then we'll see how useTransition helps us by looking at each step as the state updates in our components. Heading back to our code that does the filtering, that's in the ToDoList component. And in our filter function, which executes on every keystroke of the input field, there is a trivial amount of work done to figure out which items in the todo list match the searchText string. That's why the spinning icon barely flashed as we were typing into the input field. Let's change that by introducing a ridiculous for loop that does nothing 300,000,000 times. Lucky for us, JavaScript does not recognize that as a code optimization opportunity, and it will just effectively add a delay to our filter calculation. Back to a running app, bringing up a virtual keyboard so you can see when letters are actually entered, typing first the letter d into our search field. The d does show up in that field along with a spinning icon, but the list does not update until the spinner disappears. Same thing with the second letter. Typing o into the input field, it immediately shows up with the spinner again. And finally, when the spinner disappears, the list does the update. But again, until the spinner disappears, the list does not update. This makes it really clear that the two states we were tracking, one that reflects back what is typed into the input field and the other that is used to render the todo list, are indeed updating at different times and different priorities. The state associated with the input field is tracking updates with high priority, and the state tracking the todo list updates with low priority. Meanwhile, our isPending Boolean is driving our spinning icon, meaning that when the icon is showing, the lower priority state updates have not completed.

Takeaways
You may be tempted to take advantage of many of the techniques that I've shown throughout this module to improve your user's browser experiences. For example, when you look at a flamegraph of most running React apps, it's easy to find lots of components that are rendering that you know don't need to. Don't take the challenge to fix them. In most cases, your browser users will never know the over rendering happened, and you can spend your time working on more important things in your apps. That equally applies to solving state update problems where you know you have high and low priority state updates in your components, and you could optimize them such that the high priority updates happen first. Again, don't do it. Spend your time on more important tasks. However, once you do recognize that you have issues with your application's performance, the methods and API calls taught in this module will go a long way to help you solve those problems. One final thought here comes back to my favorite expression that is when you have a hammer, everything looks like a nail. React gives us some big hammers to solve difficult problems, but don't fall for it. If you don't have real problems, just keep the hammer ready for when you do. And like I've been saying, work on more important tasks.