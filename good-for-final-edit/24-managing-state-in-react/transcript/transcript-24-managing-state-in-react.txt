Course Overview
Course Overview
Hi. I'm Corey House, and welcome to my course, Managing React State in React 18. I'm the founder and principal consultant at reactjsconsulting.com. React apps aren't merely read only. They're interactive. So a typical React app declares literally dozens of pieces of state. And in React, there's a surprising number of options for effectively handling this state, including plain state, refs, context, producers, web storage, hooks, and more. In this course, we're going to build a realistic online store using modern state management approaches. Some of the key topics that we'll cover include patterns for declaring, setting, and reliably deriving state, sharing data and logic between components, managing loading, error, and form validation state, tracking unrendered state, and how to choose between different state management approaches. By the end of this course, you'll know how to use a variety of React state management approaches, and you'll understand when each makes sense. You'll be prepared to build complex interactive React apps using modern techniques. Before beginning this course, you should be familiar with React fundamentals such as function components, JSX, and props. I hope you'll join me on this journey to learn modern React State management techniques with the Managing React State course at Pluralsight.

Deciding How to Handle State
Target Audience and Prerequisites
Most React apps are interactive. They allow users to create, remove, and change data over time. You're about to learn how to use React to manage state. At the end of this course, you'll understand a variety of options for storing React data, when to choose different approaches, how to move state to parent components, and when to consider reaching for more powerful tools for sharing state across your app. This course was created using these versions of React and React Router, and this course is 100% applicable to these React versions. This course is intended for two audiences, new React developers and developers who already know React but want to improve their state management skills. Now if you're fairly new to React, you'll learn over eight different ways to handle state. And if you're more experienced, you'll pick up a variety of useful state management approaches along the way. This course will give you a clear mental framework for effectively handling state. To follow along, I assume that you're already familiar with React's JSX and you understand how to declare a React component. If you're not generally familiar with these concepts, then I recommend watching an introductory React course first.

Agenda
In this module, our goal is to establish a mental model for strategically thinking about React state. We'll begin with a brief history of React state management approaches. Then, we'll dig into eight different ways to handle state in React and consider questions that you can ask to help you pick a given approach. And anytime we store React state, we have to pick a JavaScript data structure. So, we'll briefly explore the options.

A Brief History of React State Management
React state management has evolved over the years. When React was first created, only class components existed. An experimental context feature also supported global state, but it was not recommended for public use. So at first, classes were the only practical way to handle component state. Since React offered no public friendly way to handle global state and functions, Facebook released a separate library called Flux that supported handling state and functions in centralized stores. A few months later, Redux was released. Redux built upon the ideas popularized by Flux. Today, Redux remains a popular way to handle state in React apps. But to clarify, Flux and Redux are not part of React. They're both separate projects that complement React, but they became so popular that they're worth mentioning here. This course focuses on state management approaches that are built into React. Since Flux and Redux are separate libraries, we won't cover them in this course. In October 2015, function components were introduced, but they were stateless. So at the time, there was no way to declare state and function components. In March 2018, a new stable Context API was added. The Context API is useful for sharing data and functions with many components or your entire app. In February 2019, hooks were released. Hooks allow us to manage state and function components. So as of React 16.8, you can do nearly everything with function components. In this course, we'll implement state, use the Context API, and use hooks. Plus we'll handle state in a variety of other ways that aren't listed here.

Eight Ways to Handle State
So what is state? The word state is overloaded. If you check the dictionary, there's over a dozen definitions. For our purposes, I'll define state as app data that may change over time. In React apps, there are at least eight different ways to handle state. And in this course, we're going to implement all eight. Let's briefly explore each. Now, before I run through the eight ways to handle state, I want to mention environment variables. Environment variables are useful to store environment‑specific settings that don't change at runtime. Environment variables aren't specific to React. They're supported on all operating systems, and they can be read during your app's build process. Now if you're using create‑react‑app, support is built in for reading environment variables at runtime. So if you prefix an environment variable with react_app, then create‑react‑app will replace that value with the associated environment variable. For example, you could store a base URL for service calls in REACT_APP_BASE_URL, or you could enable a feature in a given environment using an environment variable that looks something like this. In summary, consider environment variables when you want to specify static settings for a given environment. Okay, with this side note out of the way, let's move on. In React apps, there are at least eight ways to handle state. Throughout the course, we'll implement all eight of these. Let's briefly look at each. Option 1 is to store state in the URL. This is useful for tracking where the user is in the app, as well as their current settings. Here's a few examples of location‑related information that should be stored in the URL, the current item being viewed, as well as filter, pagination, and sorting settings. Keeping location‑related data in the URL means that your users can share deep links with others. And to avoid the URL in your app getting out of sync, it's useful to avoid storing such information in your app state. Use the URL as the system of record. Read from it as needed for such information and update the URL as needed when such settings change. Now React Router isn't part of React, but it's a popular third‑party library that helps with these concerns. We'll use React Router to handle our URL‑related state in this course. The second option is to store state in the browser via web storage. This is useful when you want to persist state between reloads or even reboots. Examples include cookies, local storage, and IndexedDB. These are native browser technologies, so they're not specific to React. So we won't explore these in detail in the course, but you should be aware of these as a valid option for storing data. And keep in mind, data persisted in the browser is tied to a single browser. So if the user loads the site in a different browser, their data won't be available. And avoid storing sensitive data in the browser since the user may access your app on a shared machine. Some examples of where web storage might be useful include storing the user's shopping cart or storing partially completed form data. Option 3 is local component state. This is useful when one component needs the state. Common examples of local state include form data, component settings, and lists that are used by just one component. Often, the same state is used by multiple components. In those cases, it's useful to lift the state to a common parent. Lifting state is a two‑step process. First, you declare the state in a common parent component. And then, you pass the state down to child components via props. Consider this pattern anytime a few related components need to use the same state. Lifting state avoids duplicating state in multiple components and thus helps assure that your components all consistently reflect the same state. Sometimes you don't need to declare state at all. If there are existing values that can be composed to give you the info you need, then you can calculate that information on each render instead of storing it. Some examples include calling .length on an array to determine how many records there are instead of storing a separate numItems, variable or deriving an errorsExist Boolean by checking if the errors array is empty. So, why bother deriving state? Well, deriving state avoids your state values getting out of sync, which can lead to bugs. And it simplifies your code since you don't have to remember to keep separate values in sync. When you update state, any derived values are automatically recalculated and rendered. React supports handling state via refs as well. There are two scenarios where refs are useful. Refs can hold a DOM element reference. This was their original primary use case, and it's why they're called refs. Refs are useful for managing uncontrolled components. Uncontrolled components are form inputs where React doesn't control their value. Refs are also useful for interfacing with third‑party libraries that aren't built for React. Second, you can use refs to store values that aren't displayed. Some examples of this include tracking if a component is mounted, holding a timer, or any data that I want to keep between renders such as the previous value that was held in state. This can be useful for features like undo and redo. If you have data and functions that are used by your entire app or by a significant portion of your app, React's context can be useful. Context avoids having to pass props down to every component that needs a given value, commonly called prop drilling. Examples of state that you might want to store in context include the logged‑in user, authorization settings, the selected theme, and internationalization settings. The final option is to handle some of your app state via a third‑party library. A few popular options include Redux, Mobx, and Recoil. And there are also specialized state management libraries for handling data that you fetch from API calls. A few popular remote state libraries are react‑query, SWR, or, if you're using GraphQL, consider Relay or Apollo. We'll explore the merits of some of these options in the final module. Here's a summary of the options we just discussed and when to use each. Now don't worry if this all doesn't make sense quite yet. In this course, we're going to use all these options. So I'll show a realistic example of when to consider each of these options.

JavaScript Data Structures
When declaring state, you also need to choose a data structure. React is a JavaScript library, so we're limited to using JavaScript data structures to declare our state. JavaScript primitives include Booleans for true and false, Strings for text, Number for numbers, BigInt for big numbers, and Symbol for storing a unique identity. JavaScript also offers multiple non primitives, which can hold collections of values. Objects have properties, and Array stores a list. But keep in mind there are a few other interesting options. Map holds key value pairs. So it's like an object, but it remembers insertion order. And unlike objects, any value can be used as a key, even an object. Set holds a collection of unique values. So a value in a set can occur only once. There are also weak versions of Map and Set called WeakMap and WeakSet. With the weak versions, if there's no reference to the objects inside, their contents are garbage‑collected. All the primitives on the left are immutable. They can't be changed. So when you change the value, you create a new instance. Unlike primitives, collections are mutable. They reference a spot in memory. As you'll see, in React, we should treat state as immutable. So when we're working with collections such as objects and arrays, we'll need to treat those carefully. So we'll look at approaches for handling state in an immutable‑friendly manner later in the course. Next, let's wrap up with a quick summary of what we've covered so far.

Summary
Let's quickly review. In this module, we briefly covered the history of React's state management approaches. React started with just classes. But today we can manage state and functions via hooks, and we can share state and functions via context. We also looked at eight different ways to handle state in React apps. We'll implement all eight of these approaches throughout the course. And most of these approaches have a dedicated module. And if we're going to store state, we need to choose the data structure. JavaScript offers five primitive data structures and around five mutable collections. Throughout the course, we'll use many of these. In the next module, let's code. We're going to build a shoe store to implement these concepts. So I'll introduce the demo, and we'll start out by managing state and function components.

Managing Local State and Remote State
Intro
[Autogenerated] Nearly every app needs to perform two common tasks, first store local state that changes over time and second request data from a remote server. So in this module, we'll focus on approaches for handling local and remote state. We're going to build a realistic shoe store app. I've designed this app to contain many of the common challenges that you'll face in react apps. Today, we'll start by handling local state via use state. Then we'll focus on remote state by calling a locally hosted mac API. I'll show how to effectively use, use effect to make async calls. We'll handle loading state, we'll handle errors and declare an error boundary. We'll use both promises and async await for async tasks and we'll create our own custom hook for handling fetch calls. You'll love how this streamlines our co to get started. Let's set up the demo.

Setup Demo
To begin, you need to install Git. Git is a source control tool. But don't worry. You don't need to understand Git to follow along. It just needs to be installed. You can download Git from git‑scm.com. When installing Git, the default should be just fine. Second, you also need to install Node.js. Node lets us run JavaScript outside the browser. We'll use Node to run our development environment. You can find Node at nodejs.org. Node offers both a long‑term support and an experimental version, and I suggest using the long‑term support version. To check your version of Node, you can run node space ‑v on the command line. The demo I'm providing was generated using create‑react‑app. I'm going to use VS Code as my editor, but you don't have to use VS Code to follow along. And I'll be using Prettier to format code along the way. If you'd like your code to be formatted, the same as mine, I'd suggest installing the Prettier plugin for your editor and then configuring your editor to automatically run Prettier each time you hit Save. If you're using VS Code and you want to auto format your code with Prettier each time you hit Save, then install the Prettier extension. Then search settings for Format on Save and check that box. See the Prettier docs for instructions for other editors. And again, using Prettier to format your code is totally optional. So you don't need to set this up to follow along. But if you do, then your code formatting will exactly match mine. Before we start coding, I want to clarify my approach. This course is focused on state management, so I'm deliberately omitting some unrelated concerns. For simplicity, I'm not using prop types or TypeScript, but I highly recommend using prop types or TypeScript in your apps to help document and enforce the props passed to your components. To keep things simple, I'm providing a single plain CSS file. I typically use CSS modules or CSS and JS in real applications. To save us time, I'll provide some code that you can copy and paste. This way, the code that we write will focus on state management concepts instead of you having to spend time writing CSS and JSX. All right, let's dig into the demo. I've provided a starter app that we'll enhance throughout the course. To begin, click on exercise files on the course home page. Open the zip file. Inside, you'll find numbered folders for each module. Inside each module folder, you'll find a before and after folder. The before folder contains the code for starting the module, and the after folder contains the final code for the completed module. Note the 03 folder. That's the folder for this module. Open the before folder in your editor. I've opened the before folder out of the 03 folder inside my editor. I'm using VS Code, but you can use whatever editor you like. I like VS Code because it has a built‑in terminal. You can view the terminal by going to View and selecting Terminal. In the terminal, run this command, npm install. This may take a few minutes. It will install all of our dependencies for the course. If you're not using VS Code, then you can run the npm install command on your operating system's command line instead. Once the install is complete, run this second command, npm start. You should now see the app running in your default browser on port 3000. Let's take a look at the app. I generated this project using create‑react‑app. I made some tweaks to the initial app to get us started quickly. Let's look at package.json. I changed the start script. It starts both the app and the mock API at the same time. The mock API runs on port 3001, and it's served by an open source API called json‑server. Json‑server reads from this db.json file. This file is named db.json because it's our database. Inside, there's some JSON. There's an array of shoes listed under products. To see the API running, we can open a separate tab and go to localhost:3001/products, and you should see the product data returned from our mock API. I've placed a few React components in the source directory. Index.js is our entry point, and inside it calls the App component. The App component contains the app's layout, and it calls the Header and Footer components. I've also provided some extra JSX that I've commented out up here that we'll use in a moment. The App component displays a drop‑down for filtering the shoe list. I also provided a couple of functions under services that will make it easy for us to call our mock API. These functions use fetch to make HTTP calls. And under the public folder, I have provided some product images that we'll use to display our shoes. And for a more detailed overview of what I just described, check out README.md. In the next clip, let's dig in and start implementing state.

Declaring State with UseState
This module is mostly coding. We're going to implement the shoe listing page first. Along the way, you'll see why state is necessary. We'll fetch data from a service and store it in state. We'll implement a filter for the list of shoes and update the state that's displayed. We'll handle errors and display a friendly page when they occur. We'll call the useState and useEffect hooks to make all this happen. So along the way, we'll explore the rules of hooks. And to close out the module, we'll implement our own custom hook to streamline fetching data. Since we're building a shoe store, let's display a list of shoes. In db.json, there's shoe data. Let's copy and paste this array into the top of App.jsx. So I'm going to come down here just above the shipping address and copy right up here to this start of the array. Then, jump back over to App.jsx. And let's paste this array up at the top and call it products. I'm going to scroll to the top and then collapse this down. Don't worry. We'll request this data via an API call in a moment. I'm just keeping things simple to get us started. Let's display the list of products via JSX. First, let's scroll down and declare a new HTML section right below the existing section. You might not typically use the section tag, but it's often a better choice than a plain div. The section tag better describes what we're going to place inside. We're going to have a separate section here. We have a section for filters up above, and we're going to have a section for displaying products down below. As a side note, if you're ever torn on what HTML tag to use, search for HTML5 flowchart. This flowchart will help you avoid always using a div or a paragraph tag. Just remember, there are many other useful and more descriptive HTML tags to consider. Let's assign an ID of products to this section, and that will also apply some CSS that I've already prepared in the App.css file. We can iterate over the array of products that we declared up above using map. And we will call the renderProduct function that is up above for each element in the array. JavaScript's map function runs a function for each element in the array and returns a new array. Check MDN to learn more about map. So let's scroll up here and uncomment renderProduct. Now, when I save my change, I immediately see the shoes displayed. I should clarify that map automatically passes the product to the renderProduct function. This is called a point‑free style. We could explicitly pass the product using an arrow function, but it's not necessary. You may also prefer to place this JSX inside the map call so that it all reads inline, but that's really just personal preference. Either works. Let's start exploring React state by implementing our first feature. Scroll back up and look over the shoe data. Each shoe is available in specific sizes. I'd like to filter the shoe list by available size. Sizes are stored under SKUs. SKU stands for stock keeping unit. A SKU is used by retailers to identify inventory. Think of the SKU as a unique ID for a product with a specific size or color. To declare our first state, we'll use the useState hook. The useState hook allows us to declare state inside function components. First, come to the top and import useState. Then, we can declare our state at the top of the App component. I'm going to store our state using a const. And our call to useState is going to return an array of two items, the state and a setter function. For our state, we're going to call it size. And for the setter function, we'll call it setSize. Traditionally, the setter has the same name as the state but has the word set on the front. So we will call useState. And then, inside our parentheses, we can specify our default. I'll default it to an empty string. So this line says declare some state called size and a function to set the size called setSize. Default the size to an empty string. Now, this may look weird to you. We're using a JavaScript feature called array destructuring. Array destructuring lets us declare a variable for each element in an array. Remember, useState returns an array of two items. So this is declaring an identifier for each of those items. To clarify what we're doing here, you may find it clear to declare state on separate lines doing something like this. I could say const state is equal to useState, and then I could say const size is equal to the first element returned from our useState call, and const setSize would be equal to the second element returned from the state call. However, there's no good reason to write this extra code. We can use array destructuring to do it on a single line. So I'll undo my change. We just declared our first hook. Let's step back for a moment and talk about hooks.

The Rules of Hooks
React offers many hooks for enhancing function components. This course is focused on state. So, we'll focus on state‑related hooks. We'll primarily use the useState and useEffect hooks since you can build just about anything with these two powerful building blocks. But there are also dedicated modules for other state‑related hooks like useContext, useReducer, and useRef later in the course. There are three rules for hooks. First, hooks are for function components. They can't be declared within class components. The second rule is they must start with the word use. That's why React hooks are called useState, useEffect, and so on. Third, they can only be called at the top level. They can't be nested in functions. Hooks must be declared in the same order for each render. So they can't be called inside functions, conditionals, or loops. This example breaks the rules of hooks. You can't wrap a hook call in a conditional. So this if statement wrapped around the call to useState is a problem. React requires hooks to be called in the same order on every render. So you cannot wrap them in a conditional. This example also breaks the rules. You can't nest a hook call inside a function. Hooks must be declared at the root of the component. Again, this assures that hooks are run in the same order on every render. You might wonder why. Well, React tracks the order that hooks are run behind the scenes. This way, it can store their corresponding data. So these rules are necessary to assure that the hooks are run on every render in the same order. These rules may sound constraining. But as you'll see, they're not a problem in practice. If you need to run a hook conditionally, then you can place the condition inside of the hook.

Implementing Event Handlers
Our app contains a size filter over here at the top. I can change the value right now, but nothing happens. The drop‑down is currently an uncontrolled component. That's a fancy way of saying that React isn't controlling the selected value to make it a controlled component, we can specify the size. So set a value property to the size state that we declared in a previous clip. Now, unlike a native HTML select, we declare the selected value using a value prop. Now that we've added this value prop, the select is a controlled component. And by controlled, I mean that React is controlling the value. Note that when I change the drop‑down, the selection doesn't stick. That's because React is controlling the value now. So we need to update state when the drop‑down changes. To do that, we need to declare an onchange prop. React has a synthetic event system. The good news is you don't really need to learn much to work with it since it operates nearly exactly the same as the browser's native event system. So, why does it exist? Well, for two primary reasons. First, it assures that events operate consistently cross‑browser. Second, the synthetic event system helps improve performance by strategically binding event handlers. There's a variety of event handlers available in plain HTML. React's synthetic event system offers all the same event handlers except each event is camelCased, as you can see here. We're going to set an onchange handler on our select input. Inside the onchange handler, we can either call a separate function or declare an inline function. The change handler will automatically be passed an event, which I will alias as e. And we will call setSize and pass e.target.value as the new value for state. If I come over to the browser now, if I change the drop‑down, now my selection sticks again because we're updating state on change. And to clarify why the event handler works, I could come over here and add some curly braces around my arrow body so that I can set a debugger inside. Now, if I open the dev tools in the browser and I change the drop‑down, we'll hit our debugger and we can see the synthetic event. If I hover over the event, I can see that event.target has lots of different properties. But if I scroll all the way to the bottom, one of them is value. So this is why I'm saying e.target.value because that is the attribute that contains the selected value. So if you ever forget what elements are available on the event, just be sure to go inspect the event and look at under event.target and you'll find all the metadata about the event that had just occurred. Now that we've seen the debugger work, we can remove the debugger and put this back on one line. We just saw how to use the debugger to inspect our code. But another useful tool for working with state is the React developer tools. Let's install that in the next clip.

React Developer Tools
The React developer tools are a useful browser extension that's supported by the React team. The developer tools make it easy to view your React component state. They're available for both Chrome and Firefox. I'm using Chrome, so I'll install it from the Chrome store. And I already have it installed. Otherwise, this button would allow me to install it. Once it's installed, if you open up your application and then click Inspect, you'll see two new tabs in your dev tools, the Components tab and the Profiler tab. The profiler is for performance testing, which we won't focus on in this course. The Components tab is where we'll spend our time. If I select the App component over here in the tree, I can see the associated state. I can see right now that that state is empty. But if I come over here and select a value on the drop‑down, then that new state is reflected down here in the dev tools. Now you might wonder why it's not labeled as size since that's the identifier that we're using. The React dev tools merely list hooks in the order that they were run. So if you have multiple useState calls, they'll be displayed here in the order that they're invoked in your code. Our drop‑down is looking good now, but it's not actually filtering our list of shoes. In the next clip, let's use derived state to implement that.

Implementing Derived State and Exploring When React Renders
Let's filter the list of shoes. The good news is this will require very little code. We don't need to declare any new state. We already have the data that we need to filter the list of shoes on each render. To do that, we can declare a variable above the return statement. Let's declare a variable called filtered products because it's going to be a filtered list of products based on the size that someone has selected. Now we're going to check the size because size may not be selected. If size is selected, then what we want to do is filter the list of products. We can use JavaScript's filter function to filter our array. Filter accepts a function that returns a Boolean. Filter returns a new array, and it filters out the values that we specify within a function. So for each product, we want to filter based on the SKU selected. We can look through the product's SKUs and use JavaScript's find function to see whether the SKU's size matches the selected size. So we'll look for a SKU, which I'll represent with the letter s. And if the size is equal to the size selected, which I will parse as an integer. If a size isn't selected, then instead, we'll just return the unfiltered list of products. So line 62 says look through the list of products and filter out any that do not have the selected size. Now that we've created our filtered list of products, we can put it to use down here where we're iterating over products. Instead of saying products, we can say filteredProducts. And I'll save this change. And we should find now if I select sizes, I see different shoes available based on the sizes available for that particular shoe. So, how did that work? Well, let me briefly discuss when React renders and how derived state works. React rerenders a component in four situations, when state changes, when a prop changes, when a parent renders, or when context changes. That's why we need to declare state for data that changes over time. If we use a plain variable, React won't rerender the component when it changes because React won't be watching for that variable to change. When state changes, our component renders, which causes our derived state to be recalculated. So we don't have to worry about our derived state getting out of sync because it's recalculated on each render. Let's implement another piece of derived state. It would be nice to display a message about the number of items found. Let's display that message below the filter. So I'll put it here right below the drop‑down for sizes. Put in a curly brace. And I will check to see whether there is a size selected. And if a size is selected, then I'll display an h2 that says found and then displays the number of matching products. So I will use the filteredProducts.length, and then put the word items after it. I'm using the logical and operator here. It only runs the right‑hand side if the left‑hand side is truthy. So, if a size is selected, it will render the h2. So this works a lot like an if statement. If the size is true, render the thing on the right. Now, each time I select a size, I have a header that labels how many items have been found. And each time I select a size, the component renders, and this derived data is recalculated. Later in the course, I'll show how to handle derived state that's expensive to calculate. Next, let's get rid of the hardcoded product array above. Instead, we can get our data from the API using the useEffect hook.

Fetching and Storing Data via UseEffect
To fetch data from an API, we can use the useEffect hook. The useEffect hook runs after each render, but we can configure it to run only after the first render too. If you've worked with class components, useEffect is like a lifecycle method that you can configure to run at different times. First, let's delete the hardcoded product data. Then, at the top, let's import the useEffect hook. We declare useEffect inside the component. I'll go ahead and declare it here below our useState call. UseEffect takes two arguments. The first argument is a function. I'm going to declare that function using an arrow function. Whatever we declare inside this function will run each time that the useEffect runs. We want to request a list of products from the mock API. In the services folder, you'll find that there's already some JavaScript functions that I've provided to save us some time, products function. It uses fetch to call our mock endpoint, and it returns from JSON. So at the top of our App component, let's import the productService. And the function that we want is getProducts. Then, we can call this function inside useEffect. We'll say getProducts, and getProducts expects us to pass it a category. For now, I'm going to hardcode in shoes. Later we'll read this from the URL. So this says call getProducts after each render. We need to handle the response. The getProducts function is asynchronous, so we can handle the response using a promise. But the question is, where are we going to store the data? So we need to declare some state to hold the product's response. I'll declare a const, and we'll call the state products. We'll create a setter called setProducts. And we will initialize our state for this to an empty array. Now we can store the results in state by handling our promise down here. So I'll say .then, and I will take the response that I receive and call setProducts. I'll pass that response in. The moment I hit Save, the shoes reappear. However, there's an ugly bug. Remember, by default, useEffect runs after every render. So if I open my dev tools, you can see I have an infinite loop. I can also see this if I open the dev tools in the browser. If I go to the Network tab, you can see that requests are happening in an infinite loop. So we need to pass the second argument to useEffect, which is where we specify when it should run again. I'll put in an empty array. And the moment that I hit Save, notice how everything calms down. And hopefully the fan on your laptop stopped spinning like mine. So this second argument is a list of reasons that this useEffect should rerun. This is called the dependency array. By declaring an empty array, I'm saying run this useEffect only once after the first render. So you can think of this array as a list of reasons that useEffect should rerun. Any state or props that we reference in this array will cause useEffect to rerun when they change. We just implemented our first API call. But there's actually a number of ways to do this, so let's step back and discuss the options.

Four Ways to Handle API Calls
Broadly, there are four ways to handle API calls in React. The simplest approach is to make your API call inline inside your component, typically using fetch, Axios, or whatever library you prefer for making HTTP calls. With an inline call, you directly call fetch, Axios, or the HTTP library of your choice directly in your component. This is simple and direct. However, inline calls like this make it hard to ensure that you handle API calls consistently across your app. And calls like this can't be reused since they're embedded in a single component. So, I don't recommend declaring inline calls. Option 2 involves handling API calls in a centralized spot. With this approach, we create a function that calls fetch, Axios, or whatever library you prefer. I've provided some functions in the services folder as an example. Then, you import the separate function and you call it. In this example, a getUsers function is being imported and then called within useEffect. So the centralized function approach is what we're doing right now. We imported the separate getProducts function that actually calls fetch. So our component doesn't directly fetch anything. This helps enforce consistently handling API calls, and it fosters reuse by handling all calls in a few centralized functions. Option 3 is to create a custom hook to simplify state management and eliminate redundant code. We'll do this at the end of this module. Finally, option 4 is to use a third‑party library that handles all this for you and more. We'll do this in the final module.

Handling Errors via Error Boundaries
We've successfully implemented our first API call. But what if our API call fails or an error occurs in one of our components? We can declare a React ErrorBoundary to show a friendly message to the user. React's documentation provides a basic ErrorBoundary, and I'm just going to copy right out of here. And then we'll paste it into a new file called error‑boundary.js. I'm going to place that under the src directory, and I'll call it ErrorBoundary.jsx. An ErrorBoundary must be a class component. This is our first class component in the course. This component declares some basic state for tracking whether an error has occurred, and this hasError state gets set to true in getDerivedStateFromError. This function is called any time an error occurs. We don't need the componentDidCatch, so I'll delete that. And inside of render, if there is an error, it will display this h1 tag that something went wrong. Otherwise, it will render whatever child components are nested underneath. Next, let's open up index.js to put this to use. We can import the ErrorBoundary, and it should be in the same directory as index.js. Then, we can wrap our App component. And I'm going to move the App component up inside of here. As a little tip, I'm using the Alt+ arrow up/down here to be able to move code up and down in VS Code. We can see an error in our application that React is not defined. So open up ErrorBoundary. And at the top, we need to import React. And we need to export default this class. And with those changes, now we have our ErrorBoundary configured. Since we've wrapped our entire application over here in index.js, any error that occurs within our application will be caught by this ErrorBoundary with a few exceptions. Keep in mind that error boundaries do not catch all types of errors. They don't catch errors for event handlers, async code, server‑side rendering, or errors thrown in the error boundary itself. To see our error boundaries work, let's open up the productService, and let's change the ul to make it break. I'll hit Save, and now we can see that the application fails to load. So we're not doing a good job of handling this error at this point. The error isn't being caught because it's happening in asynchronous code. Remember, error boundaries don't catch errors in async code. But let me show you a simple way to handle async errors using the error boundary. To handle the errors, let's go back over to our application, and let's create some new state to hold any errors that might come back from our API. We'll say const error setError = useState null. So this declares some state called error with a setter for that state called setError, and it defaults our state to null. Then, down here on our promise, we need to add a .catch so that we can catch any errors returned from the API. We will alias that error using e to represent the error. And then we'll call setError and pass the error in as an argument. Finally, if an error is set in state, we can throw it before we try to render JSX. That way, our ErrorBoundary will take over and display if an error occurs. So down here, before we return our JSX, we can add our check to say if error is set, we will throw the error. Now, when I hit Save, we see an error displayed. Now you might wonder, why don't we see our error boundary? Well, our error boundary would display in production. But in development, the error stack displays by default. You can click the Close button up here to see what the user will actually see. And now we can see something went wrong. So we are seeing our error boundary displayed. This is what the user would see if an error occurred in production. Let's go back to our productService and fix the URL that we broke earlier. I'll hit Save again. Now the application reloads. So what if the API call takes a while? Let's handle loading state next.

Handling Loading State
We're requesting data from a local mock API. It's very fast, so the data displays immediately. But what if the API call is slow? To handle that, we should properly handle loading status. First, to see the problem, let's configure our mock API to return data more slowly. Open up package.json. Down here on the start‑api script, you'll notice that there is a delay setting here. I'm going to set the delay to 1000. This means that it will take 1 second before it responds with data. Now that I've set it, go down to your terminal and hit Ctrl+C to stop the application. Then, run npm start again so that our delay setting will take effect. When the app restarts, you see that we now have a 1‑second delay before our shoes actually display. And notice that if I refresh the page, I'm looking at a blank white page before those shoes come back. So in app.js, let's declare some state to track whether loading is in progress. Up at the top, I'll say const loading, setLoading is equal to useState. And I will default loading to true because we'll assume that when the page first starts loading, we will be in a loading state. When the getProducts call is completed, we want to set loading to false. We can do this via a .finally on our chain of promise handlers. So in our finally, I'll declare a function that sets loading to false. Note that I'm using .finally here rather than handling this up within the .then. The advantage of this is if an error occurs or a successful response is returned, in either case, this finally will run. That way we know that the loading state will always be set to false in either case. Now we can use this loading state to display a loading spinner. I provided a spinner over here in the src directory so we can import it. Then, we can put it to use down here right before we return. Remember, since return returns our JSX, anything we do before this will end up rendering instead. If we return early here, when loading is true, then only the spinner will render. So if loading, we want to return the spinner. Now, we can see over on the left that when I refresh the browser, I see a spinner for a moment, and then our application displays. We just used a promise to make an async call, but you can use async/await if you prefer. In the next clip, let's refactor our code to use async/await.

Implementing Async/await in useEffect
We just use promises to handle the API response, but you may prefer to use async/await instead. However, if I try to decorate this function as asynchronous, I immediately receive a warning, and the warning is that effect callbacks are synchronous to prevent race conditions. Put the async function inside. So you can see that we get a helpful error message that says if I want to use async/await, I need to declare the async function inside of my arrow function. So I basically need to nest an async function inside. This means that I need to remove my async decorator here to keep that arrow function a normal synchronous function. And then here, I can create a new function, which I could call async function, and I can choose my name. I'll go ahead and call this function init because it really is initializing our page. I need to add a closing curly brace down here as well, and then it lays out properly. Since I have declared this inner function, I need to execute it right below. Now when I hit Save, the application loads again. The code runs the same as before. But traditionally, with async/await, I would use the await keyword on any asynchronous calls inside. And I would also traditionally use try/catch for error handling. So let's refactor this to use async/await. I can say try to do this. I want to get products. And remember, getProducts is an async call. So I can hold the response by calling await right here. Now that I have the response, on this next line, I can call setProducts. Then, instead of a .catch, I would use a traditional try catch. So I can take this out, and I would be catching the error which I will again represent using the letter e. And inside of here, if an error is found, I will call setError. Then I'll close my curly brace, and I'll add my finally block. So I don't need this.finally anymore. Call setLoading to false and then close that. Great. The app loads just fine as before. This code does the same thing as the promise‑based code. Async/await is merely syntactic sugar over promises. So the great news is you can mix and match promises and async/await. You can use either approach, just whatever you feel like. We're now handling remote state successfully via useEffect. Now that we've implemented the loading state, let's remove the delay from package.json so we can enjoy instant responses from the API again while we're developing. So open up package.json and set this delay back to 0. Be sure to save your changes. Then open up the dev tools. Hit Ctrl+C to stop the app and then run npm start again. Now, if I come back over and refresh the browser, it loads immediately. We don't even see the loading spinner, it's so fast. All right, we've implemented state and function components, but you might have noticed that there's a lot of boilerplate over here in the App component just to handle an async call. So, to close out the module, let's create a custom hook to streamline this code.

Creating a Custom Hook
Fetching data on this page required quite a bit of code. We had to declare loading an error state, declare a useEffect to make an API call, declare a catch to handle errors, and use finally to set a loading state to false. We're going to create more pages that fetch data in the coming modules, and I have great news. We don't have to repeat all of this for each page. To simplify our state management, we can create a custom hook. To create our first custom hook, let's create useFetch.js over here in the services folder. We can move a lot of our fetching logic into this custom hook. Our goal is to create a single hook that makes it easy to make HTTP calls using fetch. First, let's declare the function. Let's call the hook useFetch, and we will export default that function. Our goal is to fetch data and store the related state such as the response, the loading state, and any error that might be returned. Remember that all hook function names must start with the word use. React uses this prefix as an indicator that it's a hook. Again, a hook is a JavaScript function but with a few extra rules. React knows to enforce these rules on any function that starts with the word use. Just like fetch, let's accept a URL. We're also going to declare useState and useEffect in this file, so let's import both of those. Next, we can start cutting code from App.js and moving that logic into our custom hook. First, we know we'll need three pieces of state. We need to hold the data, any errors, and the loading state. So let's cut these three lines of code. Then we'll paste those at the top of our hook. However, we will make a tweak here. Since this is going to be a generic function, it's not necessarily going to be holding product data. It will just be holding data returned from a response. And it will also have a corresponding setter then called setData instead. And instead of defaulting to an array, we'll just default to null. Next, we need to implement the useEffect to handle making the API call. So let's come back over to App.jsx and we can cut this entire useEffect and move it over to our custom hook as well. Let's put the useEffect right below the useState calls, but we do need to make a few tweaks. Right now, it assumes that it's going to be calling getProducts. But what we want to do here is use fetch to call whatever URL has been requested. So we will await a call to fetch and then call that URL. Now there is one tweak we need to make here though because we need to declare the baseUrl. If we go look at the product service, you'll see how that's handled. On line 1, I'm reading the baseUrl out of the environment configuration. This environment configuration is specified over in package.json. You can see on this start app line 20 that I am setting an environment variable that declares the baseUrl for our API. So let's copy line 1 and then paste it up here at the top of the file. Now, down here on line 13, we can use the baseUrl and then concatenate the URL requested on the end. Instead of setting products, we will be setting data and passing in the response. The final step is to return data from our custom hook so that the caller can use that data. So down here at the bottom, we will return three items, data, error, and loading. You'll also notice that the dependency array here was automatically populated when I pasted this code in. I have ESLint configured to auto fix any issues. So you'll notice if I try to empty out the dependency array, I receive an ESList warning that says that I have a missing dependency. Since I am dependent upon data outside of this effect, I need to list that data as a dependency, which, in this case, is the URL. So I'll put the URL back in as part of our dependency array. Make sure that you have this here. What this is effectively saying is if anyone ever passes a different URL into this hook, then a new call to fetch data will occur. And there's one final tweak that we need to make up here when handling the response. If you go look at productService, notice that when fetch is called, we need to check the response to see whether it's okay. And if it is, we need to convert that response into JSON. We need to do that ourselves now since we're calling fetch directly. So, down here on the next line, let's say if the response is okay, then we want to say const json is equal to await response.json, and we have to await it because this is an async call to convert the response into JSON. Then, we can set the data, not to the response but to the JSON. And also, if the response is not okay, then we can throw the response. And if we do throw the response, it will ultimately be handled down here in the catch. We've just created our first custom hook, and now comes the fun part. We can dramatically simplify the product's page. Let's do that next by consuming our custom hook.

Consuming a Custom Hook
Now for the fun part. We need to consume the hook. So let's import useFetch from the services folder. And then down here, we can put it to use. Remember that useFetch returns data, loading, and error. So we'll call useFetch. Now we need to specify the URL that we'd like to request. If we look at the product service, we can see that the URL that it was requesting for us was products with a query string of category, and then we were specifying the category of shoes. So let's copy all of this and paste it in over here. However, we will just hard code in a category of shoes for now, and we don't specify the baseUrl. That will be the responsibility of useFetch. Now when I hit Save, we can see that the app doesn't compile. It says products is not defined. To fix this, we need to alias data to products because that's what we're expecting down below. Now when I hit Save, aha, look at that. Our custom hook is working. So App.jsx does the same thing as before, but with much less code. We can also come up here and remove some unused imports. We're not using the product service anymore. And we also aren't using useEffect anymore. The page still works fine but with a lot less code. Love it. Let's compare to see how much this simplified our code. Before, our code looked like this, multiple state declarations and a long useEffect. Ah, much better. With a custom hook, now all the logic for handling API calls consistently is centralized and thus programmatically enforced. Jumping between the before and after really emphasizes the dramatic difference. Now we can make an API call, store the result, and handle loading an error state in just three lines of code. And since we're going to make other API calls in the coming modules, all our future components will be much simpler as we reuse the useFetch hook. Custom hooks are the secret to radically simplifying your state handling logic. Let's close this module with a summary and a quick preview of what's ahead.

Summary
In this module, we began by implementing local state. We used the useState hook to declare some local state. Then, we moved on to handling remote state. We used useEffect to run code immediately after the components first render. We explored how to make async calls and effectively manage remote state by calling our mock API. We used both promises and async/await. We saw that they can be mixed together since async/await is merely syntactic sugar over promises. We handled loading state and declared an error boundary at our app root to display a fallback UI when errors occur. We saw that async calls aren't caught by the error boundary. So, we stored the async call errors in state and then threw them so that the error boundary would catch them and display the fallback UI. We created our first custom hook to radically streamline our HTTP calls into a single line of code. We'll use this custom hook and others in the coming modules. So what's next? Well, most apps have multiple pages. So in the next module, we'll build out multiple pages and routes using React Router, and we'll learn how to manage route‑related state.

Managing URL State and Web Storage
Intro
To build a realistic app, we need pages with unique URLs. So, we need to store state in the URL. React Router is a great tool for the job. It's the most popular router for React. However, it's not part of React. React Router is a separate open source project. React Router is extremely popular because it offers fast, declarative, client‑side routing. So your users can quickly move between pages without posting back to the server. Page transitions can be truly instantaneous. It's quite slick. So next, we're going to use React Router to implement multiple pages in our application. So here's the plan. We'll begin by creating the app layout. Then, we'll declare routes with placeholders, read URL parameters, handle 404s, implement links between pages that don't post back, and redirect the user when buttons are clicked. Along the way, we'll create the product detail and shopping cart pages. This module is all coding, so let's dig in.

Configuring React Router's Entry Point
React Router is already installed since I listed it in our initial package.json. So, let's put it to use. First, we need to configure it in the app's entry point. So open up index.js. Let's import react‑router‑dom, and we will import the BrowserRouter. React Router offers a few different routers, but we're going to use the BrowserRouter since it handles routing in the browser. We can use this to wrap our application. I'm going to put it inside the ErrorBoundary. So that opens the tag, and then I'll use Alt+down arrow to move this down below the App tag. Now that our entry point is configured, all child components will be able to declare routes. So let's start adding routes to our app layout in the next clip.

Creating an App Layout
Our app is now wrapped with React Router, so we can declare routes anywhere in our app. But we only have one page. App.js always displays the list of products. Instead, we need to simplify App.js to merely hold the app's layout and routes. So to begin, let's create a separate page. Create a new file in the src directory, and let's call that file Products.jsx. Now open up App.jsx and copy all the code inside. Then, let's paste that over into Products.jsx. Let's go to the top and make some changes. We can remove the App.css import, and let's rename App to Products. Now that we have a dedicated products page, we can go back to the App component and radically simplify it. First, let's remove all the nested state and functions, all the way down to the final return statement, and remove all the JSX under main. Now we can remove the unused imports, and App.jsx just got very simple. It's merely our app's layout. Now since App.js is responsible for handling the layout, that means that we can remove the layout‑related JSX from the products page. Let's go back to the products page and come down here. We no longer need the header or main or the div with className of content. And same story down here at the bottom. Get rid of main and div and footer. So now the products page is merely two sections. If we jump back to the top of the Products component, we can see that there are now some unused imports as well. So we'll take those out. Let's make sure we haven't broken anything. Jump back to App.jsx and let's import the Products component. Then, let's display the Products component within main. Excellent. The app is rendering just like before, but now we're in a better spot. Our app's layout is centralized in App.js, and we can use React Router to display different pages.

Declaring Routes
Now we're ready to declare routes so that different pages display depending on the URL. Let's create a product detail page. Under src, say New File and create Detail.jsx. I've provided Detail.jsx in the begin folder for this module to save you some typing. So open up the module numbered 04 and find Detail.jsx in the before folder. I'm going to paste in the content here. Note the commented out JSX that displays product details. In this module, we use React Router to read from the URL and then display these details. But for now to get started, just a header will display on this page. Let's also create a Cart page that will display our shopping cart. Right‑click on src, New File. Inside here, import React and then export default function cart. For now, our cart will simply return a header of Cart. Now we have different pages to display depending on the URL. Let's go over to App.jsx, and we can declare our routes there. To declare our routes, we need to import two items from react‑router‑dom. So I'm going to use an import statement, and I'll import from react‑router‑dom. And I will import both the Routes component and the Route component. Let's also import the pages that we just created, which is the Detail page, as well as the Cart. Now we can declare the routes inside our layout. First, we need to wrap our routes in the Routes component. We'll place the Routes component inside main since the page will change within this section. The rest of our layout will be static. I'll move our product page inside of Routes. The next decision we need to make is what URL should we use for our product page. For now, let's just load the product page on the baseUrl. I'll use the Route component to declare our route. It accepts a path. So, we will say that the path that matches for our product page is an empty slash. So if you're at the root URL, we will load the products page. And we need to specify that the element that we would like to load is the Products element. Then I can close my route. Now if I hit Save, the products page continues to render like before. Next, let's declare a route for the Detail page and the Cart page. I'm going to copy this line and then paste it twice to save a little bit of typing. For this second path, let's say that the Detail page will have a URL of detail and it will load the Detail component and that our Cart page will load at a path of /cart. Now I need to display the browser's URL bar so that you can see how this is working. So, at localhost:3000, products displays. But if I go to /detail, we see the Detail page. And if I go to /cart, we see the Cart page. This all works fine. But in a real app, you might want richer URLs for some pages that contain dynamic keywords. So in the next clip, let's enhance our URLs to use placeholders.

Declaring URL Placeholders
Our app sells shoes, but what if we decide to sell other products? It would be nice if the product's category was in the URL. Then we could read that state from the URL, and our products page could support displaying different product categories. So, let's stop displaying shoes over here on the home page. Instead, on the home page, let's just display a welcome message. So I'm going to copy this route and create a new route here that merely has some inline JSX. And I'll put an h1 in that says Welcome to Carved Rock Fitness and close the h1. So with this change, now when I come to the home page, I see Welcome to Carved Rock Fitness. So notice that I didn't have to reference a separate component. I can also just place JSX inside the element prop. Now we need to change the products route to have a unique URL. For the path, we can declare a named placeholder using a leading colon. So this says that the first segment of the URL will contain the category. So now if I check the browser and go to /shoes, then the shoes display at this URL. So why did we bother to declare a placeholder for this route? Well, because now we'll be able to read this category from the URL. So, let's do that in the next clip.

Reading URL Placeholders
We've declared a placeholder of category for the products URL, and now we can read this over in our Products component. So, go over to the Products component where we have hardcoded in this category of shoes. Now we'll be able to read the requested category from the URL. This way, our products page can potentially display other product categories based on the URL in the future. To read the URL, we can import a hook that's provided with react‑router‑dom. So first, import from react‑router‑dom, and the hook that we want is called useParams. After importing the hook, we can use it inside our component. So I will call useParams and destructure a value that it provides called category. Now you might be able to guess where I'm getting category here. That was one of the parameters that we declared as our placeholder. So this name of category that you see here corresponds with the placeholder that I declared on line 18 in App.jsx. We're able to read that segment from the URL declaratively here on line 8. I'm using destructuring to get to the category because the params object contains a property for each matched URL parameter. Now that we have the category from the URL stored in a variable, we can use it to replace the hardcoded category down here in our fetch. So I can close this string. And then instead of hardcoding shoes, I can reference category. Let's check the browser. Very good. The shoes page still displays, but there's a bug lurking. What if I request an invalid category? Uh‑oh, I get a blank page. So let's handle 404 pages next.

Handling 404s
If the URL is invalid, we should show a nice 404 page so that the user knows that the URL that they requested is invalid. So, let's go create a 404 page. Over here in src, create a new file, and let's call that file PageNotFound.jsx. Inside, we'll import React. And then let's export default a function called PageNotFound. Inside, we'll keep our 404 page very simple with an h1 that just says PageNotFound period. Now, we can put this to use on our products page. So go over to Products. And at the top, let's import it. So if no products are returned from our useFetch call, we'd like to show a 404 page. We can add this logic below the loading check so that we know that the loading is complete. So let's come down here. We know if loading, return a spinner. Well, we can add an extra check down here to say if products.length is equal to 0, then we should return PageNotFound. Now you notice we're starting to get multiple return statements in our JSX. As I discuss in my Clean C# Principles course, there's nothing wrong with multiple return statements in a function. You can think of these lines as guard clauses. These checks assure that the necessary data is available. Returning early often leads to writing less code, and it helps make the code after the return easier to understand because we know the preconditions have been met. Let's check the browser. Hey, good. Now when I have a bogus URL, I get a message. But if I go back to a valid URL, it loads as expected. Let's enhance the detail page URL using placeholders next.

Reading URL Placeholders on the Detail Page
When viewing the product detail page, it makes sense to have the category in the URL and then the product's ID on the second segment. So let's go back to App.js and change the way that we declare the route. Instead of /detail, let's declare the route to be /category/id. So now we have two placeholders. Let's see if this works. So now if I go to /shoes, it still loads shoes. But if I put in a slash and then a shoe ID such as 1, then it takes me to the detail page. So our routing is working well, but entering URLs by hand is no fun. Let's implement client‑side navigation using React Router next.

Implementing Client-side Navigation
To implement navigation, open up the Header component. Inside, let's import the Link component from react‑router‑dom. Link is like an anchor tag, but React Router handles the click so that the click doesn't cause a page to reload. This way, the navigation is handled on the client. This makes route changes lightning fast, and it retains all client‑side state. It's quite slick. We'll display the nav links in a list. We already have one item in the list, which is our logo, which should be clickable. So inside the li, let's wrap our image in the link tag, and we will link to the home page. And again, I'll use Alt+down arrow to move this down a line and wrap this image with Link. Next, let's add a link to the shoes page and the cart page. So I will add another li, put in a link to shoes page, and I'll put the text shoes in here. And then, I'll add another I and I'll put in a link to the cart at /cart. Let's see how it works. Our links render. When I click on Shoes, I go to the shoes page, Cart goes to cart, and the logo takes me back home. And notice that all of this loads immediately. It's basically showing different components on the client the moment that we click a link. There's one final tweak that we can make over here in our navigation. Since these are navigation links. Instead of importing the Link component, we can use the NavLink component for a few of these. NavLink has one extra trick. It allows us to set an active style when the route matches. So come down here to the text links here that we've declared for shoes and cart and change Link to NavLink. Now this will still operate the same as the moment, but NavLink has one extra prop that it accepts, which is an active style or an active class, which it will apply when that link's path is active. Let's declare a JavaScript‑based style up here above, and I will call it activeStyle. And we'll say that when the link is active, it should have a color of purple. So I'm using React's built‑in styles, which use an object to declare a style. And now down here, I can say that the activeStyle should be the activeStyle class up above. Then I'll do the same thing down here on this NavLink. Let's save our changes. Let's see if it works. There we go. Now, when I'm at the home page, all links are orange. When I click on a link, it becomes purple. So now we've seen how to style the active link using the NavLink component. And we stuck with a plain link tag here since we didn't need that extra functionality of activeStyle. You could technically use a NavLink in other places, but the link was really all we needed right here. We can also use Link on the product page so that we can navigate to the product detail page when we click on a product. So open Products.jsx. And at the top, let's import Link from react‑router‑dom. Then, we can change the anchor link that I provided down here, which was hardcoded to an empty slash. Instead, we should use a link here, and I'll update the closing tag for that anchor as well. Remember that Link does not accept an href. Instead, it accepts a prop of 2. The URL that we want to link to is going to contain the category and the ID. So, let's use a JavaScript template string to declare this. I'm going to put in a backtick and then a slash and then a dollar curly brace because I want to reference a variable, which is category. Then I need another slash, and I want to put in the product's ID right here for the second URL segment. So now, when we click on a product, it should redirect us to the relevant detail page URL. Be sure to save your change and let's give it a shot. If I hover over each one of these products, you can see in the bottom left hand that I am getting a dynamic URL. So when I click on 1, I go to 2, click on product ID 2, I go to 2. Our app is coming together. We're now loading the detail page with the desired product ID in the URL. So in the next clip, let's read the URL state and display the relevant product details.

Fetching Based on a URL Parameter
To display the product details, we need to read the product id that you see up here in the URL. We can use React Router's useParams hook to read that portion of the URL. Open Detail.jsx. And at the top, we need to import from react‑router‑dom. And this time, what we want to use is the useParams hook, which allows us to read URL parameters. So we can put this to use on the first line of our component. This time, we're going to destructure the ID from the object that it returns. And again, this ID corresponds to the ID that we specified in the route over here on line 19 in App.jsx. So now we know the product ID and the URL, and we can use it to request the product from the API. And here's where that custom hook we created in the previous module becomes handy. This will require very little code. To practice what we've learned, I encourage you to try to implement, displaying product details yourself using the useFetch hook that we created earlier. As a hint, the URL for fetching product ID 1 is products/one, and this ID variable holds the product ID that we want to load. Pause now if you'd like to try displaying product details yourself using the custom useFetch hook. Welcome back. Let's try requesting product details from the API. At the top, first, we need to import useFetch. Now, in a single line, we can call the API and declare state to store the result, loading, and error state. We can put this right below our useParams call. So I'm going to declare a const and store the data, the loading, and the error properties that are returned from calling useFetch. And the URL that I want to request is going to be products/dollar{id}. So I'm using JavaScript's template string syntax here. Again, be sure to use the backticks around this so that you can declare variables inside that template string. Now I'm going to make one other change over here. I'm going to alias data to product since that's what data represents here. We'll be receiving a single product back. And that's it. Remember, our first API call required three useState hooks, use effect, try/catch/finally, and carefully setting error and loading state inside. Now we're doing all of that in one line of code. That's why hooks are so awesome. Let's show a spinner while the data is loading. So, above our header, we can add a check and say if data is loading, then return the spinner. Now notice, as I start to reference the spinner, VS Code is smart enough to recognize that it can auto import spinner. So I'm going to hit Enter. And if you're not using VS Code, you'll need to manually import spinner if your editor doesn't handle auto imports. But notice that the import for spinner was added on line 4. If an error has occurred, we should also throw it in the component so that the error boundary kicks in and displays. So we should say if there's an error, then we want to throw that error. I'm going to add a blank line here. So now the big moment is here. We're ready to display our product details. Go ahead and delete the h1 that we had stubbed in here. And instead, we can use this JSX that I provided down here. So, let's select all of this and uncomment it. You can hold down Cmd and forward slash in VS code and that will remove the comment. Then I will delete these unnecessary lines of code and hit Enter. Let's check it out. Hey, look at that. We have product details. That is one big image. And I should find if I go back to Shoes and I go to Hiker, now I see the hiker shoe. Now I see the explorer shoe. We have a product details page. And if I refresh directly, I can see that loading spinner display for just a moment. So we also know that our loading state is working appropriately. Look at our code. We just fetched data from a URL, handled loading state, handled potential errors, and displayed the product details in about 20 lines of code. That's pretty impressive. However, there is one corner case we need to cover. If I come back over here and enter an invalid ID, then right now the application throws an error and says that something went wrong. Just like the products page, we need to handle invalid URLs. So let's handle the 404 next.

Handling 404s on the Detail Page
The API currently throws an error if the request is invalid. So, let's add special handling for 404s. Over on the detail page, we can import PageNotFound. And then, if loading is complete but we still don't have a product, we should show the 404 page. So down here below where we return the loading check, we can say if there's not a product, then we should return PageNotFound. And this is pretty logical. We know loading is done, so we should expect to have a product by the time we get to line 12. So if we don't, we know we can show the 404 page. Again, this is one of my favorite state tricks is returning early in my JSX. Notice how it keeps my JSX simple and flat. And then I know that my JSX down here on 15 through 22 only loads if all my preconditions have passed. I know loading is done. I know I have a product. I know that there's not an error. Now let's check the browser. Great. Now we get a PageNotFound. If I put back in a valid URL, then things display properly as before. That custom React hook really paid off. We've handled loading errors and 404s with only a few lines of code. And React Router has made client‑side routing fast and declarative. To wrap up this module, let's implement a final React Router feature. We can create the shopping cart page and redirect to it from the detail page.

Redirecting via useNavigation
Now that we're showing product details, let's create an Add to cart button on the detail page so that we can add the shoe to our shopping cart. Let's put the button down here below the price. So, create a new paragraph tag. And then inside, put a button and set the class name equal to btn and btn‑primary. Inside we'll put Add to cart. Let's check the browser and make sure it renders. There's the button right below the price. Looking good so far. To programmatically redirect the cart page, we can use React Router's useNavigate hook. So back up here where we've already imported useParams, we can add useNavigate. And we can call it up here at the top of our component. Say const navigate is equal to useNavigate. Now we can use the navigate function to redirect when somebody clicks on Add to cart. So let's add an onclick handler, which will accept a function. And inside that function, we'll call navigate and specify the path, which is cart. That should do the trick. Let's check the browser. Now if I click on Add to cart, it takes me over to the cart. However, notice that it takes me to shoes/1/cart. So, we need to come back over here and make one tweak. We actually want to go to the root /cart. So now if I go to Shoes and I click on a shoe and I click on Add to cart, now it takes me over to /cart. So our programmatic redirect is working as expected. Now, of course, it's not actually adding a product to the cart at this point, so nothing's displaying in the cart yet. We're going to handle that in the next module as we dig more into patterns for handling forms. Our React Router setup is looking great. Let's close this module with a summary.

Summary
Now we have a multi page app with lightning fast navigation thanks to React Router. We declared routes with the Route component, we declared and read URL placeholders, we implemented client‑side links with the Link component, we handled bad URLs by showing a 404 page, and we redirected with the useNavigate hook. In the next module, we'll implement the cart, and we'll dig deeper into tricks for handling different types of state, including shared state, derived state, and properly handling immutable updates.

Managing Shared, Derived, and Immutable State
Intro
In this module, we'll dig deeper on three common types of state, shared state, derived state, and immutable state. To explore these concepts, we'll build a shopping cart for a shoe store. Along the way, we'll derive state from existing state and props, we'll explore where to place state, and we'll lift state to a common parent so that it can be shared across components. React state should be treated as immutable, so we'll explore immutability and why it's important and look at various immutable‑friendly approaches to managing state. We'll use the function form of setState to reference existing state, and we'll declare event handlers on a list. All of these activities are common state challenges on real React apps. So, let's dig in.

Creating a Shoe Size Select
To start our formwork, let's implement a shoe size selector on the detail page. We're going to use this selector to determine the shoe size that we'll add to the cart. To get started, I have the product page open because we're going to copy this select from the bottom of the product page, and we'll paste it over within our detail page. Let's paste that select up above the Add to cart button. So I'll place it right here. First, let's change the default option from saying All sizes to saying What size? Next, the size option should be limited to the shoes available sizes. So we need to replace the hardcoded options list with a list of available sizes for the shoe that we're currently viewing. Let's take a look at db.json. This shows the data structure that we're working with. The available sizes are stored under SKUs on the product. Remember that a SKU is a stock keeping unit. So a SKU is a unique identifier for a particular variant of shoe. In our case, we're only dealing with shoe sizes, but you could imagine how a SKU could also represent a specific combination of color, size, width, or any other variant of shoe. Think of it as a unique identifier for that specific combination. So we can implement our array of options using the product.skus array. If you think that you can do this yourself, I'll give you a hint. You can use the SKU as the value because we want to add the SKU to the cart, but we want to display the size to the user. So if you want to try this yourself, go ahead and pause the video now. Let's jump back over to the detail page, and we'll replace these hardcoded options down here by iterating over the products' SKUs. So let's say product.skus.map. And I will represent the SKU using the letter s, and then I'll wrap my return JSX in parentheses. What I want to do is render an option for each one of the SKUs. Anytime that we're mapping over an array, it's important to specify a key. We need a unique key for the array, and the SKU will work well for that purpose. Then we also need to specify the value for this option, which we'll set to the SKU because the SKU is what we want to store inside the cart. Finally, we need to decide what we're going to display to the user. We want to display the corresponding size for that SKU. So I will reference s.size. Then, we can remove these three hardcoded options down here below. Next, we need to declare some state to hold our selection. So up at the top of the file, let's import useState. Then, we can declare useState up here toward the top of our component. I'm going to call the state sku because that's what we'll be holding, and we'll have a corresponding setter called setSku. Let's default this to an empty string. Finally, the select that we pasted over had a value of size, but we need to change the value instead to reference SKU. So, I'll set the value to sku. And then onchange, I want to set the SKU. Now when I hit Save, the app does render again. So let's go over to the detail page. I'll go ahead and pick a shoe. And now our size selector renders. I can select a value, so it looks like we're on the right track. We can see that only size 7 or 8 displays for this particular shoe. But if I come over to the climber, then 8 or 9 displays because those are the relevant sizes for each one of those shoes. But right now, I can click Add to cart when I haven't even selected a size. So, next up, let's use some derived state to enable the Add to cart button after someone has selected a size.

Implementing Derived State
The Add to cart button should be disabled until a SKU is selected. How could you disable the cart button using existing state? Go ahead and pause the video if you want to try this yourself. Welcome back. So we can use the SKU to disable the button. If the SKU state is empty, then the add to cart button should be disabled. So that means down here where we display the Add to cart button, we can set the disabled prop equal to true if there isn't a SKU. Now we can see that the Add to cart button is disabled until I come over here and select a size. And if I go back to the What size?, then it becomes disabled again. Again, this is the benefit of derived state. We don't have to declare any new state. We can rely upon the state that we've already declared. And we don't have to worry about this getting out of sync. Before we start implementing the cart, we need to step back and establish some guidelines for where to store state. Let's do that next.

Deciding Where to Store State
We need to store our cart in state. So your first instinct might be to declare the cart state here on the details page. But the problem is we're going to need the cart state on multiple pages later in the course. Once you start creating multiple components, you have to think more deeply about where to declare your data. Declaring state in the wrong spot is a common mistake. A sign that your state is in the wrong spot is when it's hard to consume and share with relevant components. Generally, it's a good idea to keep your state as local as possible and then broaden access by lifting state to the common parent as needed. The principle of least privilege states that every module must be able to access only the information and resources that are necessary for its legitimate purpose. This means that each React component should ideally only have access to the data and functions that it needs to do its job. In summary, try to keep state as local as possible. So here's a simple strategy for starting local. When declaring new state, begin by declaring it and the component that needs it. If the child components need the state too, then pass the state down via props. If you realize that non child components need the state, then lift the state up to a common parent. Finally, if you find passing props down to all the relevant components gets annoying, then you can consider using Context or Redux for handling global state. We'll look into these options further later in the course. Here's our current App component tree. Two components need to access the cart state. The detail page needs to support adding an item to the cart, and the cart page needs to display the list of items in the cart. So, we need to declare the cart state in a spot where both these components can access it. This means that we should put the state in a common parent. Now, our app isn't very complicated right now, so the only common parent for our components is the App component. So we can declare the cart state there. Then, we can pass it down via props. In a big app, lifting state might mean moving state up one or two levels to a common parent but not necessarily all the way to the top.

Lifting State
We need to declare our cart state in a common parent component so that other pages can access it. This pattern is called lifting state. Lifting state sounds complicated. It's not. Lifting state means that we declare state in a common parent component. As we established in the previous clip, the App component is the common parent so let's open up App. At the top, let's import useState, and then we can declare some state for cart at the top of our App component. Let's default our cart to an empty array since it will hold an array of products. So we'll declare the cart state in the App component and then pass it down to the child components that need it. Next, we need to decide what should we store in the cart? Look at the db.json and ask yourself what product data do we need to store in the cart when someone adds a product to the cart? Here's my take. I think we need to store the product id, the SKU, which for us represents the size, and the quantity. Ideally, we'd only store the SKU and the quantity, but let's put the product id in the cart too since that will also be useful and it'll help simplify our API calls. Let's jump back to the App component and implement the addToCart function. I'll declare it below our state declaration and call it addToCart. Now the logic for adding a shoe to the cart is going to be surprisingly complex. So let's build this up one piece at a time. First, to add an item to the cart, we're going to require two arguments, id and sku. The cart is going to contain a list of items, so we need to update state using existing state. This means that we should use a function to setState since it assures that we can safely reference existing state. Let me briefly explain why. React setState calls are asynchronous, so you can't expect them to happen immediately. But why? Well, React batches its setState calls for performance. This improves performance by reducing the number of renders that occur. So, if state is set multiple times in a short time period, React may only render the relevant components once by batching those setState calls together. Asynchronous setState is also required to support async rendering. React can intelligently apply different priorities to setState calls to help assure smooth animations and transitions. For example, typing in a text box needs to reflect your keystroke immediately. But displaying a response from some API call could be a lower priority and thus slightly delayed. Let's consider an example. Imagine that I'm storing a counter in state. I should avoid calling setCount and referencing count inside the setter. Due to batching, the value of count may be an old value that hasn't been updated yet. Instead, use the function form when you need to reference existing state. So let's use a function to call setCart. We will declare the function, and items will represent the current state. React provides the current state automatically when we use a function to setState. Whatever we return inside this function becomes the new cart state. Think about how a shoe store works. I add a shoe with a certain size to my cart. And if I click Add to cart again for that size, then it should increment the quantity of that size in my cart. So, if the shoe size is already in the cart, then we need to increment the quantity. Now remember for us, the SKU is the unique identifier for a given size. So we need to check if the SKU is already in the cart. Let's begin by creating a variable called itemInCart. And to determine whether it's already in the cart, we can search through items using array.find. Array.find accepts a function that returns a Boolean. Another name for this is called a predicate. A predicate is a fancy word for a function that returns either true or false. Array.find will run for each element in our array. I'm going to represent each element using the letter i, which stands for item. And I will check whether the item SKU matches the SKU passed into this function. So if the SKU is already in our cart, then we need to increase the quantity by one. So, you might think that we could mutate the item's quantity directly by doing something like this, itemInCart.quantity++, but don't do this. This won't work. In React, it's important to treat state as immutable. So let's pause for a moment and explore why immutability is important and how to handle it.

Why Immutability?
You might wonder why is immutability useful? Well, it's more efficient to test if two objects are equal if they're immutable. React takes advantage of this concept to make some performance optimizations. More broadly though immutability helps encourage writing pure functions, which are easier to understand and test. Immutability is also a natural fit for undo and redo and ultimately helps us avoid bugs. To understand why a mutable state is useful for performance, imagine we have a large state object with many properties. If state is mutable, we'd have to do an expensive operation to determine if state is changed. React would have to check every single property on your state object to determine if state had changed. But if state is immutable, suddenly this expensive operation of checking every single property isn't necessary. For example, imagine I have two variables called user1 and user2. There's two ways I can determine if user1 and user2 are equal, either value equality or reference equality. With value equality, I have to compare all of user1's properties with all of user2's properties. For instance, I'd have to check if user1.name is equal to user2.name, and user1.role is equal to user2.role, and so on. This doesn't scale well for large objects because it's a lot of comparisons. If we treat state as immutable, we can safely do reference equality checks instead. Reference equality is about the answer to this question. Do both variables reference the same spot in memory? So it's a simple one‑liner regardless of how complex the object is. So React says if old and new state reference the same spot in memory, then the state hasn't changed. The comparison is fast, scalable, and simple. And if you treat state as immutable, you can implement simple reference comparisons like this in components if you experience performance issues. You can use React.memo in function components or shouldComponentUpdate or PureComponent in class components. So, immutability also makes it easier to improve performance.

Handling Immutability
You might be wondering how can you build an application that doesn't mutate state? If I can't mutate state, doesn't that mean that no data can ever change? Not at all. It just means that instead of changing your state object, you must return a new value that represents the new state. It's worth noting that some types in JavaScript are immutable already such as numbers, strings, booleans, undefined, and null. In other words, every time you change the value of one of these types, a new copy is created. Mutable JavaScript types are things like objects, arrays, and functions. In fact, that's why I didn't talk about this concept earlier. Thus far, we've only used primitive types in our state, such as strings, numbers, and booleans. Now we're about to start storing arrays and objects in state, so this whole immutability conversation is important before we move forward. To explain immutability, let's consider an example. Imagine that our app state holds my name and my role. In a traditional app, if I wanted to change state, I'd assign a new value to the property that I want to change. So here, I'm mutating state because I'm updating the existing object to have a new value for role. Now let's contrast this with an immutable approach to updating state. Now I'm not mutating state. Instead, I'm returning an entirely new object. This is important because React depends on immutable state to improve performance. Now you might be thinking I have to build a new copy of state by hand every time I want to change it? Thankfully, no. Let's look at some easy ways to create copies of objects in JavaScript. You can use Object.assign, the spread syntax, and immutable‑friendly array methods such as map. Let's look at each. Object.assign creates a new object but allows us to specify existing objects as a template. The first parameter is the target, and then it accepts as many source objects as you want. So here I'm saying create a new object. But then, we're mixing that new object together with our existing state object and setting the role property to admin. So the result of this statement is effectively a clone of our existing object but with the role property change to admin. Another option is the spread syntax. The spread syntax is three dots. Whatever you place on the right is shallow copied. Much like Object.assign, values that you specify on the right override values on the left. So this creates a new object that is a copy of state, but with the role property set to admin. You can use spread to copy an array too. We'll use object spread in the course since it requires less code than Object.assign. And a word of warning. Both Object.assign and object spread only create shallow copies. So if you have a nested object, you'll need to potentially clone the nested object too if that's a value that needs to change. Notice how the user object has a nested address. That means that this line doesn't clone the nested address. It remains referenced in the user copy. To avoid this issue, you need to clone any nested objects when their values change.This avoids accidentally mutating a nested object. There are also some ways to avoid storing nested objects in state. You can declare the nested object via a separate useState call. For example, imagine that we're storing a user's data in state. The user has a nested address. We could declare a single useState call, but you may prefer declaring a separate useState call for the user's address. Doing so makes the state update simpler because it's easier to update state when there aren't nested objects. And if you need to send the entire user object back to the server, you can merge the two objects back together before sending them. If you have nested objects stored in state, you might be tempted to reach for deep merging tools like clone‑deep or lodash.merge, but avoid blindly deep cloning. Here's why. Deep cloning is expensive. It will needlessly slow your app down. It's typically wasteful since you don't need to clone all nested objects. You only need to clone the objects that have changed. Deep cloning causes unnecessary renders since React thinks everything has changed when, in fact, perhaps only a specific child object had changed. So, be strategic. Only clone the sub‑objects that have changed. So what about arrays? Well, JavaScript has a variety of array methods. And if you scroll down the array list on MDN, you'll see many to choose from. But when working in React, there are some array methods that you should avoid. Array methods like push and pop mutate the array, so they should be avoided. If you want to use this, you must clone the array first to avoid mutating the original array. Instead, prefer immutable‑friendly array methods like map, filter, reduce, concat, and spread. These methods return a new array so they don't mutate the existing array. Remember, you can also use spread to clone arrays as well. In summary, there are many ways to handle immutability, but we'll primarily use the spread syntax and immutable‑friendly functions like map and filter. But here's some other options to consider.

Implementing Immutable-friendly Add
Okay, back to coding. As we just saw, we need to treat our state as immutable. So we need to return a new array instead of mutating the existing array. Javascript's map function is a handy way to create a new array. Map runs a function on each element in an existing array and returns a new array that's the same length. So if the item is already in the cart, then we're going to map over the items and replace them. So our goal is to return a new array with the matching item replaced. So we will return items.map. And then for each item, which I will represent using the letter i, we want to check if the item SKU matches the SKU of the item that we're trying to add to the cart. At this point. I'm going to use a ternary operator because we have an either or here. Either we found the item that we're looking for or we haven't. In this case, if the SKU matches the SKU passed into add to cart, we've found the item we're looking for. So we want to increase the quantity of that item by one. So what we want to return in this case will be the current item, which I'm going to copy using object spread. But I want to set the quantity of that item equal to its current quantity + 1. Otherwise, I want to return the item untouched. And I'll hit Save so it formats. So this covers the logic for an item already in the cart. We iterate over the array. And if we found the item we're looking for, we return a copy of that item but with the quantity increased by one. Otherwise, if it's not the one we're looking for, we just return the item untouched. So we end up with a new array. And remember whatever we return in setCart becomes the new state for the cart. Now we need to handle the logic for if it's not in the cart yet. The logic for this is simpler. We can append the new item to the array of cart items using array spread to copy the existing array. So down here, I'll say else. And our goal here is to return a new array with the new item appended. So we will return the existing array, which we can copy using the spread syntax. But then we'll add a new item to the array. Remember, we decided to store three properties for id and the skew and the quantity. We'll set the quantity to 1. Now notice, I am not specifying the right‑hand side for this property or this property. I'm using the object shorthand syntax. I could say set the id equal to id, and I could say set the sku equal to sku. But with modern JavaScript, we can omit the right‑hand side if the left‑hand side identifier matches. So I'll just leave those out. Save a little bit of code. So let's review. We're updating state using existing state, so we're using the function form of set state. Items represents the current cart state, and it's provided by React. If the SKU is in the cart, then we increment the quantity. Otherwise, we add it to the end of the array of items using object spread. Now we can pass this addToCart function down on props to any components that want to support adding a product to the cart. We know we want to add a product to the cart on the details page. So, let's pass the addToCart function down via props. Now we can call this function on the details page. So let's go over to the Detail component. And in our onclick function, now we need to do two things. So I'm going to wrap the body in a curly brace so that we can have multiple lines inside the body. And before we navigate, we want to call props.addToCart and then pass it the id and the sku. Notice that props isn't defined, so we need to jump up to the top of the file and declare props as an argument. We're about ready to test out our add to cart functionality. But to see it in action, we need the cart to display the items that are in the cart. So, let's do that next.

Displaying Cart Items
Our cart page is empty. To save time, I've provided a partially completed cart page in the exercise files for this module. Copy it from the exercise files in this path. I'll paste it in. This is mostly JSX for displaying the cart. Let's talk this through. The Cart component expects to receive the cart and a function called updateQuantity via props. Props are being destructed inline here. If prop destructuring looks weird to you, this is equivalent to accepting props and then down here using destructuring on a separate line. But I'm just eliminating a line of code by taking this destructure and instead doing it inline in the argument. Line 6 creates an array of URLs for each product in the cart, and then it calls a handy custom hook called useFetchAll. useFetchAll is very similar to the useFetch hook. The difference is this hook supports multiple simultaneous requests. So copy useFetchAll from the exercise files. It's in this path. Note that it's in the services folder. I'll go ahead and paste it in now. useFetchAll builds an array of requests. Then, it passes them to promise.all. Promise.all is a built‑in JavaScript function for running multiple promises at the same time. So this will fetch multiple URLs at the same time. This is useful for us because we want to fetch multiple product details at the same time since we're displaying multiple products in the cart. The dependency array is deliberately empty to assure that this effect runs only once after the first render. So that's the useFetchAll hook. It's quite similar to the useFetch hook, except it makes multiple calls instead of just one. Let's turn our attention back to the cart page. After data has been fetched for all the products in the cart, it displays the cart. I'll collapse the renderItem function for a moment. The cart page has the same checks for loading an error as the other pages. In the body of the JSX, it iterates over each item in the cart and calls renderItem for each. Let's look at renderItem. renderItem restructures the value stored in the cart, and then it finds the product details for that item, and it destructures the other product details that we want to display below. Since we store the SKU in the cart, it also finds the associated size for the SKU so that we can display the selected size. The product details are displayed, and there's a drop‑down for changing the quantity, which uses the updateQuantity prop. So the cart page expects to receive two props, the cart and a function to update the quantity of an item in the cart. Let's implement that next.

Implementing Immutable-friendly Update
Let's jump over to the App component. We need to pass the cart state down to the Cart component. So let's add a cart prop and pass cart. Save your changes. And now that we're doing that, we should be able to add a product to the cart. Let's come over here, select a size, and click Add to cart. Hey, hey, look at that. Our cart is displaying. Looking good. But the cart also supports changing the quantity of an item. To do that, it calls a prop called updateQuantity, which we can see over here on line 26. We can see that it calls updateQuantity with the SKU and the selected quantity, which is parsed as an integer. So let's go implement updateQuantity and pass it down. We can place it right below the addToCart function, and we'll call it updateQuantity, and it will accept both a sku and a quantity. If you'd like to try implementing this function yourself first, pause the video now. Welcome back. We need to treat React state as immutable. So, we need to update the cart in an immutable‑friendly way. Since we're updating state using existing state, let's use a function to update state. And items will represent the current items in state. The items argument will be injected by React. Our goal is to return a new array of items but with the quantity changed for the SKU that was passed in. So again, array.map is a pretty logical choice. So let's return items.map, and we'll represent each item using the letter i. We need to set the quantity for a specific SKU. So we need to look for it. So if the items SKU is equal to the SKU that we're looking for, then we found the item that we'd like to update. So, we can copy that existing item using object spread, but then set the quantity based on the quantity passed in. And again, I'm using object shorthand here. I don't need to say quantity:quantity. I can just leave the right‑hand side out. If it's not the record we're looking for, then we will return it untouched. Now, let's pass this function down as a prop to our cart. Let's give it a shot. We'll come over here to Shoes and find a shoe. I'll select a size, hit Add to cart, and it displays. Can I change the quantity? Hey, looks like I can. Very nice. I can also navigate away and come back to the cart, and my selected quantity persists. So it looks like it's working well. Also, I can click Inspect and open the React dev tools, which are under the Components tab. And if I select the cart, we can see that the cart is receiving the cart on props. And we can also see down here in our hook our state that we're receiving from fetchAll. And if we scroll back up to app where the cart is declared, we can see the cart contains item id 2 with a quantity of 4 for sku 28. If I come up here and change the quantity, then I immediately see that reflected down here in state. However, there's a bug. If I come over here and select Remove, then Remove stays selected. But what it should do is remove the item from the cart. So, let's fix that next.

Implementing Immutable-friendly Delete
We need to remove an item from the cart if the quantity passed in is 0. So we need to remove a record from the array in an immutable‑friendly way. Array.filter is a good choice. Array.filter returns a new array. It accepts a function that determines what records to keep in that new array. If the function returns true for the record, then the record is retained. We know that we want to keep all records that don't have the specified SKU. Here's a tip. The quantity is sent in as 0 when someone is removing an item from the cart. So here's the next step. We can use filter to remove an item from the cart when update quantity is past a quantity of 0. If you want to try this yourself first, pause the video now. Welcome back. So back up here in our setCart, we need to add another check because if the quantity is 0, then we need to do something else. We'll use items.filter. So we will return the results of items.filter. Filter accepts a predicate, which is a fancy word for a function that returns either true or false. And we want to filter out any items that have the specified SKU. So with filter, we tell it what we want to keep. We want to keep all items that don't have the SKU passed in if the quantity is 0. You could also use findIndex along with array.slice here if you prefer. But I like how this does the job with a single statement. Let's try this out. I'll add a shoe to my cart, and then I can still change the quantities as before. But if I select Remove, now it actually removes the item from the cart. Slick. Hey, let's go sell some shoes. There's one final tweak we could make over here if you prefer. When I see a basic if/else statement, I prefer to use a ternary. So we can simplify this logic to say return if quantity equals 0, this first item, the results of calling items.filter. Otherwise, do items.map. I need to remove the semicolon off the end here. So we can simplify it to this. So, if the quantity is 0, filter it. Otherwise, map over the array and replace the quantity for the SKU that was passed in. But feel free to leave the if statement if you preferred that. Our cart header is hardcoded right now. It would be nice if it told us how many items were in the cart. So, let's implement some derived state next.

Deriving State for Cart Header
To practice deriving state, let's add a header on the cart. Here's the goal. The header should display the total number of items in the cart or a message that the cart is empty. Pause now if you want to try this yourself. Okay, let's try this out. Remember, each item in the cart has a quantity. So to get the total number of items, we need to get the sum of the quantity of all the items in the cart. We can use array.reduce to store the result in a variable that we call numItemsInCart. Array.reduce is a powerful function for aggregating data. With reduce, we can run a function on each item in the array to calculate the total quantity. Let's declare this variable down here after we've confirmed that there are no errors and that loading is complete. So I'll declare the const, and we'll call it numItemsInCart. To calculate this, we will look at the cart, and we'll call reduce on it. Reduce accepts a function that takes two arguments. The previous value is the first argument, which I will call total. And the second argument is the current value, which I will call the item. What we want to do is return the total plus the item's quantity. The final argument is the initial value, which we'll set to 0. Scroll this up some. Let's talk this through. Reduce accepts a function that is passed an accumulator and the item, the item represents an item in the array. The final argument is the accumulator's initial value. So this sums up the total quantity of items that are in the cart. To learn more about reduce, I suggest reading the MDN docs. Now let's use this quantity to change the header. Come down here and instead of hardcoding the word cart, we can check the number of items that are in the cart. And we can say if there are no items, then what we'd like to display is Your cart is empty. Otherwise, if there are some items, then we can display the number of items in the cart. Let's use a JavaScript template string for this. I'll put this down on a new line. And I will start out by referencing the num items in the cart. So I will say num items in the cart item. And if there are multiple items, then I want to display an s. So I will say num items in the cart greater than 1, I would like to put an s on the end. Otherwise, I don't need to put that s on the end. And then finally, I will say in My Cart and close out that curly brace. So this should say Your cart is empty if the cart is empty, and we see that displaying over on the left. Now let's see what happens if I add some items to my cart. We'll go ahead and do the hiker this time and get a size 7. Hit Add to cart, and it says none. Hmm. And I see my issue. I made a typo over here. I said quantity, but it should say quantity, item.quantity. I'll hit Save, and let's try it again. Come back over. Add a hiker. There we go, one item in my cart. And if I change the quantity here, then I see the header change as well. Great. This is the power of deriving state. You might wonder though, what if I'm making an expensive calculation? And isn't it wasteful to calculate this on each render? Well, typically, performance isn't a problem. If performance is a problem, you can wrap your code and React's useMemo hook to memoize the calculation. That would look like this. With useMemo, the value is only recalculated if the dependencies change. I'm not going to make this change since it's unnecessary for a simple calculation like this. So, are you getting tired of losing the items in your cart when the app reloads? Well, next, let's use local storage so that our cart is saved between reloads.

Lazy Initializing State and localStorage
In this clip, I want to share two useful tricks, lazy initializing state and persisting state to local storage. Adding new items to the cart is getting annoying. So it would be nice if the app remembered our cart, even if the app reloads. The question is, where can we store the cart so that it persists between page loads? Let's explore the options. There are many ways to store data in the browser, including cookies, local storage, session storage, IndexedDB, and cache storage. Broadly, these technologies are called web storage. Cookies, local storage, and session storage are simple solutions. IndexedDb is more powerful but also more intimidating. And cache storage is useful for offline support. Like any technology, web storage has tradeoffs. Web storage is attractive because the storage is local. This means that it's generally simple to implement, and it offers extremely fast reads and writes. Plus, it works offline. However, the amount that you can store is limited, and it varies by technology and sometimes even the user's browser. The data stored inside is a security risk, especially on shared machines like those in public libraries. So web storage is generally not recommended for sensitive data. Some tech like local storage and session storage are synchronous APIs. So you need to avoid writing or reading large datasets frequently since the browser temporarily locks up while doing so. And of course, since the data is stored in the browser, it's tied to a single browser. So if the user switches browsers or machines, they'll lose their data if it's not also stored in the cloud. Let's persist the cart to local storage. With local storage, we call setItem to store data, getItem to get data, and removeItem to remove data. See the MDN docs for more details. I'm back in App.js. Let's persist the cart to local storage. To do this, we can use useEffect. So first, import useEffect. Then, down below our declaration for useState, we can declare our useEffect. Remember, useEffect accepts a function that it will run. And what we'd like to do is call localstorage.setItem. We need to tell it the key for the item. Let's give it a key of cart. And then, the second argument is what we'd like to store inside of local storage. I would like to store a stringified version of our cart. So we can call JSON.stringify and pass it the cart. There's one final argument, which is our dependency array. Since we're depending on the cart, then we should put that over here in the dependency array. So this says any time the cart changes, store it in local storage as a JSON string. Use cart as the key. We also need to initialize our cart up here. Instead of initializing it to an empty array, we want to initialize it to the data that exists in local storage if any is there. Now you might think that we could do something like this. We could call JSON.parse on LocalStorage.getItem cart. Now, this might work, but there's two problems with it. First, here's a little known fact. The default value that you specify for state is only applied on the first render. However, it's evaluated on every render. So if you're doing something expensive to initialize state, then it will be run on every render even though it's only used for the default. Now thankfully, there's a way around this. Instead, you can pass a function to useState. Functions are lazy evaluated. So the function will only be run the first time the component renders. So what we can do is wrap our call here in an arrow function. And by doing that, now this will only be evaluated once. So this is more efficient. Now local storage is only read once to set the initial value instead of being needlessly read on every render. I mentioned that there were two problems. The second problem is what if the data in local storage is malformed and can't be parsed into JSON? What if we accidentally write bad data to local storage? The app would break because JSON.parse would fail. So, let's wrap our call in a try catch. I'll add a curly brace up here to wrap our function and then put in a try and close my try. Put in my catch. And if there's an error, I will sayconsole.error. The cart could not be parsed into JSON. And then, if that happens, we can go ahead and return an empty array instead so that the application still loads. And we need to add one extra curly brace and hit Save. There's one other change we need to make, and we can see the problem over on the left. What if there's no data in local storage? We need to default to an empty array. So I'll show you another new JavaScript feature. We can use the nullish coalescing operator to say if the thing on the left is null, then go ahead and use this value on the right instead. And I need to put a return over here on the left. Now, if we accidentally write bad data to local storage, the cart will default to empty. Let's try it out. I'm going to open the dev tools and look at local storage, which is listed under Application. And then over here on the left, you may need to branch out local storage, select localhost:3000. And we can see that the cart right now is an empty array. But if I navigate over here, select a shoe, pick a size, and hit Add to cart, now we can see that that cart contains ID 2, SKU 28, quantity of 1. And as I change values, that useEffect immediately runs. This useEffect right here is running and writing our state any time that I change my value. If I hit Remove, then we see that the cart is now an empty array. And also, that means that if I add an item to the cart, I should be able to refresh the browser and see it stay. So now I'm hitting Refresh, completely reloading, and it is still keeping the item in the cart because it's initializing our state using this data. So this code is running successfully. So just keep in mind if your app is acting weird at any point through the rest of the course, be sure to check local storage. To clear it, you can click the clear icon right here. For more advanced use cases, you may want to use a custom hook like this local storage hook. Great. Our cart looks solid. For the rest of the module, let's shift our focus to checkout so I can show some useful patterns for form validation.

Summary
In this module, we built a shopping cart and practiced multiple state management approaches. Here's some key points. Avoid declaring state when existing values suffice. Derive state on the fly and render when possible using existing state. We derived state for the cart header. Lift state to a common parent component when you need to share it. We lifted the cart state to the App component so that we could share it across the app. Treat React's state as immutable. So we implemented immutable friendly updates using object spread, map, and filter. React setState is asynchronous and batched to improve performance. So, we use the function form of setState to reliably reference existing state. And we combined useEffect with local storage to persist the cart even if the tab is reloaded or closed. But remember, there are many other web storage options to consider. Next up, let's implement a checkout process and focus on useful patterns for form validation.

Managing Form State and Validation
Intro
Forms sound simple, but properly implementing forms in validation can be surprisingly complex. So in this module, we'll implement a simple checkout process that includes client‑side validation. Along the way, we'll validate onBlur and onSubmit. We'll track touched fields. I'll show how to declare a very limited amount of state to handle the form. We'll strategically derive most of our values. And we'll implement a state enumeration to enforce clear, discrete states.

Creating Checkout
Let's create a checkout page and implement client‑side navigation. To save time, I provided an initial checkout form in the exercise files for this module. Copy the initial checkout component from this path. Right‑click on src and let's create a new file. We'll call it Checkout.jsx. And paste in the content. Let's scroll to the top and see what we're working with. I've kept the checkout form short. We only need a couple fields for me to convey many useful form state management patterns. The form will have city and country fields. The fields will be stored within the address object and state. I've also subbed in handleChange, handleBlur, and handleSubmit, which we'll fill in throughout the module. Scrolling down, let's look at the form. The onSubmit is configured to call handleSubmit. Both the fields are controlled components. They are bound to the relevant value in state. And they're also configured to call handleBlur and handleChange when onBlur and onChange events occur. Finally, down at the bottom, we have our Submit button. To render this new page, let's open up the App component, and we can import checkout at the top. Then, we can scroll down and add a route for checkout. Let's set the path to checkout. And the element that we want to render is Checkout. Checkout expects to be passed the cart on props, so let's pass that down as well. We'll navigate to the checkout page from the cart page. So let's open up the cart page and enhance it so that it has a button to enable us to check out. So open up Cart.jsx. We're going to use React Router to redirect to the checkout page. So let's import the useNavigate hook from React Router. Be sure to say react‑router‑dom. Now that we've imported useNavigate, we can put it to use at the top of our component. We'll create a const called navigate and set it to useNavigate. So now we have a reference to navigate that we can use down at the bottom of our component. Let's put in our Submit button. We'll use a button and we'll give it a class name equal to btn and btn‑primary. Then, we can set the onClick for this button to call navigate. So we'll put that inside an arrow function to delay its invocation. And for the path, we will redirect to checkout. For the label on our button, we can label it Checkout. This will work, but there's one other tweak we should make. We only want to render the Checkout button if there's at least one item in the cart. So let's use a little derived state. If the cart length is greater than 0, then we want to render this button. So we'll wrap it in curly braces. There we go. So now, when we click on the Checkout button, React Router will redirect us to the checkout page. Now that we've added this button, we should be ready to try all this out. I'm already running the app. So I'm going to come over here and add a shoe to my cart. When I do, I actually have quite a few shoes in my cart right now, and I have this Checkout button down at the bottom. When I click it, the checkout page displays successfully. However, if I try typing in the fields, it doesn't work because they're controlled components, but we're not handling those changes yet. So in the next clip, let's fix that.

Centralizing Change Handlers and Persisting Events
As I just showed, if we try to type in the fields, they don't respond to input. That's because they're controlled components. Each field has a specified value, but we haven't implemented the change handler yet. So, let's go back to the checkout form and do that. The initial state is a single address object. We could also use separate useState calls for each field, but I prefer to use a single useState call when the data is related. This also makes it a little easier to send the data to the server. However, as you're about to see, the tradeoff is setting state is a bit more complex with an object than with primitives like strings and numbers. Let's implement our handleChange function here, which will be called by both our inputs. To update state on change, we need to reference existing state. So as we've seen, we should use the function form of setState. So when we call setAddress, we're going to want to reference the current address. So I will put curAddress here to represent that. We want to set the address to whatever the current address is, but with the field that just changed updated. If we scroll down, I've deliberately set the ID on each one of the fields to correspond to their property in state. So the City field has an ID of city, and the Country field has an ID of country. This convention means that we can declare a single change handler for the entire form. Let me show you what this looks like. Anything that we return inside this function will become the new state. So what we want to return is a copy of whatever the current address is. However, we want to update a specific field, and that field will be passed in as the ID on that event target. So this is using JavaScript's computed property syntax to reference a property using a variable. And the value we can access as the event's target.value. So this code says set the address to a copy of the current address, use the ID to compute the property that we want to set, and then set it to the value passed in on the event. Let's try this out. If we try it out, we get an error, Cannot read property id of null. This one might surprise you, but that's because React garbage collects the event passed in before the callback function that we've declared fires. So, we need to tell React to persist the event. So come back over into handleChange, and we can call e.persist. And this is telling React to persist the event so that we can access it inside the function. Otherwise, React would garbage collect it potentially before that function is called. Note that if you're running React 17 or newer, you won't get this error. React stopped pooling events in React 17, so calling event.persist isn't necessary in React 17 or newer. Now that we've told React to persist the event, we can type into the field and it works as expected. Same story with our Country drop‑down. Next, let's begin implementing form validation.

Form Validation Decisions
When implementing a form, there's a surprising number of decisions to make. First, where should we display the errors? We could display the errors next to each field, in a summary at the top, or in both spots. Second, when should we display errors? On submit is the obvious choice, but we can also display errors on blur or even on change. Third, should we disable the Submit button if the form is invalid? Fourth, when should we revalidate the form to update the list of errors? On submit is an obvious choice, but we should also consider revalidating on change and on blur. So let's talk about our goals for this form. For our form, we'll display our errors by each field and at the top. We'll display errors immediately. So we'll display errors on submit, on blur, and on change. We'll disable the submit while the form is submitting, but allow clicking Submit even if the form is invalid. And we'll revalidate the form immediately any time a field changes or is blurred. So again, to summarize our form goals, we'll display an error summary at the top on submit. We'll validate on blur. We'll display an error message next to the field at that time. The Submit button should be disabled when the save is in progress, and we will revalidate on change. Now that we have a goal, the next question is what state do we need to declare? We only want to show errors next to fields that have been touched, in other words focused. So, we need to track touched fields. We only want to show the form validation summary if the form has been submitted. So, we need to track that. We want to disable the Submit button while the form submission is in progress. So we need to track if the form is currently submitting. We need to know if the form is currently valid to determine if the form should be submitted to the server. We need to keep a list of all the current errors so we can display them at the top of the form and next to each field. Finally, we may want to know if the form is dirty so that we can alert the user if they try to navigate away from a partially completed form. Generally, these pieces of data are sufficient. But the great news is we don't need to store and manage all these values as separate pieces of state. So let's walk through the state that we'll actually declare. We're going to declare state for touched to keep track of touched fields, and we'll track both submitted and isSubmitting via a single status variable. Since these are discrete states, it makes sense for us to group them together into a single status. And the rest of this data we can just derive. We'll calculate these values on the fly during each render. This will assure that these values are consistent and help streamline our form state. I just proposed tracking status via a single variable. This is a powerful pattern. Let me explain it next.

Intro to State Enums
Note that I'm proposing a single piece of state to track whether the form has been submitted or is currently submitting. Some call this the state enum pattern. Let me clarify what this looks like and why it's useful. When implementing a form, it's common to have multiple Boolean statuses that you need to track. One naive option is to track the form status using a number of separate status variables. For example, we might have state for submitting, submitted, and completed. The problem is our form can only be in one of those three states at a given time. For instance, it's illogical for submitting and completed to both be true at the same time. So what's the solution? We should avoid declaring separate related Boolean. Instead, we can store the form status in a single piece of state using an enumeration or enum for short. JavaScript doesn't have built‑in enumerations, but you can implement an enum using an object. An enumeration is a fancy word for a list of options. With this design, the app can only be in one active state at a time. We declare a single status variable in state, and we store the list of potential statuses in an object. This simplifies our state management, and it helps protect against bugs. As you'll see, it also makes our form easier to understand and code. We only have to think about a single status instead of juggling multiple related state variables.

Implementing a State Enum on Checkout
First, let's track the form's status. We need to know if the form has been submitted so that we know to show the error summary at the top. And we need to know if it's in the process of being submitted so we can disable the Submit button while the submission is processing. And if the form is submitted successfully, we want to show a confirmation. So you might think that we need three pieces of state, isSubmitting, submitted, and completed. But those are discrete states. The form can only be in one of those states at a given time. So instead, we should handle this via a single status variable. Let's declare this status up here at the top of the file. I'll declare a const of status. And since I'm basically creating an enumeration, I'm going to use all caps for the value and the keys. This is a fairly common convention but not required. We're going to have four states, idle, which will apply when the form is first loaded, submitted, which applies when the form has been submitted, submitting, which applies while the form is in the process of submitting, and completed, which applies when the form has been completed successfully. Next, let's declare some state to hold the status. So I'll say const status setStatus is equal to call to useState, and we will default this to a status of idle. When the form is submitted, we can't update this status and handle submit. So let's jump down to handleSubmit and call setStatus equal to status.submitting. When the form is submitted, we should also prevent it from posting back to the server because we want to handle all of our validation on the client. So, let's add another line up above this call to setStatus that we can call event.preventDefault, and that will keep the form from posting back. We can also use our status state to disable the Submit button while the submit is in progress. So let's scroll down to the bottom and set disabled on the Submit button. We want to disable it if the status is equal to STATUS.SUBMITTING. This way, you can't click the Submit button again while a submit is in progress. Let's try the form. Now if I click the button, it becomes disabled. We just implemented the state enumeration pattern in order to track the form's status. In the next clip, let's finish up the form by saving the shipping data and emptying the cart upon completion.

Saving the Form Submission and Emptying Cart
Let's finish implementing the form submit. If you look inside the services folder, you'll find that I provided a shipping service. These functions are simple wrappers around fetch, and they call our mock API to save shipping data and get shipping data. We're going to use the saveShippingAddress function to save this information to our mock API. So let's go back to checkout and scroll to the top, and we can import the saveShippingAddress call. Import it from ./services/shippingService. Our call to this service could potentially fail, so we should declare some state that can hold that potential error. Let's call that state saveError, and we'll call the setter setSaveError. We can default this to null. Now we can call saveShippingAddress down in our handleSubmit. So let's scroll down to our handleSubmit. And after we've set the status, let's use a try to await calling saveShippingAddress and pass it the address. If an error occurs, then we can catch that error, and I'll represent the error as e. And we can set the save error to that value. And much like we handled errors elsewhere in the application, if we do have an error, then we can throw it, and the error boundary will catch it. So let's scroll down. And here above our JSX, we can add a check and say if saveError is set, then let's throw that saveError. There are still two missing pieces. When we submit successfully, it should empty the cart and show a message. To empty the cart, we need to set the cart state that's stored in the App component. Now we could just pass the cart setter down and that would work fine, but I prefer to pass down well‑named functions to children to help encapsulate state management. We know that our App component manages the cart state. Let's open our App component, and we'll pass another prop down to the cart, which we will call empty cart because the checkout process needs to be able to empty the cart. Now we need to implement this function because it doesn't exist yet, so let's scroll up and do that. This will be a very simple function. It will call setCart and set it to an empty array. Now this might seem silly. But again, the nice thing about creating this function is since the app component is responsible for managing the cart state, it can also decide how to expose that cart state. So now our child components can't change the state in any way possible. They can only call the props that they're provided. And the principle of least privilege says that our components should only be provided what they need to get their job done. Our checkout page only needs to be able to empty the cart. It doesn't need to be able to set that state in the cart in any other way. So this one function is sufficient. Now we can put this to use on the checkout page. Right now, checkout assumes that it's getting cart on props, but we're going to have a second prop that we can destructure that we're now passing down called emptyCart. Now if we scroll back down, after we've saved the shipping address, we can call emptyCart. We should also update the form status after the save is completed. So we can call setStatus and set the status equal to COMPLETED. Now we can use the status to display a confirmation message when the form has been submitted successfully. And when we display this message, we can hide the form. An easy way to do this is to return early. So down here below our check for error, we can check the status and say if the status is completed, put in our curly brace here, then we can return some different JSX instead of our form because we don't need to render our form if the form is already completed. Instead, we can return a message. I'll put in an h1 that says Thanks for shopping. Let's try it out. Come over here and click on Save Shipping Info. It says Thanks for shopping. If I go look at the cart, my cart is now empty. Great. The state enum that we just set up will keep our form state simple and reliable. Next, let's consider when the state enum pattern is useful and how it compares to more complex options like a finite state machine.

State Enums vs. Finite State Machines
We just implemented a state enum. Let's talk about when this pattern is useful and how it compares to other powerful patterns like finite state machines. We just used the state enum pattern to track our form status, but this pattern is useful for more than just forms. State enums are useful anywhere that your logic has discrete states. If you have separate booleans but only one can be true at a time, then consider declaring a single status variable instead. I've found that this simple pattern scales well. But for more complex state, you may decide to go a step farther and consider using a finite state machine. Finite state machines sound intimidating and complicated. But put simply, a finite state machine means that only one state can be active at the same time. With a finite state machine, your app transitions from one state to the other. So the state enum that we just implemented is basically a simple alternative to a real finite state machine. If you want to implement a true finite state machine, then you can consider using a popular library like XState. XState is a popular open source library for implementing finite state machines in React. XState provides two key benefits over the simple state enum pattern that we just implemented. First, XState allows you to programmatically enforce transitions between states. So this means that you can declare how and when your app moves between different states. This protects from invalid transitions. For example, it would be illogical for our form status to move from idle to completed. It should move from idle to submitting and then from submitting to either submitted or completed. With XState, you could declare transitions to programmatically enforce transitions between these states. The second benefit of XState is it provides state charts. State charts display your logic in a visual interactive chart. This can be useful when your state transitions are complex. XState is a large powerful library, so it's outside the scope of this course. I recommend checking it out. But to clarify, as I just showed, you don't need a library to enforce finite state. In my experience, for many apps, the state enum pattern that we just implemented is all you need. Okay, back to coding. Next, let's implement form validation.

Implementing "On-the-fly" Form Validation
To implement form validation, we need to declare some state. The common mistake is declaring too much state. Most of the state that we need can actually be derived on the fly. For example, we're not going to store errors in state. Instead, we can calculate errors on each render. Doing so will simplify our logic and avoid out‑of‑sync bugs. Let's declare our getErrors function down here below handleSubmit. We'll call it getErrors, and it will accept an address because that's what we're going to be validating. Result will store the validation errors in an object. You might expect to store errors as an array. But as you'll see in a moment, storing errors in an object will make accessing the errors easier. And then, we can validate each one of our fields. First, let's check on the city. And if the city isn't populated, then we can set result.city equal to City is required. We can do pretty much the same thing for country and say if there's not a country, then set result.country equal to Country is required. Finally, we can return the result. So, if there are no errors, this will return an empty object. We can store the result of running this function up at the top of the component. So let's come up here below our state declarations and set a new const called errors, which we will set to getErrors, and we'll pass in the address. So this is our first piece of derived state. I'm going to put a comment above our derived state, and we'll group our derived state here. I like to follow this pattern of having state up here and then derived state down below. We know that the form is valid if the errors object has no properties. So let's add another piece of derived state at the top called isValid. And we'll derive this from the piece of derived state up above. We know that the form is valid if the errors object has no properties. A good way to check for whether an object has no properties is using Object.keys, and we'll pass it the errors calculated above and then check if the length is equal to 0. So this effectively says if it's an empty object, then we know that the form is currently valid. We can now enhance the form submit using this derived state. We know that it should only submit the form if it's valid. And otherwise, it should update the form status to submitted. So let's go down to our handleSubmit, and we can wrap the call to try catch in a check for isValid because we only want to do that logic if the form is valid. So I will say if it's valid, do the try catch. Then I'll close my curly brace down below. And now, we can also display an error summary when the form is submitted. We can display the error summary up at the top of the form. Let's place the error summary below the header. So to determine if the error summary should display, we know that we need to check whether the form is valid. And we only want to display the error summary if the form is not valid. So we will say if the form is not valid and we only want to show errors if the form has been submitted, so we want to say if the form is not valid and the form status is STATUS.SUBMITTED, then we're ready to show the error summary. To display our errors, let's put them within a div with a role equal to alert. Inside the div, we could put in a paragraph tag and say Please fix the following errors. Then below the paragraph, we can loop over any errors that we found. So let's use an unordered list, and we can loop over the errors. Now, remember, the errors are deliberately an object, and I'll show why we made them an object here in a moment. But to loop over an object, we can use Object.keys. So Object.keys will return an array of keys for that object. So we can map over the array that this returns. And we will have a key for each element as we iterate over that array. So inside of here, we can return an li for each error that is found. Any time that we map, we need to specify a key. We can use the key that we're iterating over as the key because it will be unique. Then to display the error, we can call errors key. So this says if the form is invalid and it has been submitted, then display the error summary above the form. It iterates over each one of the keys in the errors object and displays the error. We're almost ready to try displaying our error summary. But notice that on line 70, we're checking for a status of submitted. So we need to be sure to set that up above. When the form is submitted, we're setting the status to submitting and to completed. But if the form is invalid, then here our else should be set the status equal to status of submitted. And now we should be ready to try this out. My cart's empty, so let's add an item to the cart. Go to checkout and try to submit the form empty. Aha, there we go. Now our error summary is displaying. But it would also be nice to display errors in line as the user interacts with the form. So, let's do that next.

Tracking Touch for Instant Validation
Next, let's display inline validation errors next to the fields. But we only want to display those validation errors next to fields that have been touched. So we need to track which fields have been touched. This means we need a new piece of state. So come back up here, and we'll say const touched setTouched is equal to useState, and we'll store this as an object. Each property on this object will represent the ID of a field that's been touched. We can set this down in handleBlur. Inside of handleBlur, any time a field is blurred, we can call setTouched. And again, since we're going to reference existing state, I'm going to use the function form, and I'll just call this cur to represent current. And we'll return a copy of the existing touched object, but then also use the computed property syntax to add a new property for the field that was just touched. And I need to change the e here to event because that's how we alias event. Then I need to fix my curly braces and have one extra curly race. There we go. Now we can display the error by each field, but we only want to show the error by the field if it's been touched or if the form has been submitted. So let's come down here by our first form field, and we'll add some code. We can display the error inside the div that wraps the input. So let's create a paragraph tag inside this div, and we'll give that paragraph a role of alert since it will be displaying an error message. Inside of here, we know that we only want to show the error if the field has been touched or the form has been submitted. So let's wrap our check in parentheses, and we're going to check whether touched.city is set or if the form has been submitted by checking status equal to STATUS.SUBMITTED. If either of those are true, then we want to render any errors that exist for the City field. I'm going to copy these three lines, and we want to do the same thing down on country. Again, let's place this inside the div, and we need to change city to country, and we need to change city to country on the end as well. So this says display the inline error message if the field has been touched or the form has been submitted. That should do the trick. Let's try it out. If I come over here and blur, then it displays. If I blur on the other, it displays. If I come up here and type a single letter, then the message goes away. If I empty the field back out, then the message comes back. So every moment that I change, it checks whether the error exists. If I try submitting a partially completed form, I get the error in two different places. And if I fix that error, it is hidden from both places. Many different forms of state here are being calculated, and much of this is derived on each render. If I fill out the form successfully and hit Submit, it still works fine. Note how deriving state on the fly helped us reduce the amount of state that we needed to store and also helped assure that all of our error state remains valid as we interact with the form because our form validation recalculates on each render. (Silence) Let's close with a quick summary of what we learned.

Summary
In this module, we implemented client‑side validation for both onBlur and onSubmit. We tracked touched fields, and we did all that with a surprisingly small amount of state by deriving most of our validation related values on each render. We implemented the state enum pattern. We tracked the form status via a single variable. This reduced the amount of state that we're managing, and it programmatically assured that invalid states can't occur. Consider declaring a state enum any time that you have multiple discrete states and only one can occur at a given time. I briefly introduced XState for implementing more complex state using finite state machines. We implemented our validation to run on every render. This simplified our logic and assured the errors object will always reflect the current form status. And we honored the principle of least privilege by passing down the emptyCart function from the app instead of the raw setCart function. This protected the cart state by only giving the child component the specific access that it needed. And big news, we're done building out our basic app. In the next module, we're going to check out a totally different way of handling state in React using refs.

Managing State via Refs
Intro
Refs are a critical React feature, but they're often misunderstood and misused. So in this module, you'll learn what a ref is and when to consider using a ref. We'll explore the difference between controlled and uncontrolled components. Then, we'll implement three different common use cases with refs. We'll implement a form with uncontrolled inputs, we'll track if a component is mounted, and we'll use a ref to store a previous value to optimize our custom hook. Let's get started by exploring what is a ref.

When to Consider a Ref
Refs serve multiple purposes. Primarily, they're useful for storing a reference to an HTML element. That's why they're called refs. But you can also use refs to store a value that persists between renders. Unlike state, you can mutate the ref's value. And also unlike state, React doesn't re render when a ref changes. So refs are useful for storing values that aren't rendered. Here's a simple ref example using the useRef hook. The useRef hook and the ref is applied to the input using the ref prop. The ref prop is unique to React. Once applied, you can access the underlying DOM element using .current. The ref provides a direct reference to the underlying DOM element under a .current property. So this line focuses the input. But that's just one example. There are many ways to use refs. As I just showed, if you need a reference to a DOM element, that's the primary use case. But also, if you have state that isn't rendered or doesn't change, refs are a good choice because React doesn't render when a ref changes. Refs are also useful as instance variables and function components. With refs, you can keep data between renders, store a previous value, track if the component is mounted, hold an HTTP request cancel token, reference a third‑party library instance, debounce a call or declare a local cache, store a flag that something happened, or store a value that's used in useEffect. We'll implement a few of these use cases in this module.

Implementing Uncontrolled Inputs
So far, all our form inputs have been controlled. If you prefer, you can implement uncontrolled inputs instead. To try out uncontrolled inputs, let's convert the select on the detail page to be uncontrolled using a ref. Instead of changing the detail page, let's create a copy of it and then paste it in the same directory. And then, I'm going to rename the copy to DetailRefs.jsx. This way, you can easily compare the two approaches when we're done. We're going to convert the size select on this page to be an uncontrolled input. To begin, we can import the useRef hook at the top. Next, we can create a ref instance by calling useRef, and we can do that at the top of our component. We need to decide what to name our ref. Let's call it skuRef because it's going to be a reference to the size drop‑down, which ultimately stores the size's associated SKU. So I will call useRef. Traditionally, when you declare a ref, the name ends in ref so that it's obvious that it stores a reference, but you can name this whatever you want. Next, let's set a reference on the size select down below. To do that, we add a ref property and then set it to our reference, which is called skuRef. Now the skuRef variable holds a reference to this select HTML input. This way, we can read the select element's HTML attributes. With uncontrolled inputs, we don't specify a value. So that means that we can remove this value prop and the associated onchange handler. This also means that we can delete the unused SKU state up here as well. Remember, with uncontrolled inputs, the HTML input holds the value rather than React controlling it. If you've ever done plain JavaScript or jQuery development, it's a bit like that. The HTML itself becomes the source of truth instead of React state. Now that we're not using useState, we can also remove the unused import. We can see in the gutter that there are two red boxes that represent some errors down below, so let's go look at those. We're referencing the SKU in two places, but we've removed that state. In the onClick, we can instead read the value from the input. Let me show you what that looks like. I can say const sku is equal to skuRef.current.value. This may look a little weird, so let me explain. The current property references the HTML element, and the value is the attribute that we read to get the value. I could read any HTML attribute that's on the element using this approach. Now my editor marks this line as a potential error because the value may be null. But in this case, we're safe. We assigned it to an HTML element in our JSX. And when this line is called, that element will exist. There's one final error to fix. The Add to cart button was being disabled if the size wasn't selected. With uncontrolled inputs, we no longer have an easy way to handle this. This issue emphasizes a downside for uncontrolled components. We have less power to render dynamically. Remember, React does not render when refs change. So instead, we're going to have to settle for a slightly lesser user experience. We're going to need to leave the button enabled, so I'm going to delete the disabled prop. And instead, what we can do is message the user if they click the Add to cart button without selecting a size first. So down here in the click handler, I'll show one simple approach. I can say if a SKU hasn't been selected, then we can return early and alert the user and say select a size. Now in a real app, I don't recommend using alert since it freezes the browser until it's accepted. But I'm just using an alert here to keep the example simple. And that's it. We've implemented our first uncontrolled input. To try this out, open up the App component, and we need to change the import to import DetailRefs just temporarily. That way we'll be able to see the file that we just changed. Now if we go over to a detail page, we can see that the Add to cart button is now enabled even though a size isn't selected. So if I click it, it says select size. But if I do select a size, then I can add to cart and it works as expected. Now that we've proven that it works, this step is important, I'm going to undo my path change here in App.jsx. So now it goes back to using the regular detail page. To close this clip, I want to show the two files side by side. So let's open up Detail and DetailRefs. I'll put DetailRefs over here on the right. So, note that we declare a ref instead of state. We assign the ref to the element instead of assigning state and a change handler. And down here, with the onclick handler, to get the value, we call the .current property on the ref, which gives us a current reference to the underlying DOM element. As we just saw, uncontrolled inputs are a less powerful approach. So we eliminated the Submit button disable feature in order to make it work. So how do you choose between controlled and uncontrolled inputs? Let's discuss that next.

Controlled vs. Uncontrolled Inputs
So the question is, what's the tradeoff between controlled and uncontrolled inputs? And when should I choose each? Both controlled and uncontrolled inputs allow you to set an initial value, and they can both be validated on submit. But if you want to go farther, controlled inputs are the way to go. With controlled inputs, you can validate instantly such as on blur, on focus, or on change, conditionally disable the Submit button, enforce a specific input format, display the same state in multiple inputs, and generate dynamic inputs that are tied to React state. In summary, you typically want to use controlled inputs. But there are two common use cases where uncontrolled components may be preferable. First, React is plenty fast for the vast majority of use cases. But if you're displaying many DOM elements that change frequently, then uncontrolled components may perform better by avoiding the overhead of React's diffing algorithm. And if you're working with non React libraries, implementing uncontrolled components via refs can help you integrate non React libraries. So if these cases don't apply to you, you're likely best off defaulting to controlled components.

Avoiding Setting State on Umounted Components
There's another issue in our app that we can solve using a ref. Let me show the problem by slowing the mock API down. Open package.json, and on the start‑api line, change the delay to 1500 ms. That's 1.5 seconds. Then, you need to stop and start your app for this to take. So, hit Ctrl+C to stop your app and then npm start. In the browser, click Inspect so that we can see our dev tools. And I'm going to click between the shoes page and the home page. Notice the moment that I do, I get an error, and the error is Can't perform or React state update on an unmounted component. The reason this is happening is I'm going to the shoes page, but I'm navigating away before it's able to set state. Here's what's happening. When I visit the shoes page, it requests the products from the API. If I leave before the call is completed, then later, when the call is completed, the component is no longer mounted. So the call to setState occurs on an unmounted component. If we try to set state on an unmounted component, then React throws this warning in the console. To resolve this problem, we can use a ref to check if the component is mounted before setting state. We can add this check in the useFetch hook since that's where our API call originates. Let's open up useFetch. At the top, let's import the useRef hook. Inside the component, we can declare a ref called isMounted that we can use to track whether the component is mounted. I'll make this the first line. So I'll call the ref isMounted = useRef false. And you may choose to call it isMountedRef. Some people prefer to use that suffix as I mentioned earlier. Now you can think of this as basically an instance variable. React will keep track of this value between renders. So we can use it then to track whether the component is mounted. When the component is mounted, we want to set this to true. We know the component is mounted once useEffect is run that first time because useEffect runs immediately after the first render. So we can set isMounted.current equal to true. Note that you must specify .current to change the ref value. The ref's value is always stored under the .current property. Next, when the component is unmounted, we need to set isMounted to false. So, we can use the cleanup function in useEffect to handle that. Any function that we return from useEffect is run when the component is unmounted, so that's perfect for our use case. Let's come down here to the bottom of useEffect, and we will return a function, which I'll declare as an arrow function. And inside this function, I will say isMounted.current is equal to false. Now when the component is unmounted, this function will be called and the isMounted ref will be set to false. Now we can put this ref to use. We can use it to only set state when the component using this hook is still mounted. So we can add checks up here to the then, catch, and finally blocks. So before all the places that I'm calling setData, I can check if isMounted.current, then setData. Down here in my catch, if isMounted.current and set the error. And finally, if isMounted.current, setLoading false. Let's see if it works. Now I should be able to quickly migrate between the two pages, and I no longer get an error in the console because we are no longer calling setState on an unmounted component since our code is checking whether it's mounted before making that setState call. You could also consider canceling the fetch call if you like. But for most purposes, what I've shown here is sufficient. Okay, to wrap up this clip, let's go remove that delay because that could get annoying. I'm going to set this back to 0, hit Save, and then hit Ctrl+C to stop my application and npm start to restart it. Once it starts back up, we should see the shoes page loads immediately. Looks like we're good. Next up, let me show you how you can store a previous value using a ref.

Storing a Previous Value
I've opened the useFetchAll hook. Right now, useFetchAll disables a linting warning above the dependency array. That's because we only want this useEffect to run once. But this useEffect actually depends on the urls parameter. So the urls parameter should be listed in the dependency array. However, if I delete this linting warning and then add urls right here, then it will create an infinite loop because the array of URLs that's passed in is recreated on every render. To clarify where that would happen, open up the cart page. Note that on line 6 and 7, we create an array of URLs and then pass that into useFetchAll. That means that every time that the cart renders, that array of URLs is created. So, within useFetchAll, this list of URLs will be a new list on every render, which would cause an infinite loop. To resolve this, we can use refs to enhance useFetchAll. We can compare the new value passed in to the previous value that was passed in. This way, our useEffect will only rerun if it's passed in new values. First, at the top, let's import useRef. Then, at the top of our hook, let's declare a new ref that we'll call preUrls. We'll set that to a call to useRef. I've called it preUrls since it will hold the array of URLs passed in from the previous run. Since the URLs are passed in as an array, let's initialize the ref to an empty array. In useEffect, we need to check if the array of URLs that's passed in differs from the previous run. So, let's create a function that compares arrays. I'm going to place this function down below the hook. Since it's a pure function, it doesn't need to be within the hook itself. And I'm going to paste in a simple function for comparing two arrays. So this accepts two arrays and then returns true if the arrays are the same length and each one of the properties have the same value. So you might pause for a moment and type this one up. Now to clarify, I could put this function inside the hook, but keeping it outside avoids the function being reallocated on each render. So, putting it out here is a tiny performance improvement. Now we can call this areEqual function to determine if the rest of the useEffect should run. So let's call it up at the top of our useEffect. We'll say if areEqual the preUrls.current and the new URLs that just got passed in, then return. So this line basically says only run if the array of URLs passed and changes. Again, note that the current value for a ref is under the .current property. So we say preUrls.current. Finally, if the URL arrays aren't equal, we need to store the latest URL value in the preUrls ref. So below this line, we need to say preUrls .current is equal to urls. So on the next run, the preUrls will contain the value from the previous run. That should do the trick. Now let's open up the Network tab so we can test this out. If I go over to shoes page, add a shoe to my cart, we can see that we don't have an infinite loop. However, there is one little bug to fix. If I remove everything from the cart and I go over to the shoes page and then come back to the cart, the loading state is never set to false. So to fix this, we need to set loading to false if we return early. So instead of merely returning right here, we need to add a curly brace in, call setLoading to false, and then we can do our return. Now when I save my change, I should be able to navigate between, come back, and the loader is hidden as expected. All right, that's refs. Time for a summary.

Summary
In this module, we saw that refs are useful to reference a DOM element, for creating uncontrolled components that aren't tied to React state, and for storing state that isn't rendered. You can also use refs to implement uncontrolled components if your use case has extreme performance demands, and you can use refs to store instance variables and functions for tasks like storing previous values and tracking if the component is still mounted. Next up, we'll explore a state management power tool, the useReducer hook.

Managing Complex State with useReducer
Intro
So far, we've used the useState hook to manage state, but React also comes with a powerful alternative called useReducer. In this module, we'll begin by exploring why useReducer exists and how it works. useReducer manages state via a pure function, so I'll introduce the concept of pure functions and explain when to consider useReducer over useState. We'll spend the rest of the module coding. We'll convert our cart state to use useReducer.

Why useReducer?
Here's an example of using useReducer. With useReducer, we declare a function that manages state completely separate from the component. The reducer is a pure function. It accepts state and an action and returns new state. Whatever we return becomes the new state. The reducer is passed to the useReducer hook, which returns the initial state and a dispatch function. The dispatch function is used to dispatch actions. Actions are how we change state. So, in this counterexample, the actions are increment and decrement. Note how dispatch is called and passed the action type. So type is the only required property on an action. Don't worry if this seems confusing at first. We'll switch our app to use a reducer one step at a time, and that should help clarify. But before we make the change, let me step back and explain why useReducer is worth considering. With useReducer, you extract your logic outside the component. This makes your component easier to read. You can declare the reducer in the components file or in a completely separate file. Since the reducer is a pure function, you can reuse the reducer if multiple components need the same logic. And since the reducer is a pure function, you can test the logic via unit tests. useReducer scales better than useState. With a large component tree, you can pass down dispatch instead of callback functions. Since dispatch maintains its identity between renders, it's easier to implement performance optimizations on child components. I just said pure function. This add function is a pure function. A pure function depends only on the arguments passed in. It doesn't rely on any values outside the function. It doesn't mutate its arguments. It has no side effects. In other words, it doesn't change anything outside of the function. Instead, it simply returns a new value based on the arguments provided. Pure functions offer a variety of benefits. They're idempotent, which is a fancy way of saying that pure functions always return the same output for a given input no matter how many times you call it. Since they depend on no outside state, they're composable and reusable. And since pure functions can be read and used in isolation, they're easy to understand and test. You can read a pure function all by itself and understand what it does. You can understand how it works without needing to understand the surrounding code. So it's a good idea to strive to write pure functions anywhere in your JavaScript code. But reducers help enforce this practice by requiring you to declare your state changes using a pure function. And when you do, you get to enjoy all these benefits.

Extracting State Management to useReducer
All right, time for coding. Let's implement the userReducer hook. We're going to convert our current cart state to use the useReducer hook instead of useState. The useReducer hook allows us to separate our state management from our component. With useReducer, we can declare a pure function that describes all the ways our state can change. A reducer sounds intimidating, but it's actually simple. It's a function that returns new state when passed an action. We can declare the reducer inside a component or in a separate file. One advantage of declaring it in a separate file is if you want to reuse that reducer across multiple components. Let's declare our reducer in a separate file. I'm going to right‑click on src, create a new file, and call it cartReducer.js. Inside, let's export a function default and call it cartReducer. Remember each reducer accepts state and an action. We don't have to name the first argument state though. We can give it a specific name. Since this reducer is going to work with our cart data, we'll call the first argument cart, and the second argument will be the action. We can handle all cart‑related state changes in this pure function. To decide what to put inside of our reducer, let's go look at App.jsx since that's where we're managing our cart state. Now ask yourself what code in here is related to managing cart state? The useState call for the cart, the useEffect that's writing the cart state to local storage, and three functions down below, addToCart, updateQuantity, and emptyCart. We can move all this state logic to our cartReducer, and there will be an action type for running the logic in each of these three functions. The addAction type will add to cart, update will update quantity, and empty will empty the cart. As I mentioned earlier, each action is required to have one property which is type. You can add other properties onto it, but the type property is required. So let's go back over to our cartReducer, and we can begin implementing it. Traditionally, use a switch statement and you switch based on the actions type passed in. Now, we can begin pulling the logic from App.js into this switch. Let's start with empty cart since it's the simplest. First, let's create a case to handle that. So we'll call the case empty. So if the reducer is called with an action type of empty, this case will be called. You could name this emptyCart if you prefer. Now in App.jsx, let's go look at the implementation. We can see that empty cart sets the cart to an empty array. But remember, with useReducer, whatever we return becomes the new state. This is important so I'm going to repeat it. Whatever we return from the reducer becomes the new state. Since we want to empty the cart, we simply need to return an empty array. So this handles our first action type. In the next clip, let's handle an unexpected action type.

Handling Unexpected Action Types
We've handled our first action type. Note that we have an ESList warning. If I hover over it, we can see that it expects a default case. We should declare a default case for our switch in case an unknown action type is passed in. For instance, that can happen due to a typo because we are passing in a string. So let's declare that default. And inside the default, we can throw an error and say Unhandled action and then add the action.type right after. This way, we'll get a helpful error message if we accidentally pass in an invalid action type. In the next clip, let's handle add in the reducer.

Handling Add In Reducers
Now let's turn our attention to addToCart. First, we need to decide what to name the action type for adding an item to the cart. Let's just name the action add. So we'll give it a case of add. Then, let's go get the logic from App.jsx for addToCart. We can copy this and then paste it over in cartReducer as a starting point. And be sure to copy rather than cut because we'll reference the code over in App.jsx in a moment. Now, remember, whatever we return becomes the new state. So that means we aren't going to call setCart anymore. So we can totally remove this first line, and we can remove the corresponding curly brace and parenthesis on the last line for that nested function. We can see three errors to resolve. Items, SKU, and ID aren't defined. Let's focus up here on items first. Items represents the items currently in the cart. The logic looks through the items in the cart to determine if the SKU being added is already in the cart. So the next question is how do we reference the current cart state in the reducer? The first parameter always represents the current state. I deliberately called the first parameter cart, but you can name it whatever you like. Some people prefer to call it state. Each time React invokes the reducer, it passes in the current state for this first argument. Since we named the parameter cart, we need to rename items to cart. So I'll rename this, and I'll rename items down here below, all three spots. Okay, two problems left. ID and SKU aren't defined. Let's look at the addToCart function in App.jsx. It accepts ID and SKU as arguments. So the question is, how do we pass arguments with our action? Well, we can pass arguments as part of the action object. The action object can have as many properties as we want. The only required property is type. So, let's assume that when the action is called, it will include the ID and the SKU as properties. So let's go back to our reducer. And then at the top of this case, we can use destructuring to get the ID and the SKU off of the action. Great. So now we have implemented the add case. The final action type to handle is updateQuantity next.

Handling Updates in Reducers
We can handle update the same way that we handled add. So you can likely guess how to handle updateQuantity. Pause the video now if you want to try implementing the update case yourself. Welcome back. First, let's create a case for updateQuantity. I'll just put it above add. And I could have named this update if I wanted as well. I'm just being a little more specific about what it's updating. And then, we need to go copy our code from App.jsx. So let's go over here. I'll grab the body of updateQuantity, copy that, and paste it in. Again, we don't call setCart anymore so we can remove the first line and the last line. So this gets us closer. And this also references the current state using items. But in the reducer, the current state is named cart. So just like we did in add, we need to say cart for both of these. And if we go back to the updateQuantity function, notice that it accepts sku and quantity as arguments. So, let's require those arguments to be passed in with the action. Again, we can destructure on the first line to pull these off of the action. Now you will notice that the sku is now underlined as an error because I'm declaring sku in two different cases. To resolve this problem, we can add a curly brace around this block, and that will give it a separate scope. So I'll put the curly brace down here to close for this case, and that resolves our error. Now this reference to sku is completely separate from this one down here. I could wrap this case in a curly brace as well, but it's not necessary. Now we're done configuring our reducer. So, we can jump back over to App.jsx and delete a lot of code. We can delete all the unused code because we don't need to reference it anymore. So delete empty cart, updateQuantity, and addToCart. In the next clip, let's update our app to call our reducer.

Consuming Reducers
Now that we have our cart reducer, we can replace the useState call in App.jsx. We can use the reducer to manage the cart state instead. First, let's import our reducer at the top of the file. We also need to import useReducer instead of useState at the top since we're no longer using useState. Now, we can replace this call down here to useState to instead use our reducer. So change useState to useReducer, and let's review the docs. We need to pass the reducer as the first argument to useReducer. So I'll pass it here. The second argument is the initial state. Let's extract this function call outside of the component since it only needs to run once. So I'm going to cut all of this and declare it outside of the component. To handle this, let's create a variable called initialCart. And then inside of our try, we can set the value right here. Set the initial cart to the value of JSON.parse or otherwise set initialCart to an empty array if parsing that fails. Then we can remove our closing lines down here. So we no longer need a function. This will just be called once on the initial page load. Now, we can pass the initial card in as the second argument to our useReducer call. Let's check the docs again. The final argument is an init function. This is useful for calculating lazy initialized state outside the reducer. We won't use this optional third argument. Much like useState, useReducer returns an array of two items. However, it's a bit different than useState. The first argument is the state, and the second argument is a function called dispatch. So, we need to rename setCart over here to dispatch. Now we can see on the right side of the screen that there are three errors to resolve, so I'll scroll down toward those. We no longer have functions to pass down to these child components. So instead, we can pass dispatch down. So let's replace each of these calls to send down dispatch instead. And be sure to change both the left and the right‑hand side for each. Since we're sending down dispatch instead, there's one obvious piece left. In the next clip, let's update each of our components to use dispatch instead.

Dispatching Actions
Now we're ready to dispatch actions, and we have three components to update, the detail page, the cart, and checkout. First, let's go to detail. I'm going to Cmd+click on it. It's a shortcut. So in detail, let's see where we're calling props. We can see down on line 37 that we're calling props.addToCart. Instead, we need to call props.dispatch since now we're sending down dispatch on props. However, with dispatch, we need to pass it an object. And remember, the object that we pass in has one required property, which is type. The question is what type should we be passing here? Well, the action type for adding to cart we decided was add. And to clarify this, if I come over to the reducer, notice that line 11 is looking for a case of add. So these two correspond with one another. So we are dispatching a type of add. We also need to pass the ID and the SKU as part of the action. So I'll keep these here as additional properties on the object that I pass over. And note, again, I'm using object shorthand syntax. I could say sku:sku, for instance, here. But it's unnecessary to convey the right‑hand side since the identifiers match. So, you can think of these other properties as arguments. This will call the add action and pass the id and the sku in. So that covers detail. We have two other files to update, cart and checkout. And our updates there will be similar. So I encourage you to pause the video now if you want to try updating those components to call dispatch yourself. Welcome back. Let's work on cart first. Cart accepts updateQuantity on props, but instead, we're now sending down dispatch. And then we can jump down here to where we're calling updateQuantity to instead call dispatch. Remember, with dispatch, we need to specify a type, which we're going to set to updateQuantity. And I'll put in a comma. I'm going to put these on separate lines for readability because we need to continue to pass the sku and the quantity in, and we'll close this. And we need to specify the quantity as a property. There we go. So now we're dispatching updateQuantity and passing sku and quantity as part of the payload. And if we look at cartReducer, we're passing updateQuantity because that again was the name that we chose for that action type. Okay, I saved the easiest for last. Let's open up checkout. Right now, checkout accepts empty cart. But instead, we're going to use dispatch. And that means that down here, instead of calling emptyCart, we will dispatch a type of empty. And this string with a value of empty corresponds with the action type we declared here on line 3. We don't need to pass any arguments with this dispatch, so we're done. And that's it. We moved all our cart state management to useReducer. Time to try it out and make sure we haven't broken anything. Should still be able to load shoes, view a shoe, add a shoe to our cart, change the quantity, hit Checkout, add some data, and checkout. Our app works exactly the same as before. But the big difference is now our app component is far simpler. We have some JSX and a single line that calls the reducer. So our state management has now been extracted from app into a pure function. Before we close the module, let me contrast useState and useReducer.

useState vs. useReducer
Let's contrast useReducer and useState. When should you consider each? Well, useState is easy to implement for most scenarios, and most people will find it easier to learn. useReducer is more of a power tool. It's more scalable for complex scenarios such as situations where you have many complex state transitions, multiple sub‑values, or when the next state depends on the previous state. You can reason about the state in isolation without the noise of the component around. And since reducers are pure functions, you can test a reducer in isolation to assure that it operates as expected. Finally, since you can declare it in a separate file, reducers can be reused across components. In summary, consider useState a good solid default. But consider refactoring to useReducer when state management starts feeling overly complex.

Summary
In this module, we switched from useState to useReducer. We saw that useReducer implements a pure function for handling state. This means that we can unit test our state changes in isolation. We can reuse the state logic on multiple components. And because of these benefits, useReducer scales well for complex state transitions. But keep in mind you don't have to choose one or the other. You can mix useReducer and useState in the same component. In summary, consider useReducer for a more complex state. In the next module, it's time to explore another tool for building big apps. What if you want to share global data and functions across your entire app? We can do that with context.

Sharing State and Functions via Context
Intro
So far, we've been passing state and functions down to our components via props. But what if you need to share the same state or functions with nearly your entire application? Well, that sounds like a job for context. We're going to begin by answering that question. Why and when should you consider using context? Then, we'll spend the rest of the module coding. We're going to use context to share our cart data and our functions with the entire application. Along the way, I'm going to show how to wrap your context provider in a custom component, and we'll implement a custom hook to simplify consuming the context.

Why Context?
Let's begin by asking a basic question. Does my app need context? No tool is perfect for every job, so I think it helps to think about complexity on a spectrum. On one end is the simplest tool that requires no setup. And on the other end is a complex, powerful, and scalable tool that requires significant setup. Now if you're building an ultra simple application, then perhaps all you need to use is plain JavaScript. However, an app doesn't have to get very complex before you realize that writing plain JavaScript gets painful. As you start adding interactivity forms, logic, and you want to create reusable pieces, then React becomes very worthwhile. Now as your data flows get more complex, you may find yourself displaying the same data in multiple places. At this point, there are two popular options to consider, React's built‑in context or Redux. As you move to the right on this slide, capabilities increase but so does complexity. I just mentioned that React's context and Redux can solve some similar problems, so let me step back and explain how each works. Imagine this is your React app's component tree. Each circle represents a component in your app. The top circle represents your top‑level component, which passes data down to all these child components via props. What if these two components need to work with the same data? They're in very different parts of your app. So, how can they work with the same data? For example, imagine these components in blue need user data. Each would need to make an API call to retrieve user data from the database, but that might be wasteful and redundant. And how would they communicate to assure that the user data that they're using stays in sync? There are a few popular ways to handle this. The first option is to lift their state to a common parent. In this case, it means moving the user data all the way up to the top‑level component since that's the only common ancestor. This is annoying though because it means that you have to pass data down on props through all these other components, and these components don't need the user data. You're merely passing the data down on props to avoid storing the same data in two spots. We added the user prop to these six components merely to pass the data down to the components that need it. This problem is commonly called prop drilling. That said, lifting state works, and it's a good first step for small and mid‑size apps. But on larger apps that need to display the same data in many spots, lifting state can become tedious and it leads to components with many props that exist merely to pass data down. So does this mean that prop drilling is bad? Not necessarily. But passing props through components that don't need them does create some risk by exposing data and functions to components that don't actually need those values. So let's look at two alternatives for lifting state. A second option to consider is React's context. With React's context, you can expose global data and functions from a given react component. To access this global data, you import the context in order to consume it in your component. For example, the top‑level component could declare a UserContext.Provider. This provider would provide the user data and relevant functions to any components that want to consume it. So the two components that need the user data can import the user context and thereby access the user's information via the UserContext.Consumer. Since context can also expose functions for global usage, then the consuming component can also call a createUser function that's actually declared way up here in the top‑level component. We're going to implement context in the next clip. A third option to consider is Redux. With Redux, there's a centralized store. Think of the store like a local client‑side database. Any component can connect to the Redux store. The Redux store can't be changed directly. Instead, you dispatch actions, and those actions update any components that are connected to the Redux store. So, when are context and Redux worth considering? The bottom line is you can build impressive apps with just React. But context or Redux can be useful for apps that need to share global data or functions across the app or for apps that have complex data flows or when you need to handle interactions between two components that don't have a parent/child relationship. Context or Redux can also be useful as your app offers an increasing number of actions such as a variety of writes, edits, and deletes of complex data structures. This module is going to focus on context since it's built in to React. Redux is a large topic and a separate open source project, so we won't cover it in this course. Check out Building Applications with React and Redux for more on Redux. In summary, begin with state local to a single component. Just use plain React state. Then lift your state to a common parent when more than one component needs the data. Try context or Redux when lifting state isn't scaling well. All right, let's move on and implement React context.

Declaring a Context
Let's use context to share our cart state and the associated dispatch function with all components. First, let's create cartContext in the src directory. Right‑click, New File, cartContext.js. Let's import React at the top. To create a context, we call React.createContext and pick a name. So let's export a const called cartContext, and we will set it to the results of calling React.createContext. We can optionally pass a default value for the context as a parameter, but I'm just going to set it to null. The default value would apply if a component tries to consume the context without being nested under a provider. I typically don't recommend declaring a default, so I'm just going to leave it as null. In the next clip, let's declare the cart provider.

Declaring a Context Provider
We've created the context, so now let's declare the provider. The provider determines what state and functions are shared via the context. Now, we're going to share the cart data and the reducer's dispatch function. This way, any component can access the cart data without having to pass the cart down via props. Let's declare the provider in the App component since the cart state and functions that we want to share are initialized here in the App component. First, let's import the context that we declared in the previous clip. So we will import cartContext from ./cartContext. Next, we can declare the provider in the JSX. Any components under the provider will be able to access the provided values. So let's come down here and wrap all of our JSX in cartContext.Provider. And then, the closing tag which I'm going to cut needs placed down here at the bottom of our JSX. So I'll replace the empty fragment with the closing tag. The provider accepts one prop, which is value. The value prop determines what data and functions are shared on the context. We know that we want to share cart data and the dispatch function from the reducer, so let's set that as the value. And we'll pass it down as an object so I'll end up nesting curly braces here. I'll pass down the cart and the dispatch function. So this says these values can be consumed using the cartContext. In the next clip, let's update a component to consume our new context.

Consuming Context
To consume the context, let's update cart first. Jump to the top, and the first thing we need to do is import the context. So we will import CartContext from ./cartContext. Then, to consume it, we can use the useContext hook, which we can import from React. The useContext hook allows us to consume a context. So, up here at the top of the component, let's add a new line and consume the context. I'm going to leave these curly braces empty at the moment, but we'll call useContext and pass it the CartContext that we want to consume. The call to useContext returns the items that are provided on the context. Now remember, we're providing the cart and the dispatch function as you can see here on line 27. So, that means that we can destructure what we'd like over here on the left, which is the cart and the dispatch function. And now that we're accessing these items via context, we don't need to pass them down via props anymore. So up here, we can stop destructuring those values since we're no longer expecting them on props. We can also remove these props from App.js because we no longer need to pass them down to the cart component. So now, if we go to the cart, we can see the cart is empty. Let's go add an item to our cart. Hit Add to cart. And now, I am viewing my cart and seeing cart data even though we're not passing the cart down on props. Our cart is now getting the cart information via context. We can also change quantities, so we know that dispatch is working properly too and getting passed down. And if I jump between shoes and cart, we can see that that value sticks. Now I want to clarify two things. What we just did was totally unnecessary for this small app. Context is useful for large apps where passing props down through dozens of components gets tedious. So don't use context in simple scenarios like this. Consider it as a useful tool for managing global data and functions in large apps. Second, we can improve our approach. What we just did works fine, and we could repeat these steps for the other components. However, I recommend centralizing your context configuration in a single file. So next, I'm going to show you how to do so and why it's useful.

Creating a Provider Component
I recommend that you centralize context‑related code in a single file. Here's why. Doing so makes the context easier to consume, and it also helps assure that all components consume the context in a consistent way. Second, I find that it makes the context easier to understand. As you'll see, this pattern is going to simplify the App component. We'll continue our work over here in cartContext.js. We're going to declare a component that will provide the context. So let's call that component CartProvider. So we'll export a function CartProvider, and it will accept props. Inside, we can return the CartContext.Provider. This component should render whatever children we compose underneath. So let's render props.children. We know that we want to share the cart data and the dispatch function. Since this component is going to be responsible for managing the state and functions, let's cut some code from the app and move it into the CartProvider component. Over in App, let's cut this useReducer call and paste it over into our CartProvider. So now our provider is going to be responsible for calling useReducer. This means that we need to import useReducer as well. We also need to import cartReducer. So let's go cut the import from the App component since it's no longer using it and paste that up here. We also need the state initialization code, so let's go back to App.jsx and cut that too. We'll take all of this code out, cut it, and place it over here in our provider. We can paste it up above the CartProvider component because it doesn't need to be inside the component. It only needs to run once when the application first loads. Next, we can go cut the local storage call and move it to the CartProvider too. So this line can be cut, and we can place it below our call to useReducer. However, we do need to import useEffect now since we're using it here. And we need to pass the value prop down via our provider. So we can set the value here and set it to the context value. Just for readability, I'm going to set the context value on the previous line up here and say const contextValue is going to be equal to the cart and the dispatch. And then, I'll pass the context value here on the value prop. Finally, we can go over to the App component and remove a couple of unused imports. Don't need useReducer or useEffect in here anymore since that's all being handled now via our new ContextProvider component. Now that we have this CartProvider component, we can wrap it around any JSX, and those child components will be able to access the cart and the dispatch function. We don't have to pass those items down on props. In the next clip, let's update the app entry point to use this new context provider component.

Wrapping the App In a Context Provider
To put our CartProvider to use, let's set it up in the application's entry point. Rather than putting in an app, we're going to go a level higher, and we'll put it in index.js. So import, and I'll use the import statement here, ./cartContext, and what we want out of there is the CartProvider. I'm going to wrap the CartProvider around the App component. Then I'll use Alt+down arrow to move it around app. Now, any component in the app can consume the provider. If only a portion of the app needed this data, we could wrap the relevant child component in the provider. Then, only that component's children could consume the context. But for most context values, you'll likely want to share them with your whole app like this. Now that we're using the CartProvider in our root component, we can remove the provider that we declared in App.js. It's no longer needed. So let's go back to App.jsx. We can convert this back to an empty fragment and update the closing tag as well an. And we can delete the unused import for CartContext at the top. Now our App component is much leaner. It's just JSX. But we're not quite done transitioning our app to use context. Since we've moved all our cart state out to context, we need to update all our components to consume the cartContext. We could repeat the steps that we performed to consume the context in the cart component. But to streamline that process, I want to show you how to create a custom hook for consuming cartContext next.

Creating a Reusable UseContext Hook
I recommend creating a custom hook for consuming each context. There are multiple benefits to doing so. A custom hook makes context easier to consume. It requires less code to set up each consumer. A custom hook protects the context because we don't have to export the raw context at all. And finally, we can even display a helpful message if someone tries accessing the context when the provider isn't available. So, let's declare a custom hook in our cartContext file. First, we need to import useContext because we're going to call useContext within this file. Then we can declare our custom hook down here as a separate function. We'll export the function, and we'll call it useCart. The goal of this hook is to make it easy to consume the cartContext. So, we're going to use the useContext hook that I just imported. So we'll hold the value within a variable called context, we'll call useContext, and we'll pass it the CartContext. Then, we'll return the result. And that's it. It's a very simple hook. But the benefit of this hook is it will be easier to consume the context in each component. Because now we merely import this hook, we don't have to also import the cartReducer and pass it into the useContext hook. And, as I mentioned a moment ago, we don't need to export the context up here anymore because now we've created an API around our context. If you want to consume it, you use the useCart hook, so I'll remove this export keyword. So now it's enforced that components can only consume the context via the public API that we've provided in this file. So that should do the trick. Now we're ready to consume our new centralized context setup in some child components using our new custom hook. Let's do that in the next clip.

Consuming Context Via Custom Hook
To consume our context, we can use the custom useCart hook that we just created. Let's start with the cart page. Instead of importing the cartContext, we can now import the useCart hook. And instead of calling useContext here, we will call useCart. useCart doesn't accept any arguments because it's already configured with the proper context. So you can see the advantage of our hook. We didn't have to import the context as well, and we also no longer have to import the useContext hook. So we save a little bit of code. The final step is to update the other pages to consume from context. Pause the video if you'd like to try updating checkout and detail to consume the cartData and dispatch functions via our useCart custom hook. Welcome back. Let's open up Checkout next and finish our conversion. At the top, again, we need to import from the cartContext. We need the useCart hook. And this component only needs dispatch, so we will put in our const and call the useCart hook. In our destructure, we can reference dispatch since that's the only value that we need from our context. And then we can delete these up here. We actually didn't need the cart reference on props anyway because that was not being used. And we have one page left to update. Go over to the detail page and we'll do pretty much the same thing. We'll no longer be getting data on props. Instead, we're going to pull it in from context. So we will import from context using the useCart hook, let's put in a blank line here and then destructure what we need, which is our dispatch function from useCart. Then down here, we were calling props.dispatch. Instead now, we just call dispatch. Now all our pages get cart data and functions via context instead of via props. So, we can remove the props from App.jsx as our final cleanup step here. So this means no more props here and no more props here. We can see the app loads again. I can navigate around. I can add a shoe to the cart. I can change quantities. I can remove an item from the cart. And I can check out . The app works the same as before, but the App component is much leaner now. We extracted our state management concerns using useReducer, and we've provided our global cart data via context. So now the only thing that the App component is responsible for is declaring routes. State management is handled completely separately, and the state can be accessed from any component. As a final step, let's add a helpful warning to assure that the context provider is declared in a parent component.

Requiring a Context Provider
To consume the cart context, the provider must be declared an apparent component. So, it's a good idea to assure that the provider is declared by adding an error check inside the useCart hook. After we read the context from the cartContext, we should check if the context exists. And if it does not, then we should throw an error and say useCart must be used within a CartProvider, wrap a parent component in CartProvider to fix this error. I'll scroll up so we could see this. So now, if someone tries to consume the context, using the useCart hook and the component isn't composed underneath our CartProvider component that you see up here, they'll get this handy message, useCart must be used within a provider. Wrap a parent component in CartProvider to fix this error. So to see this work, if I go over to index.js and I comment out the CartProvider and hit Save, I can see the error displayed up on the screen. This tells me exactly what I did wrong. I forgot to set up the provider in some parent component. Error messages like this are useful. Trust me, your fellow developers will thank you. So I'll undo this. Let's close the module with a summary.

Summary
Let's wrap up. If you need to share global data or functions, consider using context or Redux. React's context has two moving pieces, the provider, which provides data and functions to child components, and the consumer, which consumes the data and functions exposed by the provider. I recommend wrapping context by declaring context in a single file. To do this, we exported a provider component that managed context state, and we created a custom hook that made it easy to consume the context. Wrapping context also means that you can throw a helpful error message if someone accidentally tries to consume the context without a provider. And we're almost done. In the final module, let's briefly look at some popular third‑party state libraries, and I'll close with a few suggested exercises to put your new skills to use.

Managing State via Third-party Libraries
Intro
Throughout the course, we focused solely on state management approaches that are built into React, but there are a variety of compelling third‑party libraries to consider too. In fact, the number of open source state related libraries is downright intimidating, and this isn't even an exhaustive list. So, in this final short module, I want to briefly draw your attention to a few popular libraries that you may find useful. I'll break the options down into five categories, local state, global state, server state, immutable state, and form state. I'll review all the state options that we implemented in the course and clarify when to consider each. And I'll close with some recommended exercises so you can put your new skills to use.

How to Run the Demos
A quick note before we dig in. I've provided working demos for some of the third‑party libraries that we're about to briefly discuss. To try them out, download the course exercise files from the course page. Open the folder for the last module. Run npm install to install the third‑party dependencies. And finally, I've created new files for each of the demos.o change the import in App.js for the demo that you'd like to run.

Local State
Let's talk about local state first. The goal of local state is to manage state for a component, including useState, class state, useReducer, and refs. We also derived state in multiple places throughout the course. A third‑party option worth considering is XState. XState is useful for handling complex state and transitions. Remember, the simple state enum pattern that we implemented in the form validation module is often sufficient for enforcing a single logical state at a given time. But XState provides more power by enforcing when and how state can transition. And you can visualize your state transitions using a state chart. A state chart provides an interactive visualization of your state logic and can be helpful when your application contains complex state and many transitions. And like useReducer, you can test XState's logic in isolation.

Global State
Next, let's talk about global state. The goal of global state is to share state or functions globally throughout your application. To handle global state, we lifted the cart state to the App component so that we could share it throughout the app. And later, we used context to share the cart and related functions. But there are some good third‑party options to consider. You may also enjoy Redux. Redux is a popular and powerful library for handling global state and actions in a consistent testable manner. Consider Redux if your app is big and complex with many state transitions, if you want to cache and share local data, or if you'd like to handle cross‑cutting concerns via middleware. You may wonder how to choose between Redux and context. Generally, context is great for simple values, especially those that change infrequently. Redux is useful for complex values that change often, complex state logic, and it supports middleware for cross‑cutting concerns. So both are great options, but Redux is especially scalable for large complex apps with many actions and frequent state changes. You now know all that you need to dig into Redux. Check out building apps with React and Redux for more. A second third‑party option to consider is MobX. If your app contains a lot of derived state that changes often and is expensive to calculate, you may enjoy MobX. You could think of MobX as an automatic performance optimization for derived state. Now to clarify, you don't need MobX to make your derived state more efficient. If you run into performance problems, then you can resolve performance issues manually using React.memo, shouldComponentUpdate, and other performance optimizations. And in my experience, performance issues are quite rare in React apps. But if your app contains a lot of derived state, you may enjoy MobX's streamlined approach for efficiently managing derived state. Another benefit of MobX is you can manage your app state outside of React, which means that you can test it in isolation too. A third option is Recoil. It focuses on a rather niche problem. Consider Recoil if you have lots of stuff on the screen that changes frequently and you need to avoid updating unrelated parts of the UI. Of the three, Redux is the most mature and most popular. But all three of these are worth considering since they solve problems in different ways. You may also want to consider these simple alternatives. Zustand is a simple Redux alternative, Jotai is a simple recoil alternative, and Valtio is a simple MobX alternative. And this is far from an exhaustive list. See the first clip in this module for a more complete list of options.

Server State
Next, let's talk about server state. The goal of server state libraries is to fetch and cache server data. React doesn't have an opinion on how to fetch server state. So, many end up using fetch or Axios to call the server. We wrapped fetch in a custom hook called fetchAll, but there are some excellent third‑party libraries to consider in this space including react‑query, swr, Relay, and Apollo. To understand why these are useful, think about the questions that you should probably ask when you're making HTTP calls to the server. Chances are you're not currently asking some of these questions. It's easy to forget these concerns. That's the benefit of using a data fetching library. A good data fetching library can handle all these concerns for you. These libraries have a simple goal. Make it easy to fetch and cache data from the server. We implemented a custom useFetch hook in the course. These libraries could potentially replace it. React‑query and swr work with just about any endpoint, such as REST or RPC APIs. Relay and Apollo are popular options that are focused on working with GraphQL endpoints. So if your endpoint is GRAPHQL, they're certainly worth a look. React‑query and swr are quite similar. They provide an automatic dedicated server cache. When you make a request, the library caches the data to avoid making needless duplicate requests. And since they provide their own separate cache, you're still free to handle other state however you like. These libraries automatically handle many other concerns too. When the data gets stale, these libraries invalidate the cache and refetch data from the server, duplicate requests are avoided during a given time period, and they auto retry if a call fails. Plus, when you refocus a tab, these libraries will refetch the data so that the latest data is displayed. And if a network connection is lost, they'll fetch fresh data upon reconnect. React‑query and swr use the stale‑while‑revalidate HTTP header. This header is basically a way of saying I'm okay with showing slightly stale cached data for a moment so that the user doesn't have to wait for the API call to complete. Implementing this is a three‑step process. It first returns the cached record. Then it requests the fresh record from the server behind the scenes. Finally, we update the screen to display the fresh record if it happens to be newer. So the result is the user instantly sees data when returning to a record that's already been loaded, even if the API is slow. And if new data becomes available after checking the server, the UI is updated. Quite slick. I created a copy of the products page that uses react‑query called Products.react‑query.jsx. I've updated App.jsx to reference that file. And inside package.json, I've set the delay on the mock API to 2 seconds. If I come over to the app and hit Refresh, we can see that it takes 2 seconds before the shoes display. But since I'm using react‑query, if I go to the home page and come back to Shoes, notice that the shoes display immediately, even though if we look down in the Network tab, we can see that the network call still takes 2 seconds. So react‑query displays that cached data and then makes a call behind the scenes to fetch the latest data. If any data has changed on the server, then we'd see that reflected the moment that that call returns. If I click back and forth again, we can see that we get this instant behavior even though the network request takes 2 seconds. React‑query is one of my favorite libraries. I highly recommend checking it out. So check out Products.react‑query to see the simple changes that I made to use react‑query on the products page instead of use fetchAll.

Immutable State
React state should be treated as immutable. However, React doesn't include any tools to assure that we do so. So, we used plain JavaScript, which worked just fine, but it doesn't actually enforce immutability. And we have to be careful to copy state in each state setter. So you might want to consider a popular open source library called Immer. With Immer, you can write mutative code, and it will handle the immutable update for you. It uses plain JavaScript, so its API is small and easy to learn. It has a small bundle size as well. And Immer uses JavaScript's native Object.freeze to create immutable objects. So this protects you from accidentally mutating React state. Here's an Immer example. With Immer, you call a function it provides called produce. You pass produce the data that you want to change as the first argument. And for the second argument, you specify a function that mutates state. Immer magically handles the mutation in an immutable‑friendly way by copying the state you provide first. Note that it looks like I'm mutating the name property, but I'm actually changing a copy of state that's called draft. Immer copies the user object and returns the new user with the name property set to the new value that I've specified. The original user object hasn't been changed, but our userCopy object has the new value assigned. Handy. And since Immer is a general immutable data library, it's actually not tied to React in any way. I created a copy of cartReducer that uses Immer. So review cartReducer.immer.js for an example of using Immer to handle state updates.

Form State
Form state libraries help you build complex forms. Throughout the course, we built forms using React's built‑in features including state, event handlers, and derived state. But you may also enjoy focused third‑party form libraries like Formik or React Hook Form. These libraries reduce boilerplate and help enforce useful and proven conventions. These libraries help eliminate decisions while building forms by enforcing a structured form‑handling approach. You may enjoy the opinionated approach that's provided by these libraries. These libraries tend to help you build a form faster because it requires less code to implement the form. The core tradeoff with these libraries is you write less code per form in exchange for a larger app bundle. I created a copy of the checkout form that uses Formik to show you how the code compares. Review Checkout.formik.jsx. This completes our quick review of some popular third‑party libraries to consider. I want to close the course by reviewing eight ways to handle state in React apps and give you a few exercises to put your new skills to use.

Summary: How to Handle State
At the start of the course, I shared eight ways to handle state in React apps. Let's review how to choose between these options. Store location‑related state solely in the URL. We used React Router to help us with that. Consider persisting data using web storage when it's low risk and you want to persist it between page loads. Use local state when only one component needs the state. Lift state to a common parent when a few related components need the state. Strive to derive any state that you can, and use refs to reference DOM elements or store state that isn't rendered. Consider context when you need to share global or near global data in functions. And remember, as we just saw, there are many compelling third‑party libraries to consider as well for handling things like global state, server state, form state, and more. Here's another way to think about the previous slide. These are eight questions you can ask yourself in order when you're trying to decide how to handle state. I won't read through it, but consider taking a screenshot and holding on to this one. It could be useful to reference later.

Recommended Exercises
Congratulations on making it this far. Now to practice what you've just learned, here are some exercises that I recommend. The store currently only sells shoes. I've provided images of a few backpacks. They're in the public folder and in the same directory where the shoe images are stored. Use these pictures to start selling backpacks on the site. Finish the checkout process, accept billing and shipping info, and allow copying from the shipping info so the user doesn't have to re‑enter their data for the billing info. Save a partially completed checkout so the user can come back and see their data and display a confirmation that includes their final order data. Display the number of items currently in the cart in the navigation next to the cart link. On the cart page, deduplicate the requests. Right now, if you add the same shoe to the cart in multiple sizes, the product is requested multiple times. I suggest that you dedup the request in the useFetchAll custom hook. Enhance the useFetchAll hook to accept a separate init argument. See the fetch docs on MDN to understand why the init argument is useful. Try using react‑query or swr to handle the app's API calls. Note how they cache your query results. And that's a wrap. Congratulations on making it to the end, and thank you so much for watching.