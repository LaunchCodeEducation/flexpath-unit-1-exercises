Hi, and welcome to Network Requests in JavaScript. My name is Christian Wenz, and I'll tell you everything you need to know to use JavaScript to talk HTTP and related protocols with a server. During this course, we will cover a lot of things. First of all, we will talk about HTTP, not very in depth, but there are some fundamentals that you absolutely need to know like HTTP methods and HTTP headers because you will be able to use them from JavaScript. And then there are several options to talk HTTP from JavaScript. One is the Fetch API. Nowadays, that's probably the most common way to exchange data via HTTP with a server. There are external libraries as well, and a very well known one is Axios. So we'll talk about the Axios HTTP client as well. Previously, there has been another option that's still relatively popular, and that's XMLHttpRequest, a browser JavaScript object that goes back to Internet Explorer. And finally, we'll also talk about WebSockets that can be used for very efficient bidirectional data exchange with a server, so we definitely need to talk about this. Before we proceed, one important caveat. In this course, we will use JavaScript in a browser context most of the time because arguably that's what most JavaScript developers are doing. However, if you are not working in a web browser context, if you're using Node.js, you will still be able to apply everything I'm showing and explaining to your system and to your applications. If there is something that is very browser‑specific, for instance, how to incorporate HTML content into a web page, I have shielded that away so that we really only focus on working with HTTP. And with that out of the way, let's get started.
This course has been created using the latest versions of ECMAScript and Node.js at the time of recording. Node and other engines determine which language features are supported. The code I demonstrate is supported by all major engines and browsers. This slide shows the versions of ECMAScript and of Node.js for which the information in this course applies.
During this course, we will add several features to a web application. The web application is the Globoticket site that's a fictitious company selling event tickets for future events. Well, also for past events because they somehow have to make ends meet. Let's have a look. The sample application is using Node.js, both for serving the static content and also for providing an API the Globoticket site can communicate with. To run it, just go into the folder that contains the exercise files, and then first, do an npm install, which should install all required dependencies. Depending on what's already there, this might be a very quick process or one that takes a minute or two. And then we can just do node .\index.js, and that runs the application on port 3000. So if you go to localhost port 3000, we see the application running. And here is the application. Well, the application so far. We have the Globoticket site here, and we see a list of events, currently only one event, but there will be more eventually. We see Date, Name, Artist, ticket price, and then we can also add the ticket to the shopping cart. And as you can see, the number of tickets in the shopping cart is then updated. There's not a lot of stuff going on here, but we'll gradually add some features to that application. There is one feature, which has already been implemented, and that's one API endpoint, the Events API accessible via /api/events. So we get a list of a couple of concerts or whatever that should be with names, and dates, and prices. This is how Firefox is rendering this so that it looks nice, but what is essentially coming from the server is just raw JSON. And this is a structure we will be working with later in this module.
It's time for us to take a quick look at HTTP. How does an HTTP request and its response look like? Because that's what we will be doing from within our code. So we have a client and a server. In our example, the client is a browser, but, of course, it could also be a client application, and that then sends an HTTP request to a server endpoint. It starts with something like this, first the HTTP method. We are using GET here, which also is the most common one, but there are others. And in the next module, we will see how to use those others as well, and then the URL without the hostname and the protocol, just the path to the endpoints. So here there seems to be an API that gives us a list of events, and there might even be pagination here. And then the third piece of information here on that line is the protocol being used. Here, in our case, it's HTTP/2. It's great that we have a request like that, but we still don't know which kind of host, which server we would like to talk to, and that's what the host HTTP header is for. These HTTP headers are sent automatically when doing an HTTP request within the browser, for instance. Or if we say let's send an HTTP request to HTTP globoticket.example.com/api/events, then this is the end result. There are other headers as well. We can set some of the other headers. Some others are set automatically. For instance, there's the User‑Agent HTTP header, which sends an identification string for the browser or client being used. Browser is sending that automatically. If we are using a client application, we could and should set this manually. Also, we could have state information. So, basically this sends a cookie the client already has back to the server. When later sending HTTP requests with JavaScript, of course, the most important aspect is the URL, but we can also set some extra headers if we need to. The server then processes the HTTP request and returns data, at least that's what we hope. First of all, we get the protocol and the status code. Status code 200 is my most favorite status code because it means okay. That's why it also says OK. And the data returned from the server, basically that means the request worked. Also, the server can send HTTP headers. We have already seen request headers. Now we see response header, for instance, the Content‑Type. What is the format of the data being returned? Here, it is JSON, but of course, it could be an image, for instance, or HTML or any other format. And the Content‑Type header says which kind of content we are working with. The server can also send the length of the data being returned that excludes the headers, just the actual payload of the data being returned. And after a long or not so long list of HTTP headers, there is a blank line. And after that blank line, the server sends the actual data. So here, it could be a JSON structure, which we can then parse and use from our JavaScript code. And that is HTTP in a nutshell.
It's time to send our first HTTP request from JavaScript, and we are using the Fetch API for that. As you can see here on caniuse.com, the Fetch API works in all modern browsers and not in IE, but that's essentially what I said. In Node.js, support for the Fetch API was added in version 16.15.0 and 17.5.0, and it's also available in more recent versions. It can still be an experimental feature, but at least in my project experience, it works flawlessly, so you can use that API from Node.js as well. That being said, let's have a look at how Fetch works. We just call fetch. And as an argument, we provide the URL of the endpoint we would like to call. So here it's api/events because in our application, the API resides on the same server as the application. Fetch is a promise‑based API, so the call to fetch doesn't return actual data. It returns a promise because HTTP requests should be done asynchronously because it could take some time for the data to arrive from the server if you would like to block our application while waiting. We can then resolve the promise, so how can we do that? First of all, the data that comes back will be encoded in some format, and we might be interested in decoding it. The Events API returns JSON. So this call takes the response, and then JSON decodes it so that at the end if we resolve this, we get a JavaScript structure. If we're interested in just the text without any parsing, we could use response.txt. Well, and then we just take the data. So, in our case, the data is a JSON structure. We could log the JSON structure to the console, or we could apply to the page or iterate over the list of events that depends on the application, and we will do that in our app right now. All the static assets of the Globoticket application reside in the public folder, including the file index.html, which contains the markup for the start page with the list of events. Currently, there is only one event, but we can use the API to show all of them, and I'll show you how this can be done. So I'm adding a script tag for JavaScript, and I do this at the bottom of the document. It makes it then easier to insert the content on the page. And there we just issue a call to fetch, and api/events is the relative URL to the API. No extra configuration, no extra HTTP headers, no other HTTP method to define. So the call here is really simple, and then we wait for the response and parse the response because we expect it to be JSON. Then we get a JSON structure. So I just call this maybe events, and then we can just log those events to the console just to try whether everything works as expected. I launch the app, open the browser DevTools, usually with the F12 key, and head to localhost port 3000. And we see here in the Network tab that indeed there is a request being sent to the events endpoint. And if you have a look at the console, then we see that indeed we got a list with five items back, the five items the API returns. This is a great start, but, of course, we now would like to display those events, but displaying that is not the focus of this course because we are talking about HTTP and not about DOM, for instance. That's why I've already created that functionality. It's already present in that file, and it's a function called showEvents. So we just call showEvents, and then the event data is inserted into the DOM, the Document Object Model, of the page. Back in the browser, we close those tools, we refresh the page. And as you can see, we now get a list of precisely those five items that the API returned. We have successfully issued our first HTTP request from JavaScript, but the Fetch API offers so much more, and this all is up next.
Hi, and welcome to Deep Dive into fetch() where we will have a closer look at the Fetch API, looking at more and also some advanced features. And we'll start with a different way of providing options to our fetch call and to configure it. Up until now, we have just provided a URL, and that's it. So by default, we send a GET request, but obviously there are more options, and this is how it works. We once again provide the URI. But then in the second argument, we use a hash table with the options for that HTTP call, and there are several keys we could set, too many to show them all, but here are a few important ones, for instance, the HTTP method. So we could specifically say we would like to use GET, which is the default, or we could use POST or any other HTTP method. What we can also do is we can set HTTP headers, and, of course, that's request headers. The value is, once again, a hash table with the header names and the values. So for instance, we could send the Accept HTTP header and by that tell the API that this is the format or the list of formats that our application supports and expects. By default, we always get JSON back, but we could say we would prefer XML. Actually, let's try that out. I happen to know for a fact that our API does support this content negotiation, as it's called, and can also return XML if prompted. Now we do not really want to process that XML, but I still would like to show you how HTTP headers can be set because we will need that later on in this module as well. So, here's our old call. And what we now do is we add the options hash table, so I set the method to GET, as we've seen. And I set the headers to a list that includes the Accept header, and the value will be text/xml. So far, so good. And then, of course, we cannot convert the response to JSON or better to parse the JSON and convert it into a JavaScript structure. Instead, we just process it as text, and then the showEvents method cannot really work with text, so we just log those events to the console to see whether we have really received XML from the API. Make sure that the app is running. And then if we go to localhost port 3000, we see our requests to the events endpoint there. In the list of request headers, we see the Accept: text/xml entry, and the response is indeed XML. Not surprisingly, the console now also contains the XML output. So we can now set a specific HTTP address, and we can also use different HTTP methods.
We have worked with GET requests so far where all parameters are part of the URL. Let's have a look how POST requests work with the Fetch API. Once again, we call fetch, we provide a URL, and then we have a set of options. No surprises so far. You have already seen the method key that we can now provide, and this time we set it to POST. However, that's not enough. We have to tell the server which format is being used to send data to it. We have an API that most of the time works with JSON. So as a header, we could say 'Content‑Type': 'application/json' because that tells the server that the payload of the HTTP request is in a JSON format. There are different content types that we could use here. For instance, if we had a regular HTML form, then a different content type would be used. And where's the payload? Well, that's where body comes in. So we just set body to the string or the data that is supposed to be sent with the HTTP request. The payload and POST requests always comes after the HTTP headers. We expect the strings, or we could just craft the JSON string, but it's usually better to let JavaScript create the JSON. So I'm just using JSON.stringify, and then I provide a JSON structure or an array or any other JavaScript value. Here, I'm just mimicking it and say I have the information that I would like to add something to the shopping cart, the article with the id of 42 with a quantity of 1. This will be converted into JSON and then sent alongside the request. Let's have a look. First, let's make sure that the application works again. So, how about we revert that change? So we expect JSON again. And then since we have JSON, we can use showEvents. I reload the application, and as you can see, it's not working again. And I would like to add a feature now so that clicking on this ADD TO CART button really does something. I've changed something to the exercise files and to the application here. So if I click on ADD TO CART, as you can see, nothing's happening. The number here on top doesn't increase because previously we just increased the number, but didn't store anything in the shopping cart, but the application as it is now is using a session and does store shopping cart information. But we have to add the code that runs when the user clicks on the ADD TO CART button, so let's do that right now. If we analyze the DOM, there is a small indication. We get an error message here, addToCart is not defined. Okay, supposedly the function addToCart, so maybe that's our job now. And when we have a look at that button, now when the user clicks on that button, the addToCart function is called. And it provides two attributes, the ID of the event and the quantity, which always is 1 here since we cannot provide a specific quantity. That's all we need to know, so let's implement addToCart. Let's implement the function right here. So let's addToCart, expecting the id and the quantity we would like to put into the shopping cart. We call fetch, and I've already created an endpoint in the API that both returns the shopping cart when doing HTTP GET and adds something to it when using HTTP POST, and that is the api/cart endpoint. So you already know the game. We provide a few options here. The method is obviously POST this time, and we are using headers, as you have seen on the slide, because we need to set the Content‑Type, and we set it to application/json. All right, so far, so good, but what do we use as the body? Well, we use JSON.stringify, and then we provide the structure. So we have an ID and use the value id, which is an argument to the function and also quantity. All right, that is actually quite nice, but that just sends the data to the shopping cart; however, we would also like to update our UI. In order to be able to update the UI, we need to know what's in the shopping cart, how many elements are in there? So that's why we could do the following. Once that request has been sent, we get a response, and then we have a look at that response. And here's a new piece of information. We can have a look at the HTTP status code. That's something we will cover in a bit more detail in the next clip. But basically, what I'm interested in now is if the HTTP status code is 200, which means HTTP OK, so supposedly, the request worked, then we can fetch the contents of the shopping cart and then update it appropriately. We have an API endpoint, api/cart, but this I'm using GET. And then when we get the data from it, we converted JSON into a JavaScript structure, and now we have the shopping cart basically as a structure. Of course, interaction with the HTML, and the markup, and the DOM is not something that is the focus of this course, so I've already prepared a helper function that can then update the cart as it is displayed. So I just call updateCart and submit the cart as an argument. That's all we need to do here, and that's it. We send an HTTP POST request to apt/cart, send the selected event to that API endpoint. The cart is updated, and then we fetch the shopping cart. And what this updateCart function does is it basically counts how many elements are in there and then updates the UI. Let's try this out. I'll reload the application, and then I just update a few tickets to the shopping cart, and you see that on top, the number of tickets increases whenever I click one of those buttons here. And this is how we can send HTTP POST requests to the application.
You have just seen that we check the HTTP response's status code, and I think this is a great opportunity to have a more general look at HTTP status codes. So those are those three‑digit numbers that are part of an H TTP response, and they come in a variety of types or groups. So, there are HTTP status codes that start with a 1. They are informational, so that just provides some context information, but they are rather rare, especially when talking to APIs. Most of the time, at least hopefully, we'll have an HTTP status code that starts with 2. We've already seen 200, but all of the other ones in there also signal that there has been success. There was no error. The request was properly accepted from the server, and some data is returned or a status is returned, and the status code starts with a 2. There are also HTTP status codes that start with a 3, and these are redirects. So basically, we send an HTTP request to one endpoint to one URL, and we are then redirected to a different URL. There are different types of those redirects, for instance, redirects that are permanent, so they could be cached by the client and some that are temporary, so they should not be cached, and they all start with a 3. So that's not a sign of an error, but also a sign that we haven't received the actual data we want yet. And then there are two types of error status codes or classes of error HTTP status codes. Those starting with a 4, those are client errors. So what is a typical client error? The most famous one probably is 404, which means file not found, so the URL is incorrect. Of course, it could be a server error because a file is missing there, but well, this just counts as a client error. The request wanted something that's not there. There's also HTTP 400 for instance, which is bad request, for instance, if we send an invalid parameter alongside the request. And if there are client errors, they are, of course, also server errors, and they start with a 5. I think everyone has seen this HTTP 500 error message, internal server error. So something went wrong on the server. It could be an exception to code, for instance. So these are the different types of status codes. We can access the number with the status property of the response. Some versions of HTTP also have a text representation of each status code, but working with the numbers is the safer bet.
So far, our code has been pretty optimistic. That worked, of course, in our demo scenario, but in the real world, errors may and eventually will happen, and we have to properly handle them. And of course, that's not impossible at all. It's standard practice, but I think it would be a good idea to look at what can go wrong. And in my book, there are three different error scenarios that could occur. The first is that fetch is throwing an error. So, running the fetch call generates an exception. And I think we all know what should be done here. We put the fetch call in a try catch block, and then we can properly handle the error, and then, for instance, display an error message. However, it could also be that the call itself works, but there is an error on the server, so a client error or a server error of 404 or an HTTP 500. And all of those error HTTP status codes will not lead to a client‑side exception because the call was made, and the call was properly answered. It wasn't answered with data. It was answered with an error information, but still there was a response to the HTTP request, and that's why we have to look at the status code and then handle the error because fetch won't throw any. And there's a third option that's often forgotten. It's that the data we get back could be malformed. So we could expect JSON, but we see something that is not valid JSON. So the conversion throws an error. Of course, that means our call to response.json, for instance, needs to be put in a try catch block as well. Let's implement error handling, at least some error handling in our application. And since we have already looked at the HTTP status code before, let's use that part of our implementation. The API has another secret endpoint. It's api/events‑brittle because that endpoint returns an HTTP 500 response 1 out of 4 times. So things could go wrong, and therefore, we can just show those events or jsonify the response. Instead, we just go in there. And then before we return response.json, we check the status, and if it's !==200. And I think we have an error, and I've already prepared a helper function, showError, and then we can just say Something went wrong. And that just displays that information. Of course, we could have a closer look at the status. So a 404 might need different handling than a 500, or we could have a look at the content of the response. But in general, this just shows you how this error handling can work. Here we go. I open up the Network tab. I reload the page. We see we get results. I reload the page again, a third time, and now Something went wrong. And why? Because the call to events‑brittle this time got an error back, and we see that the response status code was 500. And that's how you can basically catch those errors on the server. And it was important for me to show you that these HTTP status codes, although they clearly indicate an error do not throw clients an exception, so we have to take care of that ourselves.
When a request is long‑running, we may wish to abort it. The Fetch API does support that. There are just two additional objects we need to know because then we can implement this feature. First of all, we need a so‑called AbortController. That's the object that essentially takes care about aborting a request, but that's not enough. We also need something called a signal. Signal is a property of the AbortController, and that signal then will be used to communicate with the fetch call. So we have the AbortController, we have the fetch call, and we have the signal basically standing in between as a means of communication. And what we then do is pretty straightforward. We do our fetch call with the URL, and we also might have some properties like the HTTP method, HTTP headers, payload, etc. And we also provide the signal. So, signal on the left is the key, signal on the right is the variable we just created. Then the fetch call is running. And if it runs too long, we have the signal assigned to the request, which basically binds the controller to the request. And then at any time, we can call the abort method of the controller. And thanks to the signal being tied to the controller and the signal also being tied to the fetch call, this essentially aborts the request. Let's implement that in our application. I have changed the application a little bit in order to be able to demonstrate that feature and to put it to good use. As you can see here, the covers or the images for the events, they are gone. So far, to be honest, I've been cheating. Those covers, they did not come from the API. They were static assets of the web application. I've changed this, and now we can put the AbortController to good use. Let's update the code. First of all, we need to make sure that we're using the stable events endpoints so that we don't get that many errors. And now I'd like to implement a little bit once we get events from the API. First of all, I create a variable, controllers, where I store all the AbortControllers because I'm now loading a couple of images, and there will be an AbortController for each of those so they can abort all of these requests because maybe they take some time. I got the events, which I'm showing, and then I iterate over the events because for each event, I'll need to make sure that an image appears. How do I do that? Well, I have an extra endpoint, api/cover/, and then I just provide the ID of the event, and that returns basically the image. So far, so good. And then I get some response back, and I handled this text this time because it could be binary data since its images, but I'm actually encoding them. And then I get an image, and then I have a helper function, showImage, which basically shows an image for an event.id. And if something goes wrong, I could still log the exception. All right, so far, so good, I've already created that controllers array as well, but we are not aborting yet. Let me show you in the application. I reload, and then you see that one image appears. And well, it takes some time, but eventually they are there. I could go to the browser DevTools, and then I can activate throttling so that it's even a little bit slower. So, how about we use maybe Good 3G, or let's use Regular 4G/LTE, then it takes even a little bit longer. And I'd like to use that and use that opportunity to be able to eventually abort that loading of those images here because it just takes too long, and I can implement that in our code. Here's what I need to do. First of all, I need a new AbortController, so that controller and then new AbortController. And I am then storing that controller so that I can access its abort method later. I have the controllers array, and I just push the controller in there. And then, when doing the fetch call, I'm providing an option. I said signal to the signal property of the controller so that I can later abort it. And then, for the sake of simplicity, I'm just adding a function code, abort. And what this does is it iterates over all controllers. And for each controller, it tries to call the abort method. That's basically it. So each fetch request to a cover or image now has a signal of an AbortController. And if I run the abort function, all of those requests stop because the AbortController makes them do so. Let's reload the page. And as you see, it takes a while, so maybe let's wait until one of those images is fully loaded, and then I hit abort. And you see now that four operations were aborted. One of the images is here, and the other four, they are not there yet, and they won't appear. The one top image you saw at the beginning, that was the static template that always appears before we do the API call. So only one of those images was successfully loaded, the one for the memory allocation concept, and I've aborted all of the other four.
I would like to show you one more fetch feature that's pretty advanced, I would say, and it doesn't apply to all situations and scenarios. But if you can use it, it's actually pretty nice, and that's tracking the progress of the HTTP request or more precisely the response. And you do that by using something called ReadableStream. And sending requests to the server, you get a stream of data back. Let's just imagine that it's rather large data like the images from before. So, those are sent in chunks. And basically, you get when you read the data chunk and then another chunk as long as there's still data left. And in the end, you've read everything. And whenever you receive a chunk, you can then, for instance, update the UI and say out of those eight chunks, I have received three. And for instance, I have a progress bar. Now we have already artificially made our image loading slower than it needed to be, and so we can add some progress information to that with just a few lines of code. To make this work, there are a few changes, which I'd like to introduce. First of all, I make the forEach here or the function async. And then I will once again create the AbortController, push that into the controllers array, but then it changed the call to api/cover/id a little bit, so I directly wait for the response, so const response = await fetch, and then I do the fetch request. And that's what I need the async for because I'm now using await here. Now I got the response. And once I have the response, I create this readable stream. I need a reader. So I have a reader, and I get this by accessing the response, then its body, so the actual data being sent as part of the HTTP response, and then I can do getReader. That doesn't give me the full body, but a reader object that allows me to read chunk by chunk. Now, when I'm requesting a resource on a server, the server can send me, as a piece of information, the length of the data being sent. That's what also enables the progress bar when downloading something in your browser, and that's put in the content length HTTP header. So, we do total, so the total amount of bytes being spected, as the value in the response headers, and the header name is Content‑Length. And if we don't have that, we just assume it's 0. That's the best we can do. That's the bulk of the implementation. I'll just paste in the rest. Let's go through it bit by bit. So I work with chunks, so I define an array for that. And I'll also count how many bytes I've already received. And then I'm looping, and I'm continuously reading from the reader. I get two values back. Value is the actual chunk, and done is whether I'm at the end or not. So if I get the value back, I push that into that chunks array, and I add the length of the data to my received variable, and this allows me to calculate the progress. So its basically received divided by total, and then I just make it look nice as a percentage value. And the showProgress function here is something I added, so that that value then appears at the right place in the UI. Once we are done, we leave the while loop, and then I remove the progress bar or the progress value. And displaying in the UI, that's also a function I have already implemented. And then I take the chunks. I decode them because they are essentially byte arrays, and then I can show the image, and I can just remove the previous implementation. So, quite some code, but pretty straightforward. I calculate how much data I expect. I download the data chunk by chunk. And whenever I get a new chunk, I calc the progress and display it in the UI. I make sure that there is at least some throttling. I reload the page. And then once it starts loading those images, we do see that there is progress being displayed. And now maybe our clients are less reluctant to wait until everything has been loaded and is in place. And that's how you can track and display the progress of loading data when doing a call with the Fetch API. The Fetch API is based on promises; however, promises themselves are beyond the scope of this course. However, the Pluralsight library gots you covered, so there are several courses touching Promises, their labs, and there is at least one dedicated course on Promises and async programming. So if you need more background info on that, I just recommend that you watch that course. That will give you more background working with the fetch and other APIs.
At the end of this module, I'd like to discuss a built‑in security feature of JavaScript, not because of the security implications, but rather on potential implications for your code. That feature is called cross‑origin resource sharing and works like this. We have a client application on app.example.com sending a request to an API on a different origin. Origin is the protocol plus the domain plus the port, so they are different here. So it's a cross‑origin request. So we sent the GET request from JavaScript that only applies to JavaScript requests such as fetch requests. And of course, we have to provide the host, which is different. And what the browser now does, and it only works in a browser context that is that way, is that automatically an additional header is sent. It's called Origin, and the value is the origin. So once again, protocol, domain, and port if it's not the default port. That header is sent to the Server, and then the server, well, eventually replies with some information. Now the problem is this. By default, JavaScript cannot see that response. So the data, the payload of the HTTP response, is not accessible for JavaScript code because its a cross‑origin request that defeats a few attack vectors. Of course, cross‑origin resource sharing or that restriction here is sometimes rather cumbersome and annoying when working with APIs on different origins, but it protects the web application from other threats, so it's good that it's there. However, what if I absolutely need to access that information? Well, the client can't do anything. That origin header is sent by default, and that cannot be prevented either. But the server, the API, in our case, can green light that request. So it can say, okay, this origin is allowed to see the data, or to be more precise, the JavaScript code in that app can see the data. How does the server do that? The server has to send the Access‑Control‑Allow‑Origin HTTP header, and the value of that should include the origin of the client app. If that Access‑Control‑Allow‑Origin header is set, then the client application sees the information from the request. The request, however, is still sent because an HTTP GET request is one of those requests where we assume that the state of the application does not change, so the request can be sent. It's a little bit different, however, if you're using something like POST because a POST request would change the state of the application. So browsers do not send that POST request if it goes to a different origin and JavaScript actually started a request. However, with CORS, there's another approach here that can be used. So when sending a POST request to a different origin from JavaScript or any of those other HTTP methods that change the state of the application such as PATCH, for instance, or DELETE or PUT, the browser first sends a so‑called preflight or preflighted request. It's using the OPTIONS HTTP method and basically queries the server. Okay, here I am. I would like to send a cross‑origin request to you from JavaScript from that origin. Are you fine with that? And if the server replies with, yeah, I'm fine, and I'm telling you that I'm fine by sending the Access‑Control‑Allow‑Origin HTTP header with the calling origin as a value. And I can also say I'm fine if you're doing a cross‑origin request, and these methods are fine with the GET, POST, and OPTIONS. Then, basically, we are greenlighting that POST request. We could also say, yeah, these headers are allowed. I'm fine with Content‑Type and Cookie. Then the browser knows, okay, the server is fine with JavaScript sending a POST request. So now in the next step, the actual POST request is being sent. Without the Access‑Control‑Allow‑Origin header, the POST request would not be sent. I'm just telling you this so that you know that. And as you see, that's something that the server API needs to fix or needs to configure because client‑wise, we can't do anything. That's something the browser does, so the browser protects us. Therefore, the API needs to be compliant; however, if you see errors in your browser console that there's a cross‑origin request that could not be sent or CORS headers are missing or the Access‑Control‑Allow‑Origin header is missing, then you know what's going on. We are done with covering fetch now. So up next, we'll look at a different and dedicated library, an external dependency to send HTTP requests that's pretty popular. It's called Axios.
