Course Overview
Course Overview
I'm Peter Kellner, and in this course, you'll learn the essentials of building web apps that seamlessly exchange data between browsers and servers. Specifically, you'll learn how the React library efficiently manages those exchanges to give your browser users a great experience while at the same time giving developers awesome tools and techniques to make that happen. As the React name implies, the library is all about helping the browser react to those data changes. Specifically, the topics we'll cover include building apps that integrate with REST servers, integrating advanced HTML form data with servers, integrating concurrent Suspense into your apps, and how to embrace server components and actions for seamless JavaScript server integration. By the end of this course, you'll be able to build best‑in‑class React apps that work well with data. Before starting, you should know the basics of React and have at least built a simple React app on your own that reacts to state changes. There are many courses here at Pluralsight that can help you get to that point. Please join me in the goal of building React apps that seamlessly work with data.

Understanding the Basic Data Patterns in React
Introduction
The websites that are most often visited are based on data that is changing, sometimes fast, sometimes slow, but always changing. Whether those changes happen because of some event firing on the browser user interface, like clicks or scrolls, or based on a URL change, the end result is the browser's HTML needs to update. Sometimes events can happen in sequences, like when a user clicks a button, and then later something happens, like a rendered image changes. For those sorts of things, the transitions are often as important as the final HTML rendered when the sequence completes. That is, during the sequence, for example, should there be some kind of animation displayed indicating that the browser user should wait, these things are important, and we need a JavaScript library we can use to make those sort of things in our app easy to build. I'm Peter Kellner, and welcome to my course, Working with Data in React. Just so you know, this course was created using the following versions of React, and it's 100% applicable with this version displayed. Let's get right to work and look at a straightforward web app that works with data.

A Typical App Flow for First Render
Let's start out looking at a running React app in a browser that has data loaded from a server and also has the ability to update that same data. It's a simple speaker page for a technical conference. When the app URL first loads, it shows an animated waiting page, letting the browser user know data is loading. Once the loading completes, each speaker is rendered, which includes a hard icon rendered as either red or black, meaning favored or not favored. When clicking on a hard icon, a request is made to the server to update the favorite status of the selected speaker, causing a progress spinner to show. Then when the request is returned by the server, meaning the server processing it, the spinner icon goes away and the new status is reflected by the icon color. That's the user experience. Let's talk about how React works with the browser DOM to make that happen. This is important to understand because it directly relates to the fundamentals of how data moves between the server and a browser. Let's start out by bringing up Chrome debug tools, and specifically, let's inspect the rendered HTML on the page. This isn't view source that shows you the original downloaded HTML. This is representing what is in the browser DOM at the moment. Let's go through the same scenario we just did with the speakers loading and the favorite icon toggling, but this time slowly while talking through how this is all controlled by our React app. Okay, first, refreshing the browser. What our React app has done after its initial render is it sent a request to the server to get a list of speakers. That's the first event the browser executed. By default, the first render of this React app always sends the HTML you see here. That includes div tags that are assigned classes, like speaker‑favorite‑placeholder. That just represents CSS to show animated images, as you can see showing in our browser. Then when our React app gets notified that the request for speakers has completed, it takes those newly downloaded speaker records and figures out just what HTML on the page needs to be updated. Following that, the React app does what is referred to as reconciliation, which means the app figures out what HTML on the page needs to be replaced and then it replaces it. You may have missed the HTML changing a moment ago, so let's do a little video magic here and I'll show you by going back and forth the before and the after of the HTML rendering. Notice how the placeholder divs are being replaced by the actual image of each speaker. This is a very typical pattern that most React apps follow when first rendering a page with data.

A Typical App Flow UI Interaction
After the page is fully rendered, let's now look at what goes on when the user clicks on a heart favorite icon. First, though, in our debug tools, let's drill down into the img tag that renders that icon. Looking on the right under the Event Listeners tab, let's find the click event. Notice assigned to it is React code to process it. That code is how our React app gets notified that the user clicked the image. I'll click it now, which kicks off the process of toggling the icon. This means our user interface needs to show an in‑progress message, which in our case is an image of a spinning icon. If you didn't quite notice the HTML changing, let me do that again with our video magic. You can see the source changing. One thing to note is even though the icon is spinning, it's really just rendering an image. If the server fell into the ocean at this point, the icon would spin forever. Our app is just now waiting for the server to return a result. When that result does finally arrive, our React app processes that completion event, and it changes the image tag to show the new heart icon color. A little more video magic, and you can see the img src tag reflecting the updated heart icon. So, why did I go painfully through all this? The reason is for the rest of this course, we are essentially going to learn how to manage browsers showing HTML based on events being fired someplace. As I said earlier, there are two fundamental things that can cause events. The first is when an event is fired from the browser's UI, like a button click or a scroll event, and the second is when an external resource, like a server, triggers something like a completion event, and that can cause the HTML to change. In typical web apps, there's a lot of events happening all the time. Keeping the user engaged by showing proper waiting messages, and then when the wait is over, updating the HTML correctly can be a real challenge. React primarily handles this for us, but as developers, we need to understand the API available to us, that's the React library, and how to program it efficiently so that the user has a great experience, and certainly so that us developers can write clean, understandable, and maintainable code. Previous to React introducing concurrent rendering features, like Suspense, React Server Components and Server Actions, the only way to manage events firing was to programmatically update local component state in your apps. Those state changes would cause React to, well, react, and update different parts of the browser. The concurrent rendering features just give us another way to basically do the same thing as we previously did with local component state. In this course, you'll learn all about building apps with those concurrent rendering features. Coming up, we'll look at the actual React code that renders this conference speaker page. First, a version that uses local component state and a REST server, and then second, the exact same functionality, but with no REST server and completely built with Suspense, React Components, and Server Actions.

Using Component State to Handle Data Changes
My expectation for this very first module with code is that you will just follow along. If you're comfortable with downloading the source, which is in the GitHub repo at the URL below, and navigate to the folder m2/demo‑app, all you have to do, assuming you have the proper version of node installed, is open a terminal prompt in that folder, enter npm install, then npm run dev, and the app should come up at localhost 3000. Let's do a quick review of the code in the folder /src/app/demlLoadingState. The app starts here in the page.jsx component that in turn renders a speaker‑list component. Speaker‑list maintains two states; loading, which tracks the state of the UI, meaning whether the UI should show animated placeholders while the data is loading, speakers is just the array of speakers that renders after the loading completes. The function passed to useEffect is what causes the local state changes. It runs only once after the component renders, issues a GET request to the REST API to get the list of speakers, and when that request completes, it loads the returned speakers into the speaker's array state and also sets the loading state to false. In the render section, it checks that loading state, and if that component state is loading, meaning true, then it renders three components that include special CSS that show the animated placeholders while the speakers finish downloading. Inside of speaker‑detail, which is basically the card component that renders for each speaker, one instance of the component SpeakerFavorite is rendered. Let's look at that component. Notice it has its own two local component states. One is speakerLocal that initializes to the receiving prop speaker, and the other is updating, which basically tracks the point at which the user clicks on the hard icon till the update of the server data is complete. Notice here in the toggleFavorite function, setUpdating is set to true, the updatedSpeaker record is composed based on the current local speaker state, and a toggled value of the favorite property. Next, a PUT request is made to the REST server, and when that completes, the local speaker state is updated, and then finally, the updating status is set to false so that the spinner can be removed. Looking at the render, it's quite simple. Just a turnery expression that revolves around updating. If updating is true, the spinning icon shows, if not, then the proper heart icon shows either red or black, and the image element itself has an on‑click event that calls the toggleFavorite function we just looked at. All very straightforward, but I'm sure you can imagine in a much larger app keeping track of all the component state updates can get pretty tricky. Race conditions can happen, and not only that, this kind of code can be hard to maintain.

Using Suspense and Server Components for Loading Data
Let's take a look now at the same functionality we had before, but this time using the concurrent rendering features of React, Suspense, and server components, and also let's use server actions. This code is in the sister folder to the one we just looked at, and it's named demoSuspense. Like before, the root component is in page.jsx. But this time notice that there is not a string at the top saying use client, meaning that the way the next JS build system is configured, by default, root components are server components. Just a little side note here, this code is 100% production quality, even though some of the React features I'm showing are currently listed as canary, or experimental, in the React docs. The React team makes it clear that framework vendors, like Next.js, can take these canary, or experimental, features and release them as production. So that's what we've got here, Next.js production. I did expect that you would know about local component state we used in the previous demo, but I'd be very surprised if you'd used Suspense, server components, and server actions before. That means that the code I'm about to show you is going to look pretty foreign. Don't worry, though; I promise if you make it to the end of this course and you come back here and look at this code, it will look trivial. Let me give a short explanation of the code anyhow. And again, please don't worry if you don't follow. Everything here will be taught later in the course in much more detailed examples. Okay, so page.jsx immediately looks different. It's not just a springboard page to speaker‑list. Looking at the default exported component page, what's different about this is that surrounding the speaker‑list component, we have a Suspense element with a fallback. What this means is that if any of the children elements of Suspense do asynchronous requests, like fetch calls, for example, in a certain manner, and yes, I know that's vague, sorry, and that request has not completed, then render the component assigned to the fallback attribute of the Suspense component. Notice that fallback component, SpeakerListLoading, is right here, and it's exactly the same code as we had in the previous demo that you state, but this time there is no state to track or be concerned about. You can think of this code as purely declarative in that there is no procedural code like checking for an if loading state. Let's head over to speaker‑list and see how that changed with Suspense. Again, because we have no use client string at the top of this component, it's by default, also a React server component. Notice it's declared async, and also notice the first line of executable code just below the function declaration. That's a call to read data, which essentially reads the list of speakers directly from our file system in a filename data.json. That works because we're running on the node server directly. Previously, our REST server did that exact same thing when we called the URL localhost 3000/api/speakers because the REST server was also running on the node server. Now, we can do exactly what that REST server did, but directly in our React server component. Notice we didn't do anything to track the loading state. The call to read data will only ever continue when the data has been retrieved. We can count on that. If that data has not been retrieved, the Suspense fallback component will be rendered instead.

Server Action Replacing REST PUT Call
So far, we've used a React server component to replace the REST GET call that loaded our speakers into our speaker's list. Let's now replace our REST PUT call that we used to update a speaker record with a call to a server action. We're here in our speaker‑favorite component. Remember, this is the one that has two separate local component states, one for the local speaker, and the other when speakerLocal is updating. We still have to have those, as I don't see an easy way to do the same thing with Suspense. That is, after the speaker record updates, we want the UI to change to reflect the new values. Local component state still is a good way to do that. Notice now we have a call to a function named speakerAction that we are using to update the actual speaker data. Previously, we had a REST call using the PUT method to do the same thing. SpeakerAction is imported from a file named speaker‑action.jsx in our current directory. Let's navigate there and review the code. So we can easily see it all, let's collapse the default data, which is what gets loaded if there is no data yet persisted on the server. On top, there is a single line of code saying use server. This signals React that if we're calling from a client component, that this is a transition to the node server from a browser client. The rest of the code is no different than if we wrote a function on node. The only real important thing to keep in mind is that parameters passed in to server actions must be serializable, meaning mostly JavaScript primitives and simple objects. Also the same for the return. Now we have completely eliminated the need for a REST server when it comes to both loading and updating server data.

What’s Coming in This Course
So here's the plan for this course. We'll start learning all about how to build a React app that only uses local component state to drive changes in what's rendered to the browser. If you are going to be building apps in React, you need to understand how state changes are a critical part of handling data no matter where it comes from. We'll focus on a purely client‑side React app, usually referred to as a single page app, or SPA. We'll then take what we've learned and move on to some real‑world scenarios that include how to communicate data throughout your React app, which often involves using React Context. As part of this learning experience, we'll take a deep dive into processing data through HTML forms, which is often underused in apps. Moving on from there, you'll learn all about React's concurrent rendering feature, Suspense, and how that works with remote data. Specifically, you'll learn how Suspense without using React component state can cause browser HTML updates that are incredibly efficient in terms of browser performance, as well as friendly to both the browser user and us developers. That is, the browser user gets a great UI experience, and us developers can easily build apps that process data without getting into problems that often occur in complex apps that have a lot of different state to track. You'll learn what I mean by that, and I promise it'll be worth your time. More advanced data processing scenarios will follow using what you will have learned in the course, and that includes things like how to handle CRUD operations that involve your UI, meaning Create, Read, Update, and Deleting of server data. Then for the final modules of this course, you'll learn how your browser JavaScript can communicate directly with the node server using the concurrent rendering features, React Server Component and React Server Actions. If you are fortunate enough to be using node as your server, you'll learn how you can seamlessly build your apps that communicate with node directly through JavaScript. In other words, your React components running in your browser will be able to call JavaScript functions running in your server. Those server functions will have direct access to things like databases. In addition, you'll learn how in your apps you can completely replace the function of REST servers by using server components and actions together. That has the potential to remove a lot of complexity, as well as code in your apps.

A Word About What Is React and What Is Next.js
To be completely clear, Next.js is an awesome React framework highly recommended by the React team at Meta that provides a very important build step when creating your React apps. At its heart, it is a JavaScript bundler that brings together all the React components into a single runtime that you can deploy to a server. In addition, it does include a lot of features that you can optionally use. Those features include things like routing, image processing, caching service, and much more. In this course, I will be strictly focusing on teaching React and not Next.js. Things like Suspense, React Server Components, React Server Actions are all things that are coming purely out of the React team and not Next.js. In many cases, the Next.js framework is the first to include those features, which is exactly why we are using them, though it does introduce some confusion with some people thinking those features are from Next and not React. The only thing you'll see in this course that is Next.js‑specific is routing. I only used a very basic routing functionality built into Next.js, and that's simply for mapping URLs to root components. Everything else in the course is purely React. Feel free to post any questions here about this, or anything else for that matter, or contact me directly at my blog, peterkellner.net/contact, and I'll be happy to clarify any details that might be confusing. Let's get started now with learning all about working with React and data.

Working with Data in Pure Client (SPA) React Apps
Introduction
SPA, or single page apps, have been the go‑to way to build high quality data‑driven UI‑intensive apps for many years. That's not changing anytime soon. What is changing is what I call the hybridization, or mixing of work that's done on the server with traditional SPA apps. That is, in React specifically, with the addition of Server Components and Server Actions, taking advantage of running JavaScript in a node server has become the best way to build highly‑performant web apps. Before moving forward with that combination, it's critical to have a strong foundational understanding of data‑driven apps built purely as SPAs, that is, apps that run 100% in the browser client, and that's what we are covering coming up now. So far, we've only talked about history and theory when it comes to actually building apps with data. Typically, that data is in resources either directly on your server or possibly very far away. What's common, though, among them all is that wherever your data is coming from, it arrives with some delay, and we have to deal with that. We can't just open a data source in JavaScript and start reading from it. With some of the newer programming paradigms like, async/await and some streaming protocols, it feels though like we are just opening data and reading it, but unfortunately, that happening is not yet invisible to us. That does mean we have to deal with the delay in our UI one way or another. Our plan for this module is to go over the different data scenarios of data access you'll likely run into when building React apps using data sources from servers, both far away and close. We will need sample data to work with that's similar to the kind of data you will run into when building your own React apps. I've chosen for this course that the data source is SQLite running on a server, and to make things easier for us in JavaScript, we'll use the Prisma ORM, object‑relational mapper. Keep in mind that any JavaScript we write that accesses Prisma, and therefore, SQLite, must run on a server. That is, any JavaScript code we have running in our browser has no direct access to the server and its SQLite database. So how can our React app's JavaScript running inside a user's browser access the SQL data? Somehow we need to have a bridge of sorts that allows us to get a hold of that data. There are several technologies out there we can use for this. Those include implementing the REST protocol on the node server that knows how to both read and write data to our database, as well as implement the GET, PUT, POST, and DELETE protocol verbs. Much more on that coming up shortly. Other technologies that can be used to shuttle data requests include GraphQL, gRPC, XML, WebSockets, and others. In our case, when we need to move data from browser‑based JavaScript to a node server, we'll be doing all our demos in REST. However, keep in mind that built into React Server Components and Server Actions is a protocol that safely moves data between our user's browser and the node server hosting our app. Again, much more on that later in this course. As far as I'm concerned, much of that is now the secret sauce that makes building React apps to consume data totally awesome. I don't want to get bogged down in the details of either setting up or running SQLite, as well as the details around using Prisma, but there is some minimal amount of setup and installation needed so that as you learn these different data access patterns in React, we have real‑world type data to access. Coming up in the next few clips, bear with me as we go through the basic installs and setup to make this data work. And then I promise we'll move on to the good stuff, and that is actually working with the data from our server, in our case, a node server.

All Demos in GitHub Repository
Just like my other courses here in Pluralsight, all the source that I develop throughout each course is available for you to download on GitHub. For this particular course, you'll find the repo at the URL github.com/pkellner/pluralsight‑react‑working‑with‑data separated by dashes. In the README file, which is what's shown when you navigate to the repo, are all the directions needed to get started using these examples. Basically, all the steps I'll be going through now. The organization of the folders in this repo is that for each course module, there is a base folder, and inside that folder for every clip in the course that has changing code, there's a folder with the clip number associated with it. As an example, the code for the module 3, clip 3 can be found in the folder m3/clip‑030. For those of you that want to code along with me, I'll try to make sure that I give enough explanation so that as long as you have downloaded this GitHub repo and you have access to it, you should have little problems. There are other times where I'm going to explicitly bring in built‑in code just to save time. Again, that code will come from this repo. My goal is to maximize the amount of time we spend learning new things. Let's move on now and get started with our React project.

Scaffolding the React App with Next.js
As I'm sure you know, there are many ways to create a React app and have it served to our browser. Like my other courses, we are using the open source project Next.js as our React build system. That's because, among other reasons, it's really the only build system out there for React that supports the latest React concurrent features, like Suspense, for example, that you're going to learn all about in this course. Let's head over to the Next.js website and specifically let's navigate to the docs page. That has a lot of details about getting started with Next.js and React, but let's specifically look at the Installation section. It tells us what the steps are to create a new Next app. It says you need at least Node.js 18, or at least at the moment, and then it gives us the npx command we can use to create a new React project. It suggests npx create‑next‑app@latest, which automatically installs the packages React, react‑dom, and next to the version of whatever the latest production release is. That's what we're going to use to build our project here. Next, it shows all the prompts that are going to come up, and we're basically going to take the defaults, but let's go through a couple of the details. The most important question, "Would you like to use the App Router? (recommended), make sure to answer with Yes. If you've used Next.js prior to React 18, you will have been using the page's router, which we're not going to go into details of. But for the purpose of this course, we are going to use the new and latest Next.js app router throughout. The other question to talk about, "Would you like to use TypeScript?", I'm going to say Yes, though I know that all of you don't use TypeScript and for that, I apologize, but I will try to make it up to you by using absolutely as little TypeScript as I can throughout this course. TypeScript can do an amazing amount of type checking without ever having to mention a type. That is, it picks up library defaults, it picks up your variable defaults, and warns you when you are doing things that might cause problems. Personally, I do use TypeScript in all my projects and I recommend it, but I get it's not for everyone. Okay, let's open a terminal prompt inside an empty folder. In my case, it's going to be in the course GitHub repo folder /m2. Let's enter the command they suggest, npx create‑next‑app@latest, and for the prompted project name, let's name it, clip‑03, which it will automatically create a folder with that name in our m2 folder we're in. As we discussed, take all the defaults, making sure to answer use App Router as Yes and use TypeScript as Yes. Now we've done everything necessary so that we can open our app in Visual Studio Code and start working.

Launching the React App with Next.js and VS Code
Now that we have our project created in Next.js, let's open it with Visual Studio Code. I've done that here, and you can see the project viewer on the left side with the React app we just created. At this point, I don't actually have to run npm install because create‑next‑app did that for me, but I like to do it anyway, just to be sure. So let's open a terminal prompt, and at that prompt type npm install. That essentially just reads our package.json file and then imports all those packages into our node modules folder, which in this case has already been created for us. To launch our React project, all we have to do is type npm run dev at the terminal prompt, opening a browser at port 3000, and we have the default Next.js app ready to go. Moving on, the next thing is to clear out all the junk, junk to us anyhow, that Next created for us that we don't need so we can start with a clean empty website project. Dump the files in the public folder, that's the static files that get rendered from the web root, and then in the src/app folder, get rid of all the files with the exception of page.tsx. Notice, though, that Next.js automatically created for us a new layout.tsx file, as that's required. Then open page.tsx and you can see there's a lot of rendering that's mostly just promotion for Next.js features. Let's replace it all with a very simple React component that for now just renders Hello from Pluralsight. Refreshing our browser, and now we have a much simpler starting page. Before closing this clip, though, I feel the need to warn you about a problem when building WebPack type apps like this that depend on NPM packages. Looking at our package.json file, notice the versions of React in Next.js that got installed. Notice that React and React DOM are just version 18, and there's not a minor version or .version associated with it. That means that if React were to update from, say, 18.2 to 18.3, the next time you run npm install, the 18.2 version will automatically be replaced with 18.3. In general, there's no reason to run npm install, but sometimes you move to a different folder or a different computer and you make it a big surprise. In general, though, the React team is pretty good at keeping the updates from breaking previously working features, but we all know that bad things can happen when versions of software quietly roll without us knowing. For that reason, you might want to pin your versions, which means doing something like replacing the lines, React and React DOM, explicitly with version 18.0.2. That way you are more safe from surprise version roles. Personally, I wouldn't recommend worrying about this for doing course work, but I absolutely would never release to production software with a package.json like this. I'd always specified the exact version, and then when I choose to update to the new version, I'd explicitly do that, but only after testing. I don't mean to be negative, but when you've worked with these kinds of projects long enough, you learn to be extra cautious.

A Big Gotcha with the App Router in Next.js
We're almost ready to move on from the Next.js build system to talking about the React app itself. The component that is in the file /src/app/page.tsx, that also has the attribute export default is that component. As a side note, if we were to create in /src/app a folder named speakers, and then in that folder put a new file, page.tsx, then the folder default exported from there would be rendered from the route localhost:3000/speakers, whereas our /src/app file is rendered as the root of our web app at just localhost:3000. There is a lot more to routing with Next.js, but that covers a lot of the basics of what you need to know for this course, React in data. So here's the next important thing. I have to tell you about page.tsx, which throws a lot of learners off. Let's say you are new to Next.js. You've just created your first app that says Hello from Pluralsight, and now you want to test your ability to add a button that when clicked increments a counter. Let's code that really quickly. We just add an import for useState at the top, create a value in a setter for a state value count, initializing it to 100, and then update the render section to include a button that increments and displays that counter. You'd think this should work, but when we refresh our browser, up comes an error. That error is pointing at our declaration of useState, and it says you're importing a component that needs useState. It only works in a client component, but none of its parents are marked with useClient, so they're Server Components by default. If you've not yet learned what React Server Components are, which is totally reasonable as they are quite new and not widely used, you might be pretty annoyed that such a simple component did not work. Lucky, though, assuming you are in the group that has not used server components yet, you are covered in this course. I do promise later, though, I'll give you enough background to use Server Components well, and for now an easy way to avoid having to know anything about them. First, as I just said, in a Next.js app, every page.tsx that's in a folder below /src/app represents a component that's rendered at the route which includes the name of that folder. What I didn't mention is that by default, that's a Server Component. Server Components basically are just React components that are executed inside a node server, and essentially, though, not quite right, their HTML is rendered down to the user's browser. What is not happening in Server Components is any hydration step, which if you're familiar with, any server rendering technology app means there are no events available on that HTML. In plain talk, that means there's no way to code a click event on a button rendered from a Server Component, and that also means there's no way to store state in that component. Hence, the error we got. The easy way to work around this is to just add a single line to the top of this file, and that's 'use client.'. That essentially makes this component a client component and it will work exactly as you expect. Our page will render with a button, and the state will handle the clicks properly so that as we click the button, it increments by one. That's exactly what we wanted. For the rest of this module, we are now going to build 100% client‑based React app that has no dependency on Next.js. As the course progresses, we'll get more into server components. They are new, but definitely production‑ready, and I'm very excited to teach you how you can use them to really improve your apps that work with data.

Rendering a Static List of Attendees with Loading State
Now that we have a simple website responding at its base URL with a component, let's add another, but this time, let's put it in its own route and have it render some real async data. Specifically, let it render a few speakers from the conference website we will ultimately build out through this course. Let's add a new folder in a new file to our web project, /app/speakers/page.tsx, which effectively means that any component we add here in default export will render when a GET request is sent to the URL localhost:3000/speakers. Let's start off by creating a hard‑coded array of three speakers with some attributes including their name, company, Twitter handle, bio, and time of their presentation. Keep in mind that whenever referencing dates in an app where we plan on storing and then displaying dates, it's best to store them in Greenwich Mean Time. That means that time is set according to the clock at the Royal Observatory in Greenwich, London. It's usually just referred to as GMT. The reason storing dates in GMT is important is it eliminates vagueness. For a conference web app like this, it's completely possible that a website might show the date and time of the speaker's presentation in the time zone of the conference itself, or it might show it based on the browser's user's time zone, especially if the conference is live streamed. Storing the time as GMT makes it easy for us developers to know what the actual time is for the presentation. Then we can show what we want according to the UI. For this app, since conferences are only in the current time period, I've used January 1st, 1970 at 12:00 a.m. to mean no time speaking has been set. This actually is a special date that is known as the Unix epoch, and is often used as the basis for storing dates. Any time after that in Unix epoch time can be thought of as the number of seconds since then. Since it is in GMT, it's an absolute time independent of time zone. Okay, so let's code the simplest possible component that renders this array of speakers. That includes a basic UL and some LIs for each speaker. Entering localhost:3000/speakers into our browser's URL line, we get our simple list. As this course is about React in data, and though this example isn't very interesting, we have now implemented React with data. Moving on, let's simulate this data as if it were coming from a remote location by just adding a time delay after the component first renders and before the data is ready for display. To do that, we need to add a side effect to our component. What does that actually mean? Well, the component as is renders a list of three speakers, and no matter how many times it has to re‑render, the list will never change. If a component has a side effect, that means it can change. In our case, we want that side effect to be that after the component renders we launch some async event that does something like fetching data, and then when the data fetch completes, the component renders with the new data. The side effect changed the data displayed. For now, let's add a side effect in a very simple way. We need two React hooks to do this, so let's import those, useEffect and useState. Then in the component itself, call useEffect, passing it as the first parameter, a function that by definition runs after the component first renders. Let's start out this component by defining a sleep function that will delay for a certain amount of time. Then let's add some local component state to our component with useState, that initializes to an empty array, and then in useEffect delay for 3 seconds with the await call, and then set our local component state to speakers. Notice the squiggly line showing that speakers is not of the correct type. Let's fix that by adding the TypeScript generic type any, and we'll come back and fix that later. Lastly, in the render section of our code, we need to render the local component state speakerList instead of the static array speakers. Notice that I used an async function here, which allowed me to use the nice async await syntax. The reason I do this is because the function passed into useEffect cannot handle return promises without doing this. The second parameter to useEffect is the dependency array, which we're going to set to an empty array, meaning we only want this component to render once. Trying out our code by refreshing the browser, notice we have the same issue we had in our URL's root component complaining about useState and this being a server component. Just like then, we need to add use client to the top, and now we can refresh our browser again. We have our 3‑second delay when nothing is displayed, that's our empty array rendering, and then comes up our 3 speakers, as expected.

Streamlining Style and Component Design in React
Our speaker list I have to admit is pretty boring. Let's add some styling to it while at the same time creating a separate component that communicates with our main component using a passed‑in prop. First thing, let's bring in the styling library Bootstrap. We do that by bringing up a terminal prompt and entering the command npm install bootstrap. After it completes, let's bring in a bunch of assets for our site, including things like logos and speaker images by dragging them in from the outside. To start, let's drag some assets into our public folder, which, in Next.js, is where assets are rendered from as if they are in the root of the website. This is kind of like the wwwroot of Next.js. Then, do the same thing for our own styles and other CSS libraries. Let's drag in a new styles folder that we can import into our React app. Notice it includes fontawesome and a roboto font, in addition to site.css, which mostly contains our Bootstrap customizations. To make these styles apply to all our components, let's go to our Next.js‑specific file. /src/app/layout.tsx, which is the layout applied to all our app components under the folder /src/app. In layout at the top, first import React, then Bootstrap, then our custom site.css, followed by fontawesome and our roboto font. Now we are ready to start adding styles to our app components. Actually, just component for now, page.tsx. So let's navigate there. As currently we are just using the default CSS for lists, that's ul and li, let's change that to divs and use Bootstrap's container and row class instead. For the actual speaker detail itself, let's render a SpeakerDetail component that we'll write momentarily. Have it just pass in a single attribute, speaker, and, of course, the key, which is for React's rendering purposes. Let's create that component alongside our page.tsx file, naming its speaker detail, and then just scaffold out a simple component with Bootstrap styling that includes a nice card layout. Notice that we have typed the receiving prop speaker as TypeScript type any, meaning no type checking. We'll fix that coming up shortly. Rather than code all the details of the card here, let me paste in some completed JSX that renders the speaker's image, their name, and other details. The only thing here a little unusual is that we are picking up speaker images from our /public/images folder. In that folder, we just have the speaker images associated with the speakers we have in this demo. Because of that, it's completely possible we have a broken speaker image. The easiest way to deal with that is to add an onError attribute to the image that defines an image handler when there is an error. Let's add that and call it handleImageError, and then just code it above. Notice I just default to a known dummy speaker image if there is an error. And again, notice the any type, which, again, we'll fix shortly. Scrolling up and down through this component, nothing really related to React data besides a bunch of formatting of our speaker object with Bootstrap. Let's go back to our page.tsx, import SpeakerDetail at the top, and we should have a nicely rendered speakers page. Let's see. Refreshing our browser. Sure enough, looks pretty good.

A Brief Review of TypeScript
Going forward as our apps get a little more complex, having some typing information available to us is going to make them easier to understand, as well as help to avoid coding errors if you choose to code along with me. TypeScript is a statically typed superset of JavaScript, providing us with a power of types. A well‑typed codebase can help catch errors before they happen, making your code safer and more predictable. We'll focus on the aspects of TypeScript that bring the most immediate benefits, things like basic types, interfaces, and function annotations. By using TypeScript in our course, our goal is to have less mistakes and misunderstandings while keeping the learning curve easy. Take note, though, that TypeScript is a large language with many advanced features, and we won't cover most of them. The goal is to provide you with a solid foundation so that you can understand the code in this course and have a starting point if you choose to do further exploration of TypeScript. Once you understand the basics, you'll be able to leverage TypeScript's power in this course and in your future projects. Let's go through a couple of examples of TypeScript and how it helps. Say you have a declaration like this in plain old JavaScript, let i = 100. Then you were to have i = abcd in quotes. Inside JavaScript, i would just switch from being a number to being a string. If you were using TypeScript, then you would actually get an error because TypeScript inferred that i is a number when you set it to 100, then when you later tried to set i to abcd, TypeScript would complain. Since TypeScript is a static type checker, it does not have any influence over what happens when the code runs. That code with i = the string abcd would still work. The idea behind TypeScript is that assigning a string to a number variable might lead to problems, and more than likely, you didn't mean to do that. TypeScript is trying to help. I suppose I can see the argument why some people don't like TypeScript considering that there is nothing wrong with changing types dynamically like this. To me, though, I like the type checking. Let me talk about two other features of using TypeScript. The first is for objects. Let's say we have a speaker object defined as follows. Const speaker =, and then we have a bunch of properties. If we were to create a new speaker name const like this, const name =, and then a string that just renders first and last name, both JavaScript and TypeScript would be good with it. However, if we misspelled last name like this, then TypeScript would complain, TypeScript inferred the type from your speaker declaration. You can, however, be more specific by explicitly declaring a type for speaker. That might look like this. Then you could associate our new speaker type with our speaker instance just by adding the type after the colon. What this implies is that when we created a new speaker in the initialization, if we misspelled a property name, TypeScript would complain. The final thing to talk about in TypeScript is declaring generic function types. So here's what it looks like to create a function that has a generic type. If the generic type is string, you'd call it like this, or if it were a number, you'd call it a little bit differently, as shown here. The function declaration would cover both cases. Next, let's fix the app that we've built so far, replacing the any declarations with the proper typing in our app.

Adding Proper TypeScript Typing to the React App
If you remember, I dropped a couple any types into the very limited app that we've built so far that just renders a few speakers. As I said earlier, by using the any type, you are telling TypeScript you know what you are doing and it should ignore all type checks. It's no different than not using TypeScript at all. Let's now update our app and replace those any types with reasonable TypeScript types. Let's start with the /src/app/speakers/page,tsx file that helps the component render when the user browses to localhost 3000/speakers. Let's fix the call to useState. This is the generic function definition we talked about. In this case, it's a great example for it because when we create local component state, it will help us to be able to declare what type that state is. Then later, when we either do operations on the state or call the state setter, TypeScript will help us to make sure we are using the correct type. As in a side note, one big reason this is so helpful in programming JavaScript is that probably the biggest creator of bugs is type coercion, meaning that JavaScript will attempt to use the right type for you when you mix types. Like, for example, things like the expression 1 === "1" will return false while 1 == "1" will return true. It's always best practice to do comparisons of the same type. TypeScript helps us to follow this best practice by enforcing type checking. Okay, so in this case, our state is an array of speakers. We could do something like replace that any with an empty array, meaning our state is going to be of type array, but we can do better. Let's start out by creating a new TypeScript type named Speaker and then set all its properties. To our existing speakers assignment, make that type array of speakers. Notice immediately the property we assign to each speaker, userBioShort, is showing an error. Looking back at our type, turns out we misspelled it, leaving the r of user out. Fixing that, our error in our speaker array goes away, already a small savings from using TypeScript. Let's also update our useState hook call from using type any to an array of speakers. We know we are going to want to use this speaker type in multiple components in our app, so let's copy this interface, create a new file in a new folder, /store/app/lib, and name it general‑types.ts. Paste it in and add the export keyword, so we can import it back into our component. For now, this only has the one exported type, Speaker, but you can be sure that going forward in this course, we'll add other shared types here also. Back to page.tsx, and import this new file at the top. We have one more use of any in this component, and that's in the render section where we map over our speakerList, so let's update it also to Speaker. Notice now if we were to assign our key to speaker.speakerId, we'd get a TypeScript error, meaning our type checking is working as expected. Heading over to the speaker‑detail component, let's fix that, too. Notice we've defined our props coming into this component as type any. Let's fix that by first creating a new type, SpeakerDetail Props, and since we are only expecting one receiving prop, let's add that to this type, and then, of course, import type Speaker at the top and change our type any to type SpeakerDetailProps. Notice I use the keyword type instead of interface, like I used before in the definition of speaker. Basically, type and interface mean the same thing, but there are subtle differences, like the keyword interface you can extend, type you can't. It's common when declaring the type of receiving props in a React component to just declare the type in line. Let's update our code to do that, and going forward. In this course, you'll see that's the pattern I always follow. The last any to update in this component is the one assigned to our handleImageError function. This one is a little bit more tricky. Let's declare our own custom interface for this and have it extend the React built‑in type SyntheticEvent. Since it's a generic function, assign at the type HTMLImageElement. Then we can add the property target to it, which is what we use to set the source attribute of target. And because of that, import React at the top. Lastly, update the type itself to this new interface type. Notice now if we were to mistype target, we'd get an error, or mistype source, same thing. In my opinion, this is a good case to just use any and skip the TypeScript typing. If you're really proficient at TypeScript, you'll figure this type out, but otherwise, you'll spend a lot of time on it and not likely ever get that time back. Just my two cents, and it's certainly up to you. We've now fully typed our two React components, page and SpeakerDetail.

Adding Data Persistence with SQLite and Prisma
Remembering back a little bit, we simulated a delay in getting data into our React app by initializing some local component state to an empty array, then after 3 seconds, by way of the useEffect hook, we set that component's local state to a static array of three speakers. That caused the component to re‑render and the speakers to display. But now let's take this one step further, and instead of simulating getting data from an external async source, let's actually get that data from a database. Specifically, let's add to our current React Next.js project, both the SQLite database, as well as the Prisma object‑relational mapper. For the purpose of this course, you don't need to know much about SQLite or Prisma, but you will need to get both of them working to continue forward, assuming you are coding along with me. I've put together a very streamlined way to add these two to your project, as well as included a way to reset things if the configuration goes wrong. These type setups are often error‑prone, as everyone's computers are just a little bit different. Sometimes dependencies change over time, and just in general, there will now be a lot of moving parts. If you have any issues, please reach out to me either in the discussion section here in this course, or contact me on my blog at peterkellner.net/contact. I'll do my best to help out when I can. I get how frustrating it can be sometimes when things don't go as expected. So here are the straightforward steps to make this install happen. Start out by bringing up a terminal prompt again. Then type npm install typescript ts‑node @types/node ‑‑save‑dev. Then after that, npm install prisma ‑‑save‑dev. And lastly for now, npx prisma init ‑‑datasource‑provider sqlite. Now, in our project, we have a folder created called Prisma and a file in it, schema.prisma. Let's open that file and make a couple changes. First, the URL is currently assigned with an environmental variable, but since this is a demo project and we're always going to have the SQLite database in the same place, let's just hard‑code that to file:./dev.db, which will put our database file directly in our project. This file is also where we put all our models. So let me just paste those in, and these are the models that we're going to work with for the rest of the course. There's essentially five models here. Once this is done, we can go back to our terminal prompt and continue the setup. One small side note, if you want to install the Prisma extension, you can go to the extensions panel, search for Prisma, install it, and then when you come back, you have nice syntax highlighting for your schema.prisma file. Let's now go back to our terminal prompt and continue installing. The next thing is to type npx prisma generate. That creates all our JavaScript client code that's going to access the SQLite database. And then finally, npx prisma migrate dev ‑‑name init. This is the step that actually creates the tables inside our SQLite database. So if we want to see what those tables actually look like in the database, there's an easy way to do that by installing in VS Code the SQLite data plugin named SQLite. Let's install that. In order to activate it, we need to go to the Settings, Command Palette, and choose SQLite: Open Database. It will prompt us automatically for our file, which is in the folder Prisma, and its name is dev.db. Now, if we collapse our files in the explorer and open the SQLite Explorer, we'll see our database tables, including Session, Speaker, SpeakerSession, and others. Clicking on them, you can see the columns of the tables, and then also clicking on the arrow you can see the data, which at this point we don't have any data in any of our tables.

Seeding SQLite with Data
For development, when working with data, it's always extra work to have consistent sample data available in the app we are building. That is, as we build functionality, we are constantly modifying the persistent data in testing, and usually we want to reset that data back to a known state. Prisma gives us a clean way to include seeding functionality in our app such that with a simple npm run command, we can easily populate our tables with data. Typically, I like to have those seeding methods start by removing all the existing data so we can easily execute our seeding over and over with no errors. Since we will need some actual data, I've created a JSON file that includes several of our actual speakers from an event I organized in 2019 named Silicon Valley Code Camp. It also includes sessions from those speakers, as well as a list of about 500 randomly generated attendee names and emails, as well as some random data associating those attendees with their favorite speakers. Let's head back over to Visual Studio Code now and create a new folder to hold our seeding code and data, naming it /src/lib/prisma. Into it drag a file named db.json that includes all our sample data. Next, let's create a TypeScript file in that same folder and name it seed.ts, and let's put some code in it that will read from the db.json file and populate all the SQLite tables we just created. To execute the code in this file, we can type ts‑node src/lib/prisma/seed.ts. When it completes, you'll get a successful message. Looking now again at our SQLite Explorer, choose a table, I'll choose Speaker, click the right arrow to the right of that table, and you can see our populated list of eight speakers. Click on Attendees, and we see all the attendee data there. Just in a side note about this particular data, you may have noticed that for speakers, I'm using as my primary key a number, and for attendees, a unique identifier string, also known as a GUID. Should I have used the same type for both? Maybe yes, but I did it this way for both programming convenience, as well as performance. For speakers, there are not likely very many speakers, and when they get added, there is no performance concern. That is, in most databases, including SQLite, when you add a new record with a number as a primary key, auto‑generated or otherwise, there needs to be a calculation to figure out what the next available number is. You can imagine that if two separate browser users do this at the same time, then they both may get the same number, causing a database unique key violation when the data tries to insert. That's a problem because both the users did not successfully add the speaker, but also because of the performance impact to get that unique number even when it did work. As I said, for speakers, this is not an issue because there are so few speakers relative to the number of attendees added. The benefit of using numbers for speakers is that they are easy to read and easy to debug if you have any issues later. Long strings, like GUIDs, can be a nuisance to compare and work with. However, for the Attendees table, we may have tens of thousands of attendees, and when we do special promotions, lots of them may sign up at the same time. That could easily cause a performance hit on our website, as well as the attendee add failing when two attendees try to add at basically the same time. Using unique identifiers like this is best because they can be created almost instantly, and statistically, we can assume they will be unique. A big win! The last thing to do is to make it easy for us to reset our database if things go wrong. Let's add a couple things to our package.json file. First, add a new section, Prisma, and add a single attribute to it, seed, that points to our TypeScript file that does the adding of records from db.json. Lastly, add a new script line that resets the database and name it resetdb. It also runs some previous commands that may help if things go wrong. You should always be able to run this and get a fresh database just by typing npm run resetdb at the terminal prompt. That's it for setting up SQLite in Prisma. Next up, let's use this database to load our speakers rather than getting them from a static array, like we currently have in our React app.

Replacing Static Data with REST and SQLite Calls
Now that we have our SQLite database in place, let's update our speakers page from simply rendering data from a JavaScript array to instead render it from our populated table, Speakers. The plan is to first create some JavaScript function that performs basic data operations on our Speaker table using the object‑relational mapper, Prisma. Then, create on our node server the one that Next.js launches on our behalf, a REST server that consumes those JavaScript functions that access the data. As I said earlier, we can't just call Prisma and SQLite from our React code running in the browser because that code has no direct access to the database. That's why we need to create the REST server and node and then make calls to that REST server inside our React app. Okay, so let's start out creating our API of sorts, basically a set of functions that run on the server and perform basic data operations against our SQLite database. Before doing that, though, we need to create a utility function that provides us with what we can think of as a connection object to the SQLite database through Prisma. One is actually provided by Prisma, but because our web server opens a lot of threads to handle all the incoming REST requests, we need to create a special way to handle that, and that's by creating a global connection object that all our requests can talk to. Heading back to VS Code, we do that by creating a new file in the existing folder /src/lib/prisma, and let's just name it prisma.ts. Pasting that code in here now and scrolling down some, notice the checks to see if we are running in production, meaning we built the app with npm run build, and if so, it simply creates that global JavaScript object and names it Prisma. And then at the bottom of the file, directly exports it so we can access it any place we want in our app that's running on the node server. In development mode, this file provides us with some nice debugging options which can be set by setting environmental variables, which you typically do in a .env file. I'll paste some comments up here on the top in case you want to experiment with this on your own. Now, for the functions themselves. In this same folder, create another TypeScript file, speaker‑util.ts. I'll again paste in some prewritten code that gives us some database access functionality. As far as this file goes, we have our first method call, createSpeakerRecord, that takes in as its only parameter a speaker object, which holds our speaker properties. All it does is to call and return a promise, prisma.speaker.create, passing it as data the speaker object. This essentially is the main function of Prisma in that it takes a JavaScript object, converts it to a SQL insert that gets executed against our database. It just makes programming against SQLite when in JavaScript much easier. Looking at the sidebar on this code file, you can see we have some errors. Scrolling down, the first one is a TypeScript error, and it's pointing at _count. That's because the general‑types TypeScript file we created was very simple, and as this course goes on, we're going to add sessions and also add tables to support attendees favoring speakers. Let's go to our general‑types file and add more general typing that will support all that coming up later in the course. Going back to speaker‑utills, you can see all those errors are now cleared up. Let's continue looking at this code. Collapsing it, you can see we've got four other method calls to work with, deleteSpeakerRecord, getSpeakers, getSpeakerDataById, and updateSpeakerRecord. Notice that sometimes we have an attendeeId in the parameter list. For now, you can ignore that, and when we call these APIs, we'll just make that value undefined. Much later in the course, we'll be working with the table Attendee, and we'll be tracking things like which attendees have marked as favorites which speakers. Much more on that to come.

Implement a REST Server in Node with API Router
Given that Prisma is only running on the node server and cannot operate in our React application, which is currently browser‑based, we need to create a REST API on our node server. The REST API needs to handle incoming requests from a React web client by providing the necessary data responses. Our build system, Next.js, provides us a hook into writing our own code that runs in the node server. It does that through what Next.js calls API Routes. Let's first create a simple API route that will respond at the URL localhost:3000/api/speakers. We do that by creating a new folder under /src/app and name it api by convention. Then under that, we put another folder named speakers, which is our API route. In that folder, we create a file named route.ts that will process an incoming request to our node server. Here's some real code that processes that request. Again, by convention, we declare an async function that takes a single parameter request. Then in that function, we call getSpeakers from the data API we just wrote, and because it returns a promise, we need to await the return and then assign it to the new variable, speakers. We then just return speakers as a response object of type application/json. That's literally all we need to do to serve a GET request for speakers. If we enter our request into our browser directly by updating our URL to localhost:3000/api/speakers, we get as expected all our speaker data nicely formatted in JSON. Since our URL ending in /api/speakers is also going to handle the REST CREATE method, we need to have another exported method in this route.ts file named create that will respond appropriately. I'll just paste all the completed code here for both methods GET and CREATE. Collapsing each method, you can see it's actually named GET and POST, as POST is the CREATE in REST. To round out our full REST server responses, we need to also support GET when the URL is called ending with /api/speakers/ the speaker ID. That will get us just a single speaker record. We also need to support PUT, which is UPDATE and DELETE following that same ID convention. And next, the way to handle that is to create another routing file in a folder, [id], alongside our current route.ts. And then again, put a new file in that folder named route.ts. Following the same convention we used previously, in this file, CREATE methods, GET, PUT, and DELETE. Collapsing this code, you can see all those exported functions. Notice also now our sleep in this file so that our REST calls will include an artificial delay, possibly representing either a slow call to a database, or more likely just a round‑trip from the browser client to a remote node server, which is likely what would happen in a real‑world React app.

Updating the Speaker Component to Call REST Service
Now we have our REST server running on our node app to support the CRUD operations, Create, Read, Update, and Delete against our SQLite speaker table. Let's now update our React code to make the appropriate REST requests. Here in our /app/speaker/page.tsx file, let's update this code from serving a JavaScript array of three speakers to one instead, rendering the eight speakers in our SQLite database. Start out by removing the local speaker array. Then let's update the code in useEffect to call with fetch our REST server, and then take that response and let that be what gets set to local component state speakerList. We could have tracked the loading state before when we were just rendering based on a sleep timer, but it didn't make sense because there was no way for an error to happen. Now, however, since we are calling an external server, we know bad things can happen, so we need to track the loading state better to include things like errors. To that end, let's create a new local component state and name it loadingStatus and initialize it to the string loading. After we've set our speakerList state, let's assume that loading was successful and set the loadingState accordingly. In catch of our try catch surrounding our fetch, let's start out by setting the loadingStatus to error. Then since we want to know what the error is so we can display it to the user, let's create a local component state for that and call it error and initialize it to undefined. Now, back in the catch, check to see if it's an instance of type error, which means it will have a .message property, create a constant errorMessage assigning at that property value, then set the state error to that message. Notice there is a TypeScript error, and that's because error is currently only set to allow undefined as a type, so let's add an or string to that so that it can be either string or undefined. And that takes care of our TypeScript message. If error is not of type error, then just set error to a string that says an unexpected error happened. Since we have state now tracking our loading, let's update our render section to first check for an error. And if there is one, render a div containing that error. If not, check for a loading state, and if that's the case, display a simple string saying loading. Otherwise, render our full speaker list like before. Let's see how we did. Entering into our URL localhost:3000/speakers. Sure enough, up come our eight speaker records from our SQLite database. If we want to test our error handling, add an X to the end of the URL passed into the fetch. And as expected, we get an error rendered to our browser. One final thing to do in this file is to add type safety to our loading status. Let's do that by creating a new type, LoadingStatusType, and allow it to only be loading success or error. Then when we call useState for our loading status, update its type to be that value. Notice now that if we misspelled loading as the initial state, we get a nice TypeScript error, helping us to avoid simple mistakes like that. We've now completely updated our speakers page to render a list of speakers through a local node server running the REST protocol. A very important note here is our React app is not tied to Next.js in any meaningful way. That is, the REST server could be written in Python and running on any platform, not just node. Often when building enterprise apps, you don't get a choice as to where your data is hosted. Creating React apps like this that are purely running in the user's browser is a great way to develop apps that don't depend on any particular server technology.

Takeaways
The big takeaway from this module working with data in pure SPA apps is that React without any server‑side component or even a dependency on a node server is exceedingly capable. Building apps for environments where you don't control the server is 100% available to us devs building React apps. In addition, we learned in this module what the details are to create these SPA apps, and that depends only on a server. In our case, it was the node server built into our node environment using the Next.js API routes technology. It could, however, have been any other REST server any place on the internet. Not only that, we went in‑depth on what's necessary to have that node server work with the real database. In our case, we set up a SQLite database on our node server. But again, it could just as well have been IBM's Db2, Oracle, SQL Server, or any other enterprise database. The logic would have been almost identical using the object‑relational mapper, Prisma. Why do we go into all this detail to set up our node server accessing a SQL database? Well, first, because you may have this exact scenario when you're building your own apps. But second, and very important, is that as this course continues, you'll learn how to build both React Server Components and code Server Actions that will rely on the Prisma code running on the node server. In other words, if you can run a node server as the host for your app, like Next.js does by default, coupling our client‑side code to the node server can bring big advantages. We've now set the foundation for doing that later in this course.

Leveraging React Context for Data Including Forms Processing
Introduction
Now that we have our basic data processing covered all the way from a database, SQLite in our case, through a REST server to our React apps rendering, let's dive a little deeper into leveraging what we've learned with some more programming patterns. Specifically coming up now, let's take a look at better managing how our React component state is handled when working with data. Specifically what I'm talking about is how in our current app, we have several independent component states that are not really independent. We'll look at combining them into a single consolidated state and discuss some benefits of doing that. We'll then look at our current single component design for rendering speakers and see how we can improve that. That is, currently in a single component, we both fetch and render all our speaker data. We can make that better if we're factoring the loading and state management code and pull that out into what we'll call a shareable React provider context. Lastly, we'll use what we've learned combined with a standard HTML form element to create an email signup for our conference website. Forms are a very powerful way to manage data in web apps, and we'll take a look at that through the lens of React.

Create a Combined State Object
Our current app is basically just a single React component that manages multiple React states. Specifically what it is I'm talking about is that to manage retrieving speakers, we have three separate component states we are tracking. One for the speakerList array itself, one for loadingStatus, and the other for the error string returned in the try catch if there's an error. We can convert those three useState calls to just one by creating a single state object that has multiple properties, each representing what was an individual state. A big benefit of doing this is that with one call to a setter, we can update multiple state objects, and therefore avoid some confusing combinations of local state. Let's do the conversion now of our current code that has those three states, and that will give an example of what I mean by avoiding confusing state combinations. Let's revisit Visual Studio Code, and specifically our component that renders our speakers/src/app/speakers/page.tsx. For now, let's leave the code as is, and at the top of the function, create some new code for our new combined state. Create a TypeScript type for our combined state, then create an initialState that we will pass to useState momentarily that initializes our single state object. Finally, make our call to useState with our new TypeScript type and our initialState value. Now let's remove all the old state setter code that worked with separate states. We do need to update our useEffect call, as now we have a single state to update instead of three. Let's make all those changes needed. Notice how in the catch of the try catch, we are using the spread operator to avoid having to re‑mention all the state values that did not change. The only thing left is to replace in our render methods the direct mention of the three separate states. Let's do that also. Now that we have successfully done that coding update to have a single state object, let me continue my earlier discussion around why this is better than having multiple component states like we did before. Previously after we retrieved speakers from our REST URL /api/speakers, we made two sequential calls to state setters. That is, we called setSpeakerList to assign our speakers to the local component state speakerList, and then following that, we called setLoadingStatus to set our loadingStatus to the string success. The confusion this could create is what is the actual UI that should be displayed directly after the call to setSpeakerList and before setLoadingStatus? Technically, after each state update, the UI could re‑render. Since it's not clear whether the loadingStatus should override the fact that there are actually speakers in the state speakerList, it's not obvious what to show. By having a single state that we can update all at once, that avoids any ambiguity. We are counting on any update we make with setSpeakerState to not produce any conflicting states. That is, we are assuming the application code we write that calls setSpeakerState will never produce a speakerState that has loadingStatus set to loading, while at the same time returning a non‑empty speakerList. A more formal way to do this is to instead of creating a single combined state object, but instead leverage the React hook useReducer, which takes in as a parameter a reducer function that can have very explicit rules around how to handle state changes. In our current case with just three separate properties that we're tracking state for, I'm very comfortable handling this with a single combined state like we've done. If our state management in this component were more complex, meaning also more state interdependencies, I'd be looking harder at including the useReducer hook in our component instead of a simple combined speakerState, like we've implemented.

Add Component Nesting to Allow for React Context
Currently in our app, we just have a single speaker component that both retrieves all our speaker data from a REST URL, and then based on local component state updates, re‑renders that component to fully show a list of speakers. This is okay if we only wanted our app to have a single page like this. However, in the real world, apps are a lot more complicated, and it makes sense to refactor out parts of this component to create reusable components. Those reusable components we'd then be able to use across our full app. Also having a single component that has all the state logic, as well as the rendering logic in it, violates the design pattern "Single Responsibility," meaning the component is just doing too much. Let's extract all the logic and state updates around loading speaker data into a new function component that includes React context. If you're not familiar with this pattern and want to see a more in‑depth explanation and review of it, I suggest checking out a few clips in a previous React course I release titled Working with Components in React 18. Specifically, the module Global State Sharing, and starting out with the third clip, Sharing State with React Context, and then the next two clips following that. I'll basically do that same pattern here, but without as much explanation, assuming you've seen it before. Okay, so let's do the refactor. Let's start out by moving practically all the code in our /src/app/speakers/page.tsx into a dedicated component. The reason is that since this component is the root component or speakers route, we will not be able to access any React context without it previously being enclosed in a React context provider element. I'll explain this shortly, but for now, just follow along. To start, select everything in the component body. Let's assume we are going to create a new component in the same folder as page.tsx and call that component SpeakerList. Let's cut all this code into our paste buffer, then replace it with a return that renders a new component, once we've created it, named SpeakerList with no attributes. Import it above as if it existed in the same folder as this page.tsx. Then create that component as the default export in a new file named speaker‑list.tsx. Into the new empty file, declare the default export name SpeakerList, and then finally paste from our copy buffer the code we cut a moment ago. Lastly for this step, add the imports we need at the top. We're finally now ready to add a data provider that will allow us to use a shared data context in our app.

Create Dedicated Data Context from Existing State Management
Now that we've got this SpeakerList component as a child of the original speakers component, we can create a new context provider class that we can make this SpeakerList a child of. Let me drag into this project a completed context provider component that I've named SpeakerDataContext and put it in the new folder /src/context. This folder is where we will put any other provider context that we use in this app. Let's briefly review the code in this file. Its default export is a function component named SpeakerDataProvider. It takes in no props besides the built‑in to React children, as its main purpose is to render any children component it surrounds while adding the ability for those children components to reference the context defined here in this file. What is that context? It's declared here on top. It's SpeakerDataContext, and it's created with the React API call, createContext. We define the type of this context to be SpeakerDataContextProps, which for the moment is just a single JavaScript object, SpeakerState. This is the exact same state that we currently created in SpeakerList. Our plan is to use this one instead. We'll get to that momentarily. Notice this context can also be undefined, and by default, we initialize it to that. Scrolling down to the component itself, notice it starts by creating the SpeakerState with useState, and exactly like in the SpeakerList, it initializes that empty state to an empty list and sets the loadingStatus to loading. Because it's just a React component, we can call useEffect again, and just like SpeakerList did, our useEffect calls our REST API and on completion updates the SpeakerList in loadingStatus accordingly. In the render part of the component, it simply renders its children assigning a value to the context provider so that any child component that is wrapped with this context provider will have access with the React hook's API call, useContext. Speaking of useContext, if you notice, unlike how this pattern is often implemented, we are not exporting the context we created with createContext at the top. Instead, at the bottom of this file, we are exporting as a named export a brand‑new custom React hook and naming it useSpeakerDataContext. This hook itself calls the React API useContext, passing in the context created in this file, SpeakerDataContext, and then returns that. So, what are these extra lines of code that check to see if the context is defined? Well, the answer is in the error message it throws if it's not defined. That message is useSpeakerDataContext must be used within a SpeakerDataProvider. What this error means is that we never actually surrounded our component with a new SpeakerDataProvider React function component. That is to say, we tried to reference a context in what we thought was a descendant child of SpeakerDataProvider, but in reality, it was not. This error is a lot better than if we called useContext directly in our code and forgot to do our proper wrapping of a React context provider function. We'd get some error like undefined or contextUndefined, but it wouldn't be clear to us that the reason was because we forgot the wrapping. Let me make this more clear by finishing this example. Let's go back to the file that holds the root element of our speakers route, that's src/app/speakers/page.tsx, and add this SpeakerDataProvider function to it. First, import at the top the SpeakerDataProvider component we just created. And then simply render that while including as its child SpeakerList, the component we were already rendering, but now will have access to the React context inside the SpeakerDataProvider component. This will allow us to remove lots of code from inside our current SpeakerList because that code is now duplicated in the SpeakerDataProvider component. Navigate to SpeakerList and let's make the changes there to reflect this. First thing, let's get a reference to the custom hook exported from SpeakerDataContext that will return to us our composite state, SpeakerState. Then at the very start of the component, let's call that hook, having it, return the state that it's managing, again, SpeakerState. Now all this other code below and before the actual rendering of the component is no longer needed, as it's duplicated inside our SpeakerDataProvider function. Let's remove it. Lastly, since we are no longer managing state in this component, let's remove our React API imports, useEffect and useState, from the top. We're now looking at the entirety of our SpeakerList component. Notice how simple it is. Notice all the state and lifecycle methods, specifically useState and useEffect, are no longer part of the SpeakerList component. All that is handled inside our SpeakerDataProvider component. I realize there's a lot here we just covered. Basically, it all comes down to in our page.tsx file, we wrapped our SpeakerList with our SpeakerDataProvider function, and then inside SpeakerList, we were able to get a reference to all the code running inside that function. Let's verify our app still runs as before. Refreshing our browser, and as expected, the speakers reload after the loading message.

Adding Layout, Navigation, Header, and a Footer
At the moment, looking at our app structure, we've got a home page which is currently a simple counter demo from the beginning of the course. And if we navigate directly to our speakers page at the route/speakers, we get our list of speakers rendered, which are pulling from a REST server, which in turn is calling SQLite for the actual data. Let's update this experience to include a more classic website design, which includes a home page, as well as some navigation controls that let us easily navigate between our home and our speakers page. To do this is going to involve adding four new files to our project and two existing ones. If it were just total of a couple of files changing and updating, I'd be inclined to walk through the process with a single Visual Studio Code window, like usual, meaning that I drag‑and‑drop new files into the right locations and I update the original ones manually. My thinking there is that for those of you coding along, it's easier to follow, and for those just following along, the coding continuity just makes sense. However, when a lot of files change like this, and in particular, when the changes are not really relevant to this particular course, but just React in general, I think it's best that I make the changes behind the scenes and then bring up a really good visual div tool and explain the updates. If you are coding along, you can easily make those updates yourself based on the list of the new and changed files that are easily obtainable from the GitHub repo. Okay, so let's dive into VS Code and get started with the compare that will bring us to an updated app that includes layout and navigation. We are here in the code that was completed in the last clip, and we're ready to compare it to the updates with the four new files and the two updated ones. My favorite visual extension for comparing folders is called, no surprise, Compare Folders. To install it, go to the VS Extensions sidebar, search for it, and then click on the Install button. Now notice the double folder icon added below our existing sidebar tabs. Click on it, and then select the folder we want to compare to. That's the folder that corresponds with this clip number in the GitHub repo. Wait while the compare happens. Once it's done, we've got three sections on the left, replacing our File Explorer. The top shows us the files that changed, the middle, only the files that are in our current folder that don't exist in the new folder, and then the bottom is the files that are in the new folder, but don't exist in the original. In this case, those are the four new files. Let's start with the root element component in our app in that /src/app/page.tsx. On the left side is what the component originally was. Notice it's just the example that we had put together earlier in the course for a click event and how that's processed. And now on the right side, it's a nicely formatted component that shows the header followed by a Nav control, then our new home page, and then finally, a footer at the bottom. Notice the nice Bootstrap elements that surround each area. Moving to the new files, let's switch to header. Notice that header is basically just a new component. We're calling it a client component, though it could just as well be a server component, and notice that it's mostly formatting. It's got our code camp logo, as well as the code camp title, and the date of the event. If we look at the Nav control, notice the Nav control does have a lot of client‑side React components. It starts out with a TypeScript type enum, which allows us to have Home and Speakers as static URLs. It makes sure we don't mistype those. Then in the component itself, we have an activeNav state, which keeps track of whether we're on Home or Speakers, and also isNavCollapsed, which has to do with whether we're using a hamburger menu because it's a mobile menu, or a standard menu, which is just the tabs listed across the top. Looking at the render itself, we've got some nice semantic HTML with the nav element. And then, nothing surprising, just some HTML that renders the menu itself, as well as handles the click events as the user navigates this Nav control. Looking at the home page, that's this home.tsx, notice all the home page includes is some Bootstrap formatting, along with a nice image of our attendees eating lunch at a previous code camp event. Lastly, we have the footer, which is just a bunch of Bootstrap formatted HTML or JSX that's rendered, and it includes a copyright notice at the bottom. The only other component to look at is how we changed our speakers page. That's the component associated with what renders at the URL /speakers. Notice previously, we just had the simple React context wrapping our SpeakerList. Now we have the Header, the Nav, and the Footer all rendering around that. Let's now see how things change when we re‑render our page at the new URL /speakers with all the new Nav controls added. Notice we have our loading message just like before, and then our speakers render. But now notice that we have our header with our code camp name on it and the date, we have our navbar which lets us switch between the Home page and the Speakers page, and then at the bottom, we have our footer, which includes our copyright notice, among other things. Clicking on the home page, we get our new home page with a picture of lunch. Clicking on the speakers, we get the loading message just like before, and then our speakers render.

Adding a REST Implementation for a Second Table
Let's move on from working on our conference speakers to a different aspect of our website, that is collecting email addresses of people who want to be notified of upcoming events. That's pretty standard for a website like this. Specifically, let's add an input field to our footer that allows browser users to type in their email and then click some button to subscribe to a list. This kind of functionality is exactly what HTML forms are designed for. Most often, forms have multiple fields on them, but there's nothing wrong with having just a single input field and a single Submit button. If you remember when we created our SQLite database, and specifically, the Prisma schema, we included an attendee model, as I was planning on adding functionality like this in the future. And the future is now. You can see attendees here in this model, and it includes one email address per attendee. What we did not create was a REST service to perform CRUD operations on our attendee database. Let's do that now. Remembering from before, we have two separate API route files for our REST server that supports speakers. That's /src/app/api/speakers/route.ts, and the same starting URL, but /[id]/route.ts. Let me drag in exactly the same routing file functionality for attendees in a sister folder, just /src/app/api/attendees. These two new files will support GET, PUT, POST, and DELETE, basically CRUD operations on our Attendee table. These REST services do depend on a small TypeScript file for accessing the attendee records through Prisma, so let's drag that in also. That ends up in the folder /src/lib/prisma/attendee‑utils.ts. We can easily verify that our POST, that's the CREATE, to the REST server is working by issuing a curl command from a terminal prompt to our REST server using the following curl command. Of course, you have to have curl installed on your computer for this to work. Notice it just passes one attribute, and that's email. So let's send it. And as expected, back from our REST POST API call, our new record is returned. It includes the new id, which is a GUID, along with the other fields that are automatically created for attendee records. To show that this POST or CREATE actually worked, we can go to a browser and send a GET request by just simply typing the URL into the browser of the REST server. That's just localhost:3000/api/attendees. Notice we have lots of speakers. We created 500 by default when we set up the database, but since it's returning in reverse creation order of attendees, you notice on top, we have the one we just added. Our REST server for attendees is working, and now we can proceed to add to our conference website's footer component and input field, and then submit whatever is entered into that as data, and hopefully the browser user will now have subscribed themselves to conference emails. We'll do that next.

Processing a REST POST with the Form Element
Now that we have our REST service built for attendees, we can add a new item to our footer that lets browser users subscribe to an email list associated with the site. Let's replace the KEEP UP TO DATE ON SOCIAL MEDIA, which is part of our footer, with a new input field that takes an email address and a button, when clicked, does a POST to our attendee REST API. We're back here in Visual Studio, and we're looking at our footer component. That's in the file /src/app/footer.tsx. Let's replace this h5 and the text below it, Keep up to date on social media, with a call to a new component that we've not yet created, FooterSubscribe. Importing it at the top first, assuming it will be in the same directory as our footer.tsx, this file, and then render it replacing the h5 below. Now create that file, and then scaffold out a default export, FooterSubscribe. First thing, create a local component state to hold our email using useState, making a type string and initializing it to blank, and then have the state be called email with setEmail as the setter. Import useState at the top, of course. Here's the key to getting a POST made to our attendee REST service. We just simply create a form element, which is standard HTML, and then we add the attribute onSubmit, passing it a reference to a new function, handleSubmit, we'll write in a moment. Add an input element of type email that allows us to type in an email address, having onChange be a new function, handleEmailChange, and have it default to our new state value email. Then add a simple button of type Submit, and that will activate the onSubmit in the form definition. Now we can write a simple handleEmailChange event that simply updates our state. And next, let's write the handleSubmit function, which is an async function, that will actually do the submission or the posting to our REST service. Have it start out by forming the POST request itself. We'll call POST data, and it gets the email, as well as the CREATE date of now. Then for the actual work, call fetch with the method POST, make the Content‑Type application/json, and stringify it so it posts correctly. The rest of this function is just to make sure it didn't fail, and if it did to put up a message indicating that it failed. That's basically all we have to do to submit or POST to our REST server from an input field. We're mostly leveraging the capability of the form element and how submit works with that. So, let's see how we did. We're looking at our new webpage. It's certainly not formatted very well, or at least up to the standard of the current webpage, but we'll fix that coming up. Let's try it. Type in a sample email address, Tom@Jones.com, in this case. Press the Subscribe button, and as hoped, we get a message that says subscription updated successfully. Browsing to localhost:3000/api/attendees, and sure enough, we get Tom@Jones.com as our first attendee shown. It worked as we expected.

Enhancing the Form Processing UI
Just looking at the UI in the footer of the conference app we created, you can tell something is wrong. The input field formatting isn't right, the button formatting is wrong, and not only that, when we put in an email address and click Subscribe, there's no feedback while the POST request is sent all the way until the alert shows us successfully subscribed. The fixes are very straightforward. For formatting, it's just adding the standard Bootstrap classes, and for the processing side of things, adding appropriate local component state to track the button press event and the request completion are all that is needed. Rather than having you watch me code through the updates, this is a perfect opportunity for me to make the necessary changes behind the scenes and show you a div of the changes and explain them. So let's do that. We're back here in Visual Studio Code, and I've got on the left side some updated code that represents the code at the completion of this clip, that is after all the fixes, and on the right side, the previous, very simple code that didn't work very well. Let's just go section by section. We've added at the top an import to useEffect. You'll see that momentarily. We've added a sleep, which we can use to delay the return, so we can actually see something happening. We've created local component state isSubmitting, so we can track when it is submitting and when it's completed submitting, that's just a Boolean. And we've also added another Boolean state, isButtonDisabled. Going down a couple lines, we can see that useEffect checks every time the email is changed, which happens on keystrokes, and then it does a simple calc to see if it's a valid email, and if the email is valid, isButtonDisabled is false. Scrolling down a little bit in this code, in our handleSubmit, the first thing we do is we add a setIsSubmitting. That sets our local component state to true. We'll see how that is affected when we look at the render section. And then when the submitting is done, we set it to false. Scrolling down further and actually looking at a render section, you can see on the right, it's very simple. There's no support for interactivity or even Bootstrap. First thing to look at is notice all the new Bootstrap classes, like form‑control and btn‑outline‑dark. Those are just simple Bootstrap classes that make the format incorrect. Regarding the interactivity, notice we have a disabled attribute, which is set on the button, which basically says if the email is not valid or a submission is in progress, in other words, a request is in flight, then disable that button. The other thing that's nice is while it's submitting, the button text changes to Subscribing versus when it's not submitting, it says Subscribe, just to show the user something is happening. So let's go back to our browser and see how we did. Notice right off the email address and the Subscribe button look a lot better. It's got rounded corners, the font is correct, everything just looks nicer. And if I type into the email address, John@, notice it's not a valid email address. so the Subscribe button is disabled if I continue and type smith.com, as soon as the email becomes valid, the Subscribe button lights up. Now when I click Subscribe, you can see it says Subscribing, letting me know something is happening, and when it's done, just like before, I got my Subscription updated successfully message. Saying OK, the email goes blank, and of course Subscribe is disabled because we don't have a valid email anymore. A much nicer UI experience than we had before.

Takeaways
Taking our ability to work with data to the next level was the goal of this module. We started learning about how consolidating multiple component states into just one can improve the quality of our components by making them both more efficient, as well as more consistent. In other words, multiple React local component states that are managed independently when they are potentially not really independent of each other is a problem that can often be solved by using these combined state objects. We then learned how React context can be combined with data to make reusable data components, and thereby simplifying our designs. That is, putting everything into a single component adds a lot of complexity to our apps that refactoring can help. Specifically, the refactoring we learned was how to use React context to share both lifecycle events and local component states in our React apps. We also took a short trip into using the very powerful form element in our React apps to simplify getting data from our client app to our server. Forms are often overlooked, when in reality, they can provide a very elegant solution to potentially complex problems that otherwise you have to do a lot of state management to solve.

Using Suspense to Better Handle Async Data
Introducing Suspense for Data
Suspense is a great feature in React that allows us to easily manage data coming from asynchronous data sources, like REST servers or databases. What makes Suspense a great solution is that it reduces the complexity of the React code we have to write when creating UIs for our browser users. It does it by keeping track of when async requests complete, and then and only then, renders components that include the data associated with those requests. Let me explain at a high level what I mean by this, and then coming up in this module, we'll dive into some code to demonstrate that. First, let's discuss how our current speakerList renders at a high level and discuss how that would change when using Suspense. Here on the left, we've got the basic flow of our current app that explicitly uses state to track both the array of speakers that will render, as well as the loading status of the list of speakers. In this case, when the component is first created, the loading status is set to loading, and the speakerList is set to an empty array. Then when the render section of the function runs, the resulting rendered HTML reflects the loading status, and a loading message is rendered to the browser. After the first render of the component, the code in useEffect is executed, which effectively does some kind of request to get data, and since in this case, it's doing it as an async function with the async/await pattern, execution pauses, or at least pauses in this useEffect code. Lastly, when the request is complete, the loadingStatus is set to success, or if the request fails, it's set to error. Again now, the render part of the code is executed, and if an error occurred, the error is displayed. Otherwise, the speakerList is rendered. Now let's look at the story with how the same functionality is achieved using Suspense. Unlike when using states to manage the component's rendering, where we could do everything in a single component, Suspense requires a little more setup before any processing can happen. More specifically, that setup involves creating a promise that is returned from an async request, and then that promise is passed to a dedicated rendering component. Let's look at the dedicated rendering component first. Notice it takes as a single receiving prop the promise I just mentioned, and for now I'm calling it speakerPromise, but it could be any promise. The first line of executable code in the render is const speakerList = use(speakerPromise). Use is a new React hook that's built into the React API and designed specifically to work with Suspense. Just a very important side warning to mention, at the time of creating this course, January 2024, the "use" hook is currently in a React Canary Release, which means two things. First and most important, React is 100% committed to this release. That is, the use hook will become a part of the full production release later. It also means that this code is not completely stable. The team is basically telling us to use it at our own risk. In my experience, use is not ready for production apps, and I strongly recommend not to use it yet. I'll go into more details shortly about this. This doesn't mean you can't use Suspense. I'll talk about that more later. Okay, so back to the Suspense code with no status checking or state management and just the rendered speaker's code. The assumption here is that when the new use hook returns, you are guaranteed that the data request has completed and the data has been returned. You can kind of think of use as an await of sorts. It's just very specific to components that render in suspense boundaries.

Comparing Suspense to Code without Suspense
When comparing the code written with Suspense on the right to the code written using local component state on the left to manage async calls, it's obvious, to me anyhow, that the Suspense code is much simpler to write and maintain. Let me explain my reasoning. To start, writing those ternary expressions and curly braces that tracks what to do based on state is just a hassle to write correctly and can easily lead to obscure bugs down the road. The Suspense code is just easier to write and easier to maintain. So what about creating this promise? How did that happen? Let's look at the other component that rendered SpeakerList as a child and passed in the speakerPromise as an attribute. Notice the first thing we create is an async function that returns a promise. That promise when fulfilled will return a concrete list of whatever we want rendered, the SpeakerList, in this case. Then we call our SpeakerList, passing in that promise, but more importantly, we have to surround that call with the Suspense element. Doing this effectively creates what we refer to as the Suspense boundary around the SpeakerList component. That's what allows the new React hook use to actually work. Meaning the execution of the code in SpeakerList doesn't happen until the promise passed in is completed. That is, the program doesn't proceed past the use call. So what happens until then? That's easy. The component assigned to the fallback attribute of the Suspense element is rendered. Then when the promise completes, the SpeakerList component continues from the use hook call and the SpeakerList renders, replacing the fallback code. Let's walk through the code path that gets executed when a traditional pre‑Suspense component is processed. When the component is created, the initial SpeakerList state is initialized and set to an empty array, and the loading status state is also initialized and set to the string loading. In addition, useEffect is called, and the first parameter, which is the function that gets executed after render, is set, not executed. Then after the component is fully rendered, meaning the loadingStatus is set to loading and the SpeakerList is an empty array, the code assigned to useEffect executes. That code executes a fetch command to retrieve speakers, and then when it completes, it assigns the SpeakerList to the result of the fetch and sets loadingStatus to success. Finally, then, the return or rendering happens. Assuming no error, the speakers render. So what about Suspense? When the component is first created, the speakers component renders, and whatever promise was created in fetchSpeakerPromise is passed to SpeakerList as part of the initial render. When SpeakerList renders, the first line of code that calls the React hook use pauses, or basically awaits, until the promise completes. When that happens, this code continues running and renders the SpeakersList. Do you see like I do how much simpler the code execution path is? With the original code, the code execution starts out in the initialization phase, first time by loadingState, then loading the function into useEffect, and then finally rendering the code in a loadingState. Then after the render, the code pointer goes back up to the top, runs the code and useEffect, checks the state again, then renders based on a complex ternary expression. With Suspense, just one simple pass. First the promise loads, then one simple pass through SpeakerList, and when use returns, the rendering happens. No complicated states to keep track of; just a much simpler flow.

Error Processing with Suspense
What about handling errors? We took care of that in the loadingState code with a try/catch and setting state accordingly, but we did not in the Suspense code. Turns out we can use error boundaries just like we did previous to Suspense. It just means now that Suspense works seamlessly with it. That is, we don't need to explicitly code try/catch, and then handle the errors, we can let the error boundaries handle that for us. Error boundaries have a fallback attribute just like Suspense does. That is, whatever component we assign to the error boundary fallback attribute will get executed if there is an error in completing the promise assigned to the element executing inside the error boundary. Just like Suspense boundaries, if an error occurs any place in your React app, the nearest error boundary to the error will get executed and no other error boundary will process. If you want to learn more details about error boundaries in React, I suggest heading over to a previously released course here in the Pluralsight library working with components in React 18 and specifically the module Handling Errors and Debugging Components. Look at the last two clips specifically discussing using error boundaries like this. Now's a good time to talk a little more about Suspense or error boundaries. This example only has one Suspense boundary. In real apps, it's often the case that you'll have multiple Suspense boundaries in React apps. When a promise completes, the component that executes is the one wrapped in the nearest relative Suspense boundary. In other words, if you have a Suspense boundary wrapping your full app, and then inside that another Suspense boundary, like might be the case if we had a speaker detail component with its own Suspense boundary, that detail component will render when the promise inside that boundary completes. If, for example, we had multiple nested promises like this and only one Suspense boundary around the full SpeakerList, then none of those speaker details would render until all the promises complete. That is, we'd just not be waiting on the SpeakerList promise, we'd be waiting on every promise inside that Suspense boundary, including all the speaker detail promises.

The React Hook “use” Is Canary Release
I previously mentioned that the React hook use is currently only available as of January 2024 and the build of this course in the Canary channel of React, which at the moment is 18.3. What Canary means to the React team is the following. Canary releases are officially supported, and if any regressions land, meaning significant updates, they will be handled with similar urgency to bugs in stable releases. They go on to say that unlike experimental releases, Canary releases only include features that they believe to be ready for adoption. You can take these words from the React team as you see fit. However, for me personally, I found that the use hook is not that stable. I've had odd behavior I've not been able to pin down, and because of that, I'm personally not going forward to include use code in any code that I ship to a customer yet. I am however, quite confident that the React team will figure out how to get this new use hook stable, and it will become stable with Suspense in the future. I'm teaching it in this course because I believe it's something you should know about, and it's also a great way to demonstrate the new Suspense features. So what about Suspense in general? Is that stable? Is that okay to use in production? Again, in my opinion, the answer is yes, but only if you use React server components and in a framework where that is thoroughly tested. At the moment, the only framework that is thoroughly tested with server components and Suspense is Next.js, which happens to be the framework we are using in this course. Coming up near the end of this module, we'll review an example of speakers rendering with suspense from server components that is 100% ready for production use.

Source Code Going Forward in This Module
Let's head back to Visual Studio Code and take a look at the project we'll be using for the rest of this module. To be clear, this is not a continuation of the project that we've been working on and building so far in this course. This is strictly a dedicated project just for the purpose of learning the fundamentals of working with Suspense in your React apps. It is based on the Canary release channel of React 18.3, and allows us to include the new use hook in our demonstrations. Notice now there are three specific routes built in this demo. They are speakers‑with‑loading‑status. Basically that's a rework of the speakers page we've been building so far in the course. It uses no Suspense and strictly retrieves speaker data using local component state to track the loading of speakers, just like we've done in the course so far. The second route, speakers‑with‑suspense, is a rewrite of the speakers with loading‑status‑route to do exactly the same thing, but using Suspense 100% in browser code, leveraging the new and only available again in the Canary release React hook use. The third route, speaker‑with‑suspense‑server‑only, again is identical in functionality, but this time uses React server components without any React canary features and is 100% available to you now to release production React apps with. I absolutely encourage you to run this project along with me to help you better understand coding with Suspense. Launching this project is a little different than we've done up until now, but still very similar. Let me explain. First, let's have a look at package.json. All that is different here is the three dependencies. Next is including the Canary release of 14.05. React and React DOM are the latest release as of now of the Canary release 18.3. In order to run this project, you will need to do an npm install, but it's important to use the ‑f option. That stands for force. That's because some of the other dependencies in this project are not consistent with these Canary releases, and in order to allow for all the packages to install, the ‑f is necessary. Then like previously, you can run npm run dev, and the node server will launch at port 3000 and the browser will run as normal. Notice now the tabs across the top all corresponding to different routes. Browsing to the first one, Speakers With Loading Status, notice the expected loading message, but then after all the speakers load, each individual speaker gets another REST request to fetch data based on the speaker's ID. That requested data includes the number of attendees who have favored that particular speaker. That is, assuming we have eight speakers when the browser first loads, one request is sent to the REST server /api/speakers, and then when that call completes, the full page of speakers is rendered, just like before. But then each individual speaker issues another REST call to the URL /api/speakers/speakerid, and then as those requests return, each speaker detail component is updated with that favorite count. The other two routes, Speakers With Suspense and Speakers With Suspense Server Only are very similar. Both use Suspense, but one uses it purely on the client side with the use hook, and the other uses it in React server components, which is currently fully supported and does not use the use hook. In all three cases, I can press the Refresh button on any individual speaker, and just that single speaker refreshes its favorite count. Coming up in the next several clips, let's take a deep look at all three of these routes and how they change as we add first browser only suspense with the Canary release hook use, then Suspense running 100% on the server with React server components.

Data with Loading States Code Review
Let's start out by reviewing the code in our first route, which is speakers‑with‑loading‑status. The root component of the app, page.tsx, is identical to the code we created earlier in the course. The page has a simple header, a Nav control, a component that renders the SpeakersList, and a footer control. Before going any further, it's very important that I explain something here that if you are not experienced using Next.js in the app router, you'll likely stumble on. Did you notice at the top on line 1 of this page.tsx file, we have "use client" in quotes? In React, when 'use client' is on line 1 of a component file, that effectively means this is a transition from a server component to a client component. I realize we've not talked at all about server components and what those are and what they mean. And really, you shouldn't have to know. React server components are new, and they can and should be treated as optionally opting in only, meaning that if you don't do anything special, your React apps will be client apps, just like they've always been in previous versions of React. Unfortunately, in this particular case, that is when you are using the Next.js app router, like we are, at the top of the page.tsx file, you must put 'use client;' otherwise, by default, the component exported in this file will be a server component. That means any use of useState or useEffect will be flagged as an error. As this use client string that's inserted is really about a transition from a server component to a client component, you don't need to include it in components that are children to this, as there is no transition, and they will continue to be client components by default. This particular problem just shows up in the route's root, like this, in page.tsx. Okay, so now we're done talking about page.tsx, and we can move on. Navigating to the SpeakerList component, it also is very similar to previous code. To keep things simple, it no longer uses a React Provider Context to manage the SpeakerList state in the page lifecycle event useEffect, but instead just puts all the code in line. By way of review, at the top, it defines the initialState of our single state object, that's type SpeakerState. It then defines that object with useState. Then, in the useEffect hook, after render, a REST request gets executed to the /api/speakers endpoint, and then after awaiting the results, setSpeakerState is called to indicate that the speaker loading was successful. Moving down to the render section of code, first, we check for the error status. That is, if the try/catch caught an error and set the state accordingly. Assuming no error, we check for the loadingState, and if it's not loading, we render the list of speakers with one SpeakerDetail component rendered for each speaker in the list. Bringing up a browser, you can see our speakers loading, and then they render. Notice, though, the number of attendees favoring each speaker is slowly filling in. That's obviously coming from the SpeakerDetail component, so let's navigate there and see how that works. This component simply takes in as a receiving prop the speaker record, and then in the render section, it displays all the speaker demographics. Notice, though, we have a new component rendering, SpeakerFavoriteCount, and the element, or component, just takes in the speakerId as an attribute. Let's navigate to that component. What we have here is a very simple component that has its own page lifecycle event, useEffect, that takes as the first parameter a function that gets executed only after this component renders. Remember that our SpeakerDetail component did not render until after the SpeakerList loadingState was success, meaning that anything rendered here will be delayed until after the SpeakerList fully renders. Here in this useEffect in the async function that runs, we first create a delay of 1 to 3 seconds randomly so that it looks like not all these components render at the same time. And then we call our REST URL with the URL including the speakerId, and then after waiting for the result, we set the local component state we've defined in this component, FavoriteCount, to the result, return from our REST call. That result is data.favoriteCount and is the number of attendees favoring that particular session. Notice also on the click event of the Refresh button, when the browser user clicks that button for just the speaker details, the status is set to loading, a single request is issued to the REST server for that individual speaker, and when it resolves, the local component date is again updated, but now just for this one speaker favoriteCount component.

Data with Client Components Suspense Code Review
Remember from just a little while ago, we compared with not quite real code, what it looks like to render a SpeakerList using local component state, specifically a loadingStatus in an array of speakers assigned to that state to one using Suspense and no local component state. The big difference, structural‑wise, is that for the loadingState version, we could do everything in a single component, and for the Suspense, we had to have a separate component that created a promise that then passed that promise to a child component that then rendered the data after waiting for the promise to complete. Specifically, we want to convert the app we just finished reviewing to one that includes Suspense and the new use hook. Let's go back to Visual Studio Code and look at the conversion to Suspense. The code in the route speakers‑with‑suspense is structured very similarly to what we reviewed previously in the route speakers‑with‑loading‑status. Suspense does force some differences, and right away that becomes apparent when looking at the page.tsx and SpeakerList files. Remember previously in our code managed by loading states, page.tsx was essentially just a simple component that really did nothing besides rendering some very static‑like pages, and SpeakerList had all the state and lifecycle management code to make the SpeakerList render. Let's look at the Suspense version of that. There's no local component state, no useEffect call, just the new React hook use, and the SpeakerList array is returned from a call to the hook use. Notice, however, that there is a single parameter passed into this component, and that's the promise needed which will return our speakers array once completed. That's very different than our previous example that had all the code in the SpeakerList component. Let's go up one level in our hierarchy to the component that calls this SpeakerList, and that's in page.tsx. It basically has the same async function as the one that we wrote for the component state version, but this one is much simpler. It doesn't have to worry about managing loading states, it doesn't have to worry about setting the speaker array into state, or initializing it. It just simply awaits the fetch call, and then before the data return, it just returns the promise for that data. Then it calls SpeakerList and simply passes in that promise as an attribute to the SpeakerList component. Something also important that's needed to get the same functionality as we had with our loadingStates version, we need to wrap our SpeakerList component with both a Suspense element and its loading fallback, as well as an error boundary element, also with its fallback. Suspense is directly imported from React, while error boundary is a class, we have to create ourselves and put in the project. It's actually a class component and is taken directly from the React documentation. You can read more about it at this URL. As is, this code that we've created will work just fine. The SpeakerList will load correctly using the Suspense boundary we created, along with passing the promise, and then waiting on that promise with the new use hook. However, if we look back at the loading status code and specifically the speaker favoriteCount component, it's still using local component state in each SpeakerDetail record to track each speaker render. Coming up next, we'll fix the speaker details so they each have their own Suspense boundary, and you'll see how gracefully nested suspense components work together.

Nest Suspense Boundaries
It's often the case in all but the simplest of React apps that components need to render based on other components. We already have that in our simple SpeakerList example because our SpeakerDetail records can only render after the SpeakerList itself renders. That's because our SpeakerDetail records each do their own REST GET to retrieve the number of attendees favoring that particular speaker. We certainly can manage this with local component state, specifically with a loadingStatus, but it's easier to let the React framework figure this out for us and just load them. Let's look at how the speaker with Suspense route handles nested Suspense boundaries. By way of review, the render code in SpeakerDetail is rendering the component speakerFavoriteCount, passing the speakerId of the speaker whose attendee count we need. Navigating there, we have similar logic to what we had before in that we make a REST call to a specific speaker URL, that is, the URL that ends with speakerId, and then on return, we can almost render it. That is, fetchFavoriteCount returns us a promise that will get us our favorite count, but only after the promise resolves, and we can't make that happen in this speakerFavoriteCount component. Well, this actually worked more simply when we could do everything in the same component. That is, in this speakerFavorite component, we had a call to useEffect and all the local state management necessary to render the count. Remembering with Suspense, we need to first get a promise from our async call, or in this case, REST fetch, and then pass that promise to a component whose job is to call the new React hook use so the component can wait until the promise completes and then render. Let's scroll down to that render section and look at how we solve this problem. We get around that in this code by creating a new component that will be a child of this one, and we'll name it SpeakerFavoriteCountDisplay. We then pass our promise to this component while remembering to surround its execution with Suspense and an error boundary. If for some reason we were to have forgotten to add these new, essentially nested suspense and error boundaries, the speakerFavoriteCountDisplay would still render, but not until each individual promise bubbles up to another Suspense boundary, which we have in our page.tsx. What the UI result would have been is that all the accounts would appear at once and only after every promise completed on every speaker detail. Finally, let's look at our new SpeakerFavoriteCountDisplay component. It's exactly what you would have expected. It receives a promise, and then calls the new use hook that effectively awaits the promises completion before rendering a count. Let's go back to our speakerFavoriteCount component and look at the Refresh button that updates that count. When that Refresh button was pressed, the onClick event fired calling fetchFavoriteCount, and that method simply called the REST URL again, and then when the load completed, set the loadingStatus to success. And we updated our state value. Well, without state, what can we do? I'm sure there is not one right answer, but this is what I came up with. Navigating back to speakerFavoriteCount in our speaker use Suspense route, I created my own local state in the component, knowing that changing state will force a component to re‑render, and then in the click event, I increment that state. In this case, I made a simple counter named Dependency, and I just increment it by one. Unfortunately, though, that's not enough. Rendering the component is not going to create us a new promise for fetching data from our URL endpoint. To solve this, I added a call to useMemo that creates a new promise when the dependency array changes. That is, I made the dependency array of useMemo equal to my dependency local component state. I realize I'm using useMemo somewhat opposite to how it's usually used. That is, usually we use it to reduce the number of renders, but in my case, I used it to force another fetch to happen, which is exactly what I wanted. Now with our Suspense fully implemented, clicking on the Refresh button on any individual speaker will cause just that attendee count to be retrieved again with a fresh value.

Data with Server Suspense Code Review
Lastly in this module, let's take a look at what it will take to run our app using Suspense in a server‑only mode. That means using React server components instead of the new use hook. Because server components run in a much more controlled environment than a user's browser, Suspense is right now 100% production‑ready when using it inside server components in a supported framework, like Next.js. So, what code changes would we need? The first thing to notice when working with server components is that you can't have the use client in the top of the page.tsx file in the root of your app. In our page.tsx, for speakers with Suspense, you can see we have use client, which means everything below this is going to be a client component. Looking at speakers with Suspense server only, you can see immediately we don't have use client. This component calls SpeakerList. Again, no use client, so this is server, this calls speaker‑detail, again, no use client, and speaker‑detail calls speaker‑favorite‑count, which in turn calls speaker‑favorite‑count‑display, all server components. So how does Suspense work with these? Well, in page.tsx where we previously created our promise, we don't do that anymore. Now when we look at SpeakerList, which is a server component, notice it's declared export default async function, which is allowed in a server component, not a client component. Notice in this function, we have code that runs directly on the server, that's this async function fetchSpeakers, which when we call it with await return speakers list, and then when it runs again in the render section, it renders SpeakerDetail, which has no promised‑based code, like we had previously. SpeakerList does render SpeakerDetail, and SpeakerDetail renders SpeakerFavoriteCount, which in turn renders SpeakerFavoriteCountDisplay, all server components. However, when we look at SpeakerFavoriteCountDisplay, again, this is a server component, and just like SpeakerList, it has an async function, fetchFavoriteCount, that when called returns the favorite count and renders it. Moving one level up to our parent component, and scrolling down, notice we have Suspense and an error boundary surrounding this component and rendering SpeakerFavoriteCountDisplay. In other words, in this route, speakers with Suspense server only, everything is formed on the server and rendered, and Suspense is doing exactly what it's supposed to do. Instead of waiting on the new hook, use, the function inside server components acts like a promise and then it respects Suspense boundaries, just like that use hook did.

Takeaways
I hope what you got out of this module on Suspense and data is that there is a new pattern out there that you can use to manage retrieving async data in your React apps. It does hand more control to the React framework for managing the timing of fetching data and errors. But with that trade‑off, gives us the potential for better performing apps, as well as ones that are easier to build and maintain. Suspense and data is something that Meta has used for a long time with their Facebook website. I expect it will continue to improve over time and well into the future. It uses Suspense almost exclusively for all its async needs. If it's good enough for Facebook engineers and their huge site, it's probably good enough for us also.

Implementing Enterprise App Features Involving Data
Introduction
You can think of this module as a book of short stories all centered around adding more enterprise capabilities to our conference speaker app. We'll start out by adding basic authentication, log in and log out, that is, to our app, and from there, we'll leverage that towards building some more sophisticated, real‑world app scenarios. Right off we'll extend our speaker interface to allow for a logged in person to favor one or multiple speakers. That's all about processing data with UI events. We'll then work through some examples that include sharing data at different levels in our app. We'll demonstrate how a speaker search bar shares data with a speaker list in order to make that search happen. We'll move on to the often difficult problem of needing to reliably update data to a server, and we'll do that by implementing a modal dialogue for editing speakers. Next thing, we'll upgrade our general site signup from a simple single field form that the browser user types an email into, into a two‑step wizard that properly manages the steps such that the data posted to the back end server is progressively updated. Then we'll look at how to convert the app that we've written that loads speaker data through a REST server to our speakers page to React server components using Suspense. That version will no longer need GET requests from our REST server in order to retrieve data from our SQLite database. That is, you'll learn how to cross that boundary between server and client components with data and without having to create a REST server. Unlike other modules in this course, there is much more code that changes. In order to implement these features, it's not hard React code to write, it's just a lot of React code. To keep your learning time under control, the format I'll follow for each of these short stories will be the same. I'll first talk about the enterprise feature we're going to implement, then I'll demo that feature so you know what's coming in the code, then I'll go through the completed code and explain those changes. The last thing for every clip is i'll show you a slide that has all the files that got updated in that clip. That way if you want to code along with each clip, you can easily make those changes yourself. Let's get started

Adding Login Authentication
If you are building an enterprise app, it's very likely that you will need to include some kind of authentication, meaning login and logout into your app. There are lots of choices for how to do this, and I don't want to make you feel like I'm pushing you towards one in particular. However, for several clips in this module, we do need to simulate a user being logged in to demonstrate different enterprise features. For example, favoring a speaker on the speakers page doesn't mean anything unless you declare who you are as a browser user. Then persisting that data in a secure way to a database or REST server is something important you need to know how to do when working with enterprise data in React. I could somehow simulate a simple login system, maybe store the logged in user as a local state, or maybe even persist that state to either local storage or a browser cookie, but likely anything I do will be half‑baked and probably cause us both a lot of issues. To that end, I think the easiest solution for us is that I make the simplest implementation of a production quality authentication package, and then all the basic authentication will just work perfectly every time. Because Next.js, the framework we are using strongly endorses the authentication package, Next.auth, which is becoming NextAuth.js in the future, I've decided to use that for our sample OAuth system. Before diving into how I installed it and added all the associated React code to make it work, let's have a look at how the completed code runs so you have an idea when I explain all the code how it ultimately will look in the browser. To start out, we have our app open like normal to localhost 3000, which is the home page. Notice now we have a Login button on our navbar at the same level as our Home button and our Speakers button. If I click on that, I get a login prompt. It's prompting me for an email, and then for the password, it says not needed for demo. And then of course, the sign in button, Sign in with Pluralsight Demo App. So I've opened up on another browser tab a list of all the attendees that we've created for this site. Remember, we previously showed the number of attendees favoring each speaker, and this is one of the tables we used for that. I can pick up any one of these email addresses, save it to my paste buffer, and then go back to sign in, paste it in the email field, I don't have to put anything in my password field, and then when I say sign in, I'm authenticated as this user into our app. So what actually happened? If I look at my debug tools and I go to Application and I look at cookies, notice that there are several cookies stored. These all are stored by the NextAuth system in order to authenticate me. Effectively that means if I refresh the browser, the cookies stay, and I'm still logged in. That was the goal. If I log out by clicking the Logout button, notice some of the cookies change and some disappear. Refreshing the page, I'm still logged out as expected. Coming up next, we'll take a look at the code needed to install the NextAuth package, as well as the associated React UI.

Implementing Authentication into Our React App
Let's take a look at the changes we need to make to our app to have it support authentication and specifically the functionality we just reviewed in the last clip. As we discussed, we're going to use the NextAuth package as our authentication provider of choice. First thing is we have to install it. That's just npm install next‑auth. Then we can add the required implementation files we need. Let's navigate back to Visual Studio Code and do that. First in our pages/api/auth folder, we need to add a file named [...nextauth].ts. This is using the older pages router, which works just fine along with the app router, so there's no issue there. Essentially, it's a wildcard route that means anything that's routed to /api/auth gets executed by this file. This file includes a credentials provider section, which determines how auth is going to work. That is, when the user puts in a login and a password, this file is the map of how it's processed. It can have multiple providers, so, for example, you could have Google, Twitter, and your own authentication built in. But for this course, we just have our own built‑in authentication. Here it is in the providers section. You can see our login is defined here as Pluralsight Demo App. That's the title of our login control. And then it takes a username with a placeholder email, and a password with a placeholder Not Needed For Demo, which we recently saw. Then scrolling down in the authorized section, this is where the credentials actually get processed. Notice we're not even using the password, and we're calling Prisma, which accesses our SQLite database attendees to get the attendee record based on the email passed in from the login control. The return includes the id, which is the unique identifier for this attendee record. Assuming an attendee is found, it creates a user object, which has that attendee email and the id and returns it. Then the next section session determines how that user object is encoded and stored as a session object in the user's local browser. That's all that's required of us to make use of authentication in our app. To do something useful, though, we create a NextAuthProvider in our context directory, which essentially we use to wrap any components we want to have access to authentication. Notice it imports SessionProvider at the top from NextAuth, and then any components we render inside this NextAuth provider have access to SessionProvider. In both our home page page.tsx and our /speakers/page.tsx, we have NextAuthProvider as a parent to our Nav and our speakers list. Finally, in our Nav page at the bottom, we add a new call to the component LoginOnNavbar, and looking at that, that essentially gives us our login and logout controls. Notice the href of the login goes to /api/auth/signin, that's from our page's API auth route, and logout goes to signout from the same place. Those are all our changes for the client of our React app, but on the server‑side, that is what gets rendered from localhost:3000/api/speakers. Those REST services also need to have access to our NextAuth API. Looking at the file /api/speakers/route.ts, you can see at the top we get a reference to the built‑in next‑auth API call getServerSession, and then below that, we get authOptions, which comes from our auth provider. And then in the function itself, we access authSessionData.user.id to get our actual logged in attendeeId. Same for the [id] direct REST route. At the top, we have the same imports, and then for the PUT, which is the update, we use the same authSessionData to get the attendeeId when we call updateSpeakerRecord. If you want to make the code changes yourself, here's a list of the changed files and the new files you need to add to this project, or you can just pick up the code directly from the GitHub repo.

Adding Event Processing with a Speaker Favorite Toggle
Enterprise apps almost always have some interactivity that's based on a user logging in and then doing something as that user. That doing something almost always involves event processing in JavaScript, or in this case, React. The interaction we've implemented in this case is favoring a particular speaker by clicking on a hard icon. Notice here we're logged in as Eileen54@yahoo.com, and if I hover over one of these new hard icons, which is what we're going to add in this section and click on it, it changes the 58 to 57 because Tammy Baker was already favored. If I go over to Douglas Crockford, click on that, it goes from 229 to 230. Notice also the heart changes from black to red. If I go to Arun Gupta, watch carefully again. When I click on the red icon, the first thing that's going to happen is a spinning loading icon, and then the number is going to come back with the number of people favored by this speaker. Notice how it changes, but only after the waiting icon. Let's look at how we have to change the code we've written to add this favorite icon and make that happen. Heading back to Visual Studio Code, let's start out in the speaker‑data‑context file. This holds our speaker data provider, which manages all the state updates around speaker data, as well as persisting those changes back through our REST server to our SQLite database. If you remember previously, all we had was speaker state in this context. That is, we managed the speakerList, the loadingStatus, and if there was an error, we track that. Now we've added three more methods, updateSpeaker, createSpeaker, and deleteSpeaker. These methods are completely defined here in this code. If I scroll down to the bottom, notice we've assigned them to the value that we pass into our SpeakerDataContext.Provider, and that essentially is what gives us access to these methods in all our React components this provider surrounds. If we look at our speaker‑detail React component, this is the speaker card that displays the speaker record. To that we've imported SpeakerFavoriteToggle, which is a new component that displays the toggle. Scrolling down, you can see we've added it right above our speaker first and last name. Looking at that component itself, this component has its own state, loadingStatus, which is used to track the change of the SpeakerFavorite icon. It gets a reference to the speaker details with useSpeakerDataContext, and also the new updateSpeaker method that will get called when the browser user clicks on a SpeakerFavorite icon. Notice here in the onClick code, a new speaker record state is calculated, the loadingStatus of that particular card, that's the local component state here, is set to loading, then the new method updateSpeaker is called, with the first parameter being that speaker record and the second parameter being a completion function that when updateSpeaker finishes, it calls, and that changes our loading status to success. You can see in this flow how immediately after the user clicks on the icon, it changes to loading, and then there's a delay while updateSpeaker does its work, and when it finishes, the loading icon is reset and the new speaker count is displayed, and, of course, the new speaker favorite status, too. Lastly, we need to fix the problem of our speakerList state changing order. Sometimes when we update data, we may add it to the beginning or the end, and the original displayed order could change, which would actually happen in this case. To fix that, we go to our speakerList component and just do a force sort before we redisplay the data. Originally, the data was sorted from the database. Now it's still sorted from the database, but because state updated, that order may have changed, and this just forces the sort again. If you're coding along with me, here's a list of the new files and the changed files you need to get from the GitHub repo to make these changes. You can also get the full directory there and continue on.

Nested Context Providers and Implementing General Search
When building enterprise apps, that often means the apps have many components. Those components have relationships to each other as both parents, children, and also siblings. In order to best communicate data between these components, you can follow the prop drilling pattern, which has you passing props, both down as attributes into receiving props of components and up by calling functions using values and closure, but that often just leads to problems down the road. React Context is one way to help mitigate this problem. There's two things it does for us. The first is it allows you to create global variables of sorts that are available to just parts of your app, specifically the parts of the app that you wrap with context providers. The second is it allows you to nest context providers in a way that provides access in a way that you design. How we're going to expand our speakers app to show this is we're going to add a search bar above our SpeakersList component, and that search bar is going to share the value that's typed into it. Then that value is going to be shared with the SpeakerList, giving it the ability to filter what's displayed. Obviously, this is a very simple example, but you'll get the idea. Let's take a look in Visual Studio Code of the changes we've made to make this context sharing happen. Let's start out by looking at our speaker‑menu‑context. That file contains the component SpeakerMenuProvider that we wrap around the components that we want data shared between. Notice this only has one local component state that tracks in that search text. It does it the standard way by passing a value to the provider itself that contains searchText and setSearchText. Looking at our speaker's route in /speaker/page.tsx, you can see how we're using it. We've surrounded both SpeakerMenu and SpeakerList with the SpeakerMenuProvider component. That's because we only need access to the search text in those two components. We don't, for example, need it in our Navbar, which is one level up, or our header, which is multiple levels up. Looking at how we access it, first in SpeakerMenu, as expected, we call the hook that's built into that file that contains the provider, useSpeakerMenuContext, and we get the two values. The only place they're used is in the onChange event of the input field, which is the search value we're actually typing. Then looking at SpeakerList, we only get the search text itself because we don't need the setter, we're just using it as a read‑only field of sorts. And then we update the code we had before, which simply did a sort to now do a sort and a search. We do that by creating a new hook, useSpeakerSortAndFilter, which we've put in our hooks folder, and you can see that just brings over the previous code for sorting and adds a filter for the searching. Notice it also has no state. It's just a simple function that takes in two parameters and returns a single value, the SpeakerList. Let's go back to the SpeakerList itself. Something also to mention, notice we are calling this hook before we do our conditional checks on loadingStatus for both error or loading. If for some reason, we were trying to optimize this, like we thought this calculation would just take a lot of work, we would move this to below the code that does that checking. We'd get a rules‑of‑hooks error saying that we use this hook after we called a conditional. Clearly we violated that rule, but there's absolutely nothing wrong with using this hook like this because in the hook, there's no call to state. UseContext actually is the same way. You can use useContext and violate the rules‑of‑hooks and everything will work fine, but none of us likes to see syntax errors, so let's just put it back to where it was. That's all the code changes we need. If you want to make these changes yourself, here are the changed files, along with the new files you need to add to your project, or you can just pick up the full folder in the GitHub repo.

Implement Modal Dialog for Updates
Another typical scenario that comes up when building enterprise apps is being able to do modal edits. Modal, meaning that some action on your app is going to cause an interface, typically a form, to pop up, then the current interface that you were working on is either hidden or just unavailable. After you've done whatever you need to do in this modal interface, maybe it's editing a document, you need some way to either cancel that or save it, and then get back to where you were originally in the app. This often requires both styling, in our case, we use Bootstrap, and it also requires logic to make this happen. Let's look at our conference app and see the modal interface that we've implemented and the special features that are React‑dependent and UI‑dependent that make it special. Notice now we have an Edit button and a Delete button on each speaker, and we have an Add Speaker button in our toolbar. When we want to edit a speaker, say we want to edit Douglas Crockford, we would click on the Edit button, and notice how the background got dimmed and the focus is now on a center dialog that popped up. In this case, like I said, it's a form. We make our changes, so, say, for example, we rename Douglas's first name to Doug, and then any other changes we might want to make. When we press Save, watch carefully as I press the Save button, it changes to Saving briefly, and then when it's done, the modal dialogue goes away and we're back to the app behind it. Adding a speaker essentially brings up the same window where I now can put in a first name like John, and then Smith, and any other details. Again, watch when I press Add, it says Adding, and then when completed, the modal dialogue disappears, and we have our list of speakers. Scrolling down, in alphabetical order, there's John Smith at the bottom. That's essentially it for the modal interface that we're going to build, but there are a lot of details in the React app and how to manage the data associated with this type of interface. Let's now navigate to VS Code and look at the changes we needed to make this happen. Before we really dive into the code, let me explain the basics of how it works. You might think that we're dynamically opening some kind of window and closing it, but we're actually not. What we're doing is we're rendering on all of the speaker pages a modal dialogue and we're essentially just hiding it and showing it at the appropriate time. The data that we render in that window, we store in a new context called SpeakerModalContext. That context includes not only the data that we render, like the speaker's first name, last name, company, etc., but it also includes a modalShow state, which tracks whether the dialog should be shown or hidden. By default, it's hidden. You may be wondering where that dialog gets popped up from. Well, if we look at our page.tsx, that's the route for our /speakers, notice it's always rendered here above the SpeakerMenu in the SpeakerList. The CSS makes it center on the page, and the CSS also makes the background hide and the modal dialog itself show, but fundamentally, it's always rendering. The reason it always has access to data is because our context SpeakerModalProvider is wrapping not only this SpeakerModal, but also the SpeakerMenu, which is where the Add button is pressed, and the SpeakerDetails, which are rendered from below SpeakerList. The modal dialog always has access to all the data that it needs. Looking at the modal dialog itself, at the top as you'd expect, it has some CSS that automatically renders a show‑model or a hide‑model, meaning whether it should show or not, and then it renders the ModalHeader, the ModalBody, and the Footer, with the header basically determining whether it should show Add or Edit. The body includes all the information you'd expect, like the speaker's first name, middle name, last name, along with access to all the setters and getters to update the context appropriately. And the footer, that has the logic and the buttons on it to save or discard changes. Again, that saving is going to be through the modal context, and of course, back through our REST server to our SQLite database. The only other thing to mention is that in the SpeakerDetail card, you can see this is where we render the speaker‑detail‑edit and the speaker‑delete buttons. And then in the speaker‑menu component, scrolling down, this is where we render the SpeakerDialogAdd component. There are a lot of moving parts in doing modal dialogs, but often that's necessary in order to get the detailed edits that you need in your app. Here's a list of the changed files and the new files you'll need to add if you want to code along with me, or you can just pick up these files directly from the GitHub repo.

Create a Two Step Wizard Sign-up Form
Often when building enterprise apps, we find ourselves in a position where we want to collect data from users, but putting tens of lines of data on a single form becomes impractical and users just don't get through it. A solution for this is to create progressively loading forms. In other words, have the user input a little bit of data, then save it, then a little bit more, then save it, and then finally finish. Typically these are called wizards. React using state makes it really easy to add wizards when collecting data. Here's an example of a simple wizard. When we register people for Code Camp, the most important thing we want to know is their email. There may be other things we want to know, but we don't want to lose their email because we asked them 10 other things and they just never finished the form. This is how we've changed our form to now be a wizard. We start the same by entering the email address, RonReagan@WhiteHouse.gov, and now when I press Subscribe, it says Subscribing, but the second part of the wizard comes up prompting me now for the first and last name. Keep in mind that we've already added RonReagan@WhiteHouse.gov to our database. If the user abandons at this point, we still have that. However, and hopefully they go on to finish by typing Ron Reagan into the new fields, this is basically the second step of the wizard, and then when they press Update, it says Updating, and finally, it says Subscription updated successfully. Press OK, and we're back to where we started. You can imagine this could be a lot more complex, but this is basically the pattern that's followed when creating enterprise wizards. Heading back to VS Code, let's look at the only changes we had to make for this to happen. The file FooterSubscribe is the only file that needed changing. Notice now we have some new local component state, including firstName, lastName, and most importantly, currentStep. Notice currentStep is of type Step, and it only allows STEP1 and STEP2. Scrolling down to the code above the render, you can now see we have an if statement that does certain things if it's STEP1, certain things if it's STEP2, and then finally, in our render section, we render differently if it's STEP1 first, if it's STEP2. There's nothing particularly complex here, and you certainly could make this cleaner by separating out the steps into their own individual components, but I think you get the idea. Progressively updating data into the database is a really good way to go when you don't want to lose information from a user and better control that flow. To update the site to use this new wizard, the only file you need to update is footer‑subscribe.

Animating Loading Status Rendering
What our browser users see when data is in a pending state is totally up to us. Currently, we're not being very creative by showing "Loading...". In most enterprise apps these days, when an app is loading, you'll see some sort of animated gradient that looks similar to what the data that's meant to be rendered is. There are lots of ways to create those sort of loading displays, and certainly one of the easiest is just to use CSS and animations. So that's what we'll do. Here's a quick look at what our app will look like after we've made just a few updates, coming up next. Notice the nice gradients transitioning, and then the speaker data loads. No "Loading...". Let's switch over to Visual Studio Code and see the changes that made that happen. If you remember previously, our loading message was just "Loading...". Now, when we look at SpeakerList, instead of returning "Loading...," we're returning a new component, SpeakerListPending, based on the same loading status. If we navigate to that component, all it does is it renders five new SpeakerDetailPending components, which are used to display an animated gradient. Looking at that component, it's practically a copy of our normal SpeakerDetail component, but notice the class definition bg‑gradient‑pending‑text. Also notice there's some Lorem ipsum‑type character space holders, and that's just to make the spacing of the images approximately right. I don't normally show CSS, but in this case, if we browse to our site.css file, you can see some of those classes, as well as the keyframe animation that makes it happen. Notice here, we're cycling indefinitely every 1.5 seconds. We only have one file changed and two new files, so if you're coding along, make sure to bring these into your project or just copy the GitHub repo directly.

Loading Data with Server Components and Suspense
Currently in our app, we're getting our data for speakers from a REST server, and then we're rendering that after the appropriate page lifecycle events and React client components to our user's browser. If our app were to render a server component from the start rather than the client component it's rendering now, we would be able to retrieve the data for our speakers directly from Prisma and the SQLite database and not have to go through a REST server. Right now, we'll build that scenario out exactly. That is, no REST server for getting our data will retrieve it directly from Prisma and SQLite. We haven't talked a lot about server components versus client components, and I'm expecting a basic understanding. You're welcome to follow along, but if you want more details, I suggest you take some time and review the course Server Component Fundamentals in React 18 here at Pluralsight. So let's now go to Visual Studio Code and look at the changes we make to our current app to support server components in Suspense. Specifically, we'll change how our SpeakerList loads and renders from using a REST server and a GET request to going directly to the SQLite database. And for rendering, instead of using loading states, we'll use Suspense in fallbacks. Let's start by looking in our speaker's route at the root component, which is page.tsx. Notice there is no use client at the top, meaning this will default to being a server component. Notice also, we've restructured the rendered components to instead of directly rendering the SpeakerMenu and the SpeakerList, we've now put them in their own component, SpeakerListContainer, and we've wrapped that in a new Suspense component with a fallback to SpeakerListPending. That's the same component we just showed that rendered the nice new animated gradients. So let's take a look at SpeakerListContainer. Again, because it doesn't show use client at the top, this is also a server component. If you want to retrieve async data in a server component, you need to add the async keyword to the function definition, which is what we have here. Notice we're calling authSessionData. That's a call to the NextAuth library that gets us our logged in user when we're running on the node server. Then immediately, the next line is const speakerList = await getSpeakers. Again, since we're running in the server, this getSpeakers is calling directly to Prisma, which calls SQLite to get our data. Here's the real difference. Previously in our SpeakerDataProvider, we had a useEffect hook that essentially called our REST server to get the data, set the appropriate loading states, and then render the data. With server components, we don't need to do any of this. Notice that we got our speakerList data directly from the database, and then we just pass it in to SpeakerDataProvider as an attribute. What's very important now to notice is that if I navigate to SpeakerDataContext, which is where SpeakerDataPovider renders from, we now have at the top a use client, so effectively, we've transitioned from a server component to a client component, and we've passed the SpeakerList to it. That's very important because we're no longer passing between functions in‑browser memory. That past attribute and then receiving prop here has to be serialized and deserialize to get it to this component. That really is the magic behind React server components talking to React client components. Scrolling down in this context, we have our React component. Remember now, this is a client component. And it takes in speakerListInit as a receiving prop, and that is our SpeakerList. Notice right here at the top, we define our own local component state with useState, and we assign it initialState, which includes that passed in SpeakerList. That means that when this data context renders, it's guaranteed to have the list of speakers, so there is no useEffect call needed to load the speaker data. Now, when we navigate to the bottom of this file, notice we're returning as the value of this SpeakerDataContext.Provider the same as we did before, but we never had to load speaker state. It just got passed in, and it's passing through. This means now when our SpeakerList actually renders because it's surrounded by Suspense in our page.tsx file, the rendered data in SpeakerList will be immediately available. The Suspense boundary will now be providing the fallback, which is our animated gradients we programmed earlier. That's basically everything to make this server component work in Suspense boundaries. To help understand the changes, let's go through a brief div of the previous clip to this one. Starting out in page.tsx, notice at the top on the left side, that's our old code, we had use client. On the right side we don't, as this is a server component. And then notice in the main render, instead of rendering the SpeakerDataProvider and its children, we're now rendering SpeakerListContainer with a Suspense element surrounding that with the fallback to our SpeakerListPending component. Looking at SpeakerList, this is our transition from server component to client component, so we need to add to the top use client so React knows this is a boundary. Notice also how we don't have to worry about our loadingStatus. All that code is removed now and we just go straight from the component function definition right into rendering. That's a big win. Looking at speaker‑detail, again, since this is rendered from SpeakerList, we need a transition to a React client. And then the only other change is the SpeakerDataContext itself. Notice how we don't have in our SpeakerState a loadingStatus or an error anymore because we're not tracking this here. In scrolling down, the biggest change is that we literally have no useEffect necessary in this code. The useEffect on the left completely disappears. That's basically it for all the changes. Here are those changes, and like usual, you can get those from GitHub repo to bring your project up‑to‑date.

Takeaways
Often when building React apps, we follow patterns to do things that we do over and over. Throughout this module, I hope you've learned along with me several patterns that you can use to make your apps better. Many of the implementations here are clearly not the only way to do what I've done, but it's a good starting point, and hopefully it will spur you on to think about how you might do it better or in other similar situations, how you might follow patterns like this. Coming up next, we'll embellish many these patterns by replacing the calls to REST services like we've been doing all through the course to calling server actions. You'll see how, in many cases, server actions can be a lot simpler than working with REST services. But keep in mind, this requires that you have a node server to do this.

Updating Data with Server Actions
Introduction
Assuming you have a node server as the back end for your React app, server actions are an ideal way to communicate from the browser to any services, including things like databases that are running on that node server. The reason is because node is JavaScript‑based just like your browser, and passing data from the client to the server is practically trivial. You can call JavaScript functions inside your node server in practically the same way you would call functions locally in your browser. The big restriction is you can only pass and return primitive types like strings, numbers, and Booleans. Passing functions in complex JavaScript objects just doesn't work. That is still pretty awesome. In reality, though, there is still a network layer that has to be traversed to get from the React app in the browser to the server. The beauty of doing this with server actions is that layer has been abstracted away and it feels just like we are calling from one JavaScript function to another. There are two fundamental ways to call server actions from a React app. The first and most common is to use the HTML form element. When the form element is processed by React, its action attribute is overridden so that instead of posting data to a form, like what happened if you passed a string to the action element, instead, you pass as a JavaScript expression in curly braces an action method name, and then that new server action can run on your server and receive posted form data directly. The second way, which is often used, is to call server actions directly from React client components. Typically, you call server actions from inside events, like button clicks, or page lifecycle event methods in React, like the function passed in to useEffect. This is often more convenient than having to worry about posting form data. For this module, my plan is to start out with a single component running in the browser, meaning I've put use client at the top of the page.tsx file. I'll then have that component process just a simple form that uses the form action string to send data to a server that is not using server actions at all. Then following that, we'll step‑by‑step improve that, not only to use server actions to send form data, but also implement many of the great features that React gives us with server actions. That includes how to make sure the browser UI shows pending when data has been submitted, but the async event has been completed, and also how to handle errors gracefully that come back from server actions. We'll then take a look at how to call server actions directly from inside React client components. The example we'll create is to dynamically validate an email address to make sure it's not already been submitted to the server, and if it has been, we'll send an error quickly to the user's browser UI. To ensure that the data sent from your React client to the server action, either through a post or by calling it directly, is valid, we'll use the open source package Zod, which is commonly used in React apps like we're building, and I'll explain some of the most common processing techniques that are used. Before ending the module, we'll go back to our conference app and replace all the existing REST processing with new server actions that we'll create. In other words, by the end of this module, we'll completely remove the REST server and all the communication to our back end database will be through server actions.

Form Action Basics
Let's head back to our conference app in Visual Studio Code and create from scratch a new route that we'll build out as an example of a React form whose action will create a new attendee. That is, the form will take a first name, a last name, and an email, and then add that to our SQLite database using Prisma. This will be the first time we'll be doing this without using a REST server, but instead with a new server action that will create from scratch. Okay, here we go. Since we're using the app router and not the page router, let's create a new folder in our src/app directory and name it server‑action‑example. In that folder, put page.tsx, which holds the default exported component that will render it localhost:3000/server‑action‑example. Scaffold out a simple Bootstrap container, and in that container, put a form with the action attribute set to /api/attendee. This is just basic HTML that says that if we have a button with type submit, any relevant input fields will be posted when the user clicks it. So let's code the form. First the Submit, button which will be at the bottom. Then, let's add three input fields, all with labels. The first one will be the first name. It includes a label and then an htmlFor attribute that points at the input field for first name. The second is similar. The only difference is it's last name. And the third is the input field for the email. Notice we have type=email. That tells the browser to validate this input as email before submitting it. Let's take a look at our form running in a browser. To bring it up, we browse to server‑action‑example, and that gives us a nicely formatted Bootstrap form, adding a first name, a last name, and then at first let's put in a bad email address. Pressing Submit, we get a basic check like we'd expect, and no submit action happens. Fixing the email to something reasonable, pressing Submit again, and the action attribute on our form tag sends us to the URL /api/attendee with the input values encoded in the URL. We can change that behavior with other form attributes, like method, for example. But for the purpose of this course, that's not really important, as we are going to change how that action behaves, and specifically how we can use it to redirect the submit to go directly to a server action running a node.

Comparing Server Actions to REST
Before we dive into the code associated with creating a simple server action that processes our form, let's talk a little bit about how we might have solved this problem before server actions, and then just briefly how that changes. Before, based on what we've learned so far in this course, we'd be using the REST API built into this app, and specifically, we'd be making asynchronous http fetch requests using the REST protocol method POST to our URL /api/attendees. Then that REST server would process the request. That means having code that would recognize this as a POST, extracting the form data, and then doing the SQLite database insert with the passed in values. We'd not be done, though, because we'd still need to pass back a response to the browser's fetch request. The async code in the original request would have needed to register a callback of some kind, typically using a promise completion or possibly just async/await, and then when that response got received back, it would need to be processed. For server actions, it's much simpler. In our React component, we simply reference the name of a server action in our form elements action attribute. We do that using a JavaScript expression instead of a text ring; that's how React knows it's a server action. And then in the action itself, we extract the passed in form parameters, and then do the database update directly to SQLite. In both cases, I skip the Prisma ORM, as the steps are the same. I won't spend any time here coding the REST scenario, but I assume you get the idea. Let's move on and code the server action to do the SQLite insert we've been talking about.

Responding to a Form POST with a Server Action
Because this is a server component, and we know that because we're using the app router's page.tsx, and there's no use client string at the top, there is an abbreviated way to create a server action directly inside this server component. Before I go any further, let me express my opinion that this is a really bad idea. I'll expand on that in a moment, but I want to be clear from the start that I believe server actions should never be created inside a React server component like this. They should always be in separate files. Okay, enough complaining for now. Let's do it anyway, though, because guaranteed you will see this done a lot in the Next.js docs, the examples people write as tutorials, as well as I'm assuming production code that you'll run into. So here we go. At the top, we can simply create the server action by declaring an async function inside a React server component. I've named it addAttendeeAction, as we want it to perform just one simple task, and that's to add an attendee to our SQLite database. That is the one that will get posted from the form below. This method takes a single parameter, and that's of type form data, which means it's a simple collection of keys and values that represent the data from the form. Here is the very important string you must type at the top of every server action. It's just "use server" in quotes. This tells React at this point we are transitioning to a server component, and in this case, a server action .What's really important to remember is that this function is not going to be called in the same way you might think. That is, if this were just a JavaScript program, which it certainly looks like it is, you should be able to pass completion functions, complex objects, and anything else you think of that's a valid JavaScript object. However, you can't. You must pass only data that can be serialized, and that means just things like JavaScript primitives. This is the primary reason I don't like the idea of putting this server action embedded in a server component. It's just hard to understand what is really going on. Coming up soon, we'll move this server action into its own file, and I'll be done complaining. Now, we can simply write the Prisma SQLite code that does the database insert. Remembering that the code we are looking at here is purely running on the server, that means we don't have any way to show whether what we've done succeeded or failed. All we can really do is redirect the response to a different URL. If we had checked for errors, which we didn't, we could redirect to an error page, but in our case, we're assuming success, so we want to redirect to a success page. We could include in the redirect URL special parameters, like the new attendeeId, but in this case, let's just redirect to a page that will show the top 10 attendees sorted in reverse order of creation date. We'll code that momentarily. The last thing to do here is to replace the action attribute value in the form element with the name of this new server action addAttendeeAction. Of course, we do need to add the proper imports at the top, so let's do that. As I said a moment ago, we do need to create a new page that shows our attendees, so let's put that together quickly. Let's create a new route and folder for it named app/server‑component‑example, and as usual create the file to hold the default exported component page.tsx. Start out by making the same imports as we did before. And then because we don't have use client at the top, this will continue to be a server component. Scaffold out the basics, which includes making it async because we are getting our attendees directly from Prisma and SQLite, and we'll use await. Render a Bootstrap table, and at the top, create a link that takes us back to our server action form we just created, and continue coding the rendering section starting with the table header columns. For the table body, map over the attendee records, one per row, and then render all the columns. That's it. We have a simple React server component that has a single form, as well as an embedded server action, and we have a dedicated URL that lets us see our top most recently added attendees. Let's see how we did. Bringing up the form, enter George Bush as the new attendee, giving him an email at the White House. And then when we press Submit, immediately George is added to our database, and we are redirected to our new server component that renders with George at the top.

Separating Server Actions into Their Own Files
It's easy to pull the server action code that we embedded in our React component in the last clip out into its own file as an export and then import that back into where it's needed. You still need to include the use server string at the top, as this is still a transition point to a server action, but otherwise, it just makes a lot of sense to have the single purpose action available as its own dedicated entry point. Something we've not talked about yet, but will coming up shortly, is calling server actions from React client components. Except for the very rare case where you don't have JavaScript running on the user's browsers, there are not that many times you need to call server actions directly from React server components. We'll talk later about the benefits of doing that. There are plenty. For now, let's just do the coding work to extract the server action. The naming convention I like to use for creating dedicated server action files is simply append the filename where the server action is called with the words server action. I can see as things get more complex and you want to reuse your server actions this strategy will need to change, but for now it's a good starting point. Since our current server component is in the file /app/server‑action‑example/page.tsx, let's create a file next to that in the same folder named page‑server‑action.ts. Note that server actions are not React components or even hooks. They are dedicated functions that take in parameters and return values. Those parameters and values need to be serializable, and of course that code needs to run in the node server. Let's go back to our original page.tsx file, copy out the code that is our async server action, and then copy it back in to our dedicated file we just created. Move that use server string to line 1 where it belongs in a dedicated file like this, and also add the export keyword to the function definition so that we can import it back into our page.tsx later. Add the necessary imports at the top, and basically that's it. We've now got a server action in its own file that we can call from either React server or React client components. Going back to page.tsx, we can remove all the existing imports, as they were used by the server action only, and then add back the single import for our newly created server action. Our code will work exactly as it did before, but with the benefit of having the server action in its own file.

Calling a Server Action from a Client Component
The title of this clip is Calling a Server Action from a Client Component, but that's not really the point. The point is that we are taking advantage of React client components in general and their ability to process events on a browser while at the same time calling a server action. Why do we need to do that? Let me show you. Since SQLite is running directly on our local computer here, there is practically no delay when clicking the Submit button that adds a new attendee, and then the attendee list displays. What happens if the node server is far away and may be a little busy? Let's simulate that by adding a 3‑second delay at the top of our server action. Go to the browser, enter another attendee's data, and watch carefully when I click the Submit button. The orange flash will let you know that I did that. Clicking it now, nothing, nothing, nothing. And then the list appears. For that nothing, nothing, nothing time, the browser user got no feedback to let them know that a submission was in flight to the server. There's really no way for us to fix that when all we have are React server components and react server actions in the picture. We can, however, fix that by refactoring our Submit button into its own component. That page.tsx renders, and we can make that component a client component. Because it will now be able to process events, we can track the status of the submission and give the user feedback as to what's happening. Let's do that. Navigating back to page.tsx, let's take the three lines of code that are our button and put them in their own component, which will be a client component. Copy them into a paste buffer, replace them with a new call to Submit button, import that as if it already exists in the same directory as we're in, and then let's create that new file, submit‑button.tsx. Since this will be a client component, on the first line, put use client. This basically creates that transition from the server component page.tsx to this component. Scaffold out that component as just SubmitButton, and then for the return paste in the button code we copied from page.tsx. Going back to our browser now, putting in a new attendee and pressing Submit. After 3 seconds of waiting, we get exactly the same behavior as we did before, but now we have a client component that's not really doing any client interactions yet. Because this is a client component, we can use React hooks in it. There's a new hook from the React library, useFormStatus, that will help us. Something important to mention is that useFormStatus is marked as experimental in the React 18.2 docs. It is part of their Canary release, which allows framework vendors, like Next.js, to include it in their releases as production. So in Next.js 14, useFormStatus is fully production. Let's import that from react‑dom. Now above our return, call it, returning pending, which will allow us to track whether the server action is processing or not. Add the aria‑disabled attribute to the button so that once the button is clicked, it will automatically be disabled until it's finished processing. That will keep someone from clicking it twice. And then replace Submit with a JavaScript expression that says either "Adding..." or "Add," depending again whether the post is in flight or not. Now let's try adding another attendee and see what we get. Pressing the Add button, notice immediately it changes to Adding, and though it's not obvious, the button is disabled. And then when it's completed, the list shows just like before. The good news, though, there's no more nothing, nothing, nothing, and the browser user always knows something is going on. That's a win!

Returning Data from Server Actions
Right now, after the new attendee is added to the back end, SQLite in our case, we immediately redirect the browser user to a new page that shows the top 10 attendees sorted by creation date, which means since we are the only ones running the app, the new record will always be on top. Clearly, this is not a production‑type solution for a conference website. Multiple browser users could be signing up at once, and we don't want to expose our attendee list publicly like this. There's most certainly a better solution. Getting data back from our server action is the solution we'll implement. We're here starting out in our React server component page.tsx that renders our attendee form. Currently, we are calling our server action, addAttendeeAction, and there's no way to get any information back from it. It basically is a fire‑and‑forget type solution. Fortunately, the React team has given us a new hook, useFormState, which gives us the visibility into what is happening after server actions complete. It does it by taking our existing server action and returning to us a new server action that we'll use in this form. It also returns us some state from that server action that we can then turn around and also render in this form. Just like with useFormStatus, useFormState is currently listed as experimental in the React dev docs, but as a Canary release, it's available in Next.js in full production in version 14, which is what we're using. Okay, let's code that hook here, and things will become more clear. To start, since we are now going to use a React hook in this page.tsx file, we need to make it a client component, as a React server component can call hooks. So I add to line 1 "use client." Then below that, add useFormState as an import. Before our function return, or render, call it passing in the current server action we are now calling, addAttendeeAction, and also as the second parameter pass in an initialState that our server action will potentially change and return to us. Notice that the return of the call to useFormState is similar to what the call to useState returns. It's an array whose first value is the updated state, return from server action, and a new server action that we need to pass to our form. This is what allows this hook to internally intercept what is going back and forth between the React server component and the server action we are communicating with. Now, of course, we need to replace the action attribute value in the form element with this new returned server action. We're almost done here, but we've done nothing to help the browser user know that something good happened when they click the Add button or something bad. You may have noticed what looks like a syntax error with the red squiggles under addAttendeeAction. This is actually a TypeScript warning that tells us that addAttendeeAction is not being called with the parameters it expected. That's because when we use useFormState, the server action will now have two parameters coming in instead of one. We'll fix that shortly. Let's scroll down, and below the Submit button, let's add some code that checks the state value return from useFormState, and if there is a message property set on that state, then display it. If the message starts with error, then display it as text‑danger, which in Bootstrap means show it in red to indicate in error. Again, the red squigglies are TypeScript errors because we've not yet coded our server action to line up with our call here. That's everything for our React client component that renders the form. We do need to modify the action itself now that we are including usedFormStatus, so let's head over to the action and make the necessary changes. First thing is now instead of just a single parameter coming into this action, we have two. The first parameter is a state value that comes to us from the server action. What it does is it allows the server action to return data to us that we can use as state in the form. One use case is for browser users who don't have JavaScript enabled in their browsers, which admittedly is not very many. Another more valuable use case, and the one we will show coming up, is telling the form what to re‑render when there is an error. That is in our case, if the user successfully submits the form, we want to clear all the existing input fields, but if it fails, we want to only clear the ones with problems. The second parameter is what used to be the first. It's just form data, and that has all the input field values. Let's move on to the code itself. Instead of a redirect at the bottom to a new page, let's replace that with a return that returns an object that includes all the previous state properties using the spread operator and appends another property message that says the attendee was added successfully. Are we done? Well, almost. Let's also handle the error case when adding the attendee failed for any reason. To catch that error, we wrap the Prisma create in a try‑catch loop. Then in the catch, we check for the error, and if one occurs, we return an appropriate message. Because in our Prisma data model we declaratively say that the email address must be unique, because of that, we can count on the database rejecting any insert with a previously existing email. The code I've got here in the catch specifically looks for that unique constraint violation, and if that's the error, it assumes it's from a duplicate email add. Otherwise, the message is generic and just says an error occurred. And finally, scroll to the top and fix our imports by adding Prisma, which we use to look up the error and also remove the redirect, as we don't need that anymore. Let's see how we did. In our browser, type in a new attendee, press the Add button, and sure enough, we get a nice message confirmation right on this form saying the attendee was added successfully. But wait, wouldn't you have expected that after we added all the form fields would be erased so we could add another attendee? Coming up, we'll see how that first value we passed in previous state can help us do that.

Revisiting React Form Basics and Clearing Data
After pressing the Add button when entering a new attendee, and it succeeded, why did the form fields first, last, and email not clear like we would have expected? Well, the reality is we should not have expected those fields to clear. That is, there is no code in our component here to clear those fields. Let me prove that to you with a simple React example. Let's create a new root component in a folder /src/app/generic‑form/page.tsx. Make it a client component, and scaffold out a really simple form with no labels or formatting, just three fields and a Submit button. That Submit button will just simply create an alert. Browsing to this new component, typing in some data, pressing Submit, we get the alert, and the fields don't clear as we should have expected. These input fields are basically uncontrolled, meaning that we are basically telling React to let the DOM handle them directly. There is no code here that tells those input fields to clear. We could create local component state for each of the fields, giving them each setters and getters, and then add to the handleSubmit code setters that would clear these fields. That would solve our problem. That's exactly the solution we will use to fix our own addAttendee form in our conference app. It gets a little tricky when we're working with server actions to keep track of when to clear the fields and which fields to clear, but nothing we can't handle. Let's go back to our server action example and make it happen.

Returning Success and Errors from Server Actions
We are back in our conference app, and the add a new attendee form component where the form did not clear as we wanted. But now we understand why. To fix this, we need two things to happen. First, we need to update our server action to return to us updated values of state so that we can set new values to our input fields. And second, we need to update our form such that all input field values are controlled by React so we can set them to these new return values. Let's start out by updating the server action. Navigating there, then scrolling to the bottom, that's where we return our successful add attendee case. Notice we are returning all the passed in previous state properties using the spread operator, and then appending a new one assigned to the property message that says attendee added successfully with the name included. Since the attendee did add successfully, let's replace our return state values with an empty string for first, last, and email, basically telling our form that we want those fields cleared. Hopefully that makes sense, though keep in mind we've not added any code yet to our form that will make this happen. Let's first finish some more updates here to this action to make it even more robust. Scroll to the top, and to keep things consistent with TypeScript, let's enhance our previous state type to include first name, last name, and email. Then let's think about the case where the unique constraint is violated and report back to the browser user that we only want the email input field cleared and not the first and last names, as likely they are both still good. To do that, for the email constraint violation, add to the return state the first and last names passed in to this action, and the email set to an empty string. How about the other error, the generic one? Let's say our connection to the database failed, and we want the user to try again. Last thing we want to do here is clear the three fields and make the user type them all in again. Better to show the user the error and pass back the typed in data in all three fields passed in. We follow the same pattern as before, but this time we pass back email, also. Now we're done. Our server action is much more robust and better able to support the form component. Let's go back to that component and update it to handle the state passed back from the server action. As of now, our form is completely uncontrolled by React local component state. Let's fix that. Let's assume we will use a composite state, that is, a single state value that will hold all three of our input fields, first name, last name, and email as properties. Let's start out by creating a new TypeScript type for that and just call it FormDataType. Then below our call to useFormState, let's create our own local component state and just call that formData, making it of type FormDataType. Initialize it to the state returned from useFormState, which initially is just empty strings for all three values. And also at the top, we need to import use state from react. Now to make the input fields controlled, we need to assign value in onChange to each of them. First, to firstName, then to lastName, and finally, to email. Let's now code our handleChange event. Let's put it above our return or render. It's just a little JavaScript that looks at the name of the passed in fields and their values and then assigns that to the appropriate formData property, which is our local component state. Nothing too complicated. And we could have made three separate local component states, one for each input field, but this is a little simpler. Also, it uses the ChangeEvent type, so we need to add that as an import from React at the top. We're almost done. As of now, there is nothing that makes this form re‑render when the passed back value from useFormState state updates. You might be thinking that because our return from useFormState is state, and because it is changing, you might think the component should re‑render. Well, actually, what causes a component to re‑render is when its local component state changes, not when returned state from other external components is returned to it. So we need to fix that. Easiest way to do that is add a call to useEffect that forces an update to our local component state, which holds our firstName, lastName, and email, and that will cause a re‑render. That does require, though, that we put our state as a dependency array to useEffect, and then when the state changes from our external component, this code in useEffect runs. And of course, we need to import useEffect at the top. Now we should be good to go. Let's refresh our browser, enter a new attendee into all the field values, click Add, and we get our adding message as expected, and when it completes, we get the success message. Notice all the input fields clear, which is what we wanted, we expected, and is now happening. What about the error states? Let's try adding the same attendee again. Pressing Add, waiting for the time delay, and now as expected, we get a meaningful error returned from our server action saying that the email already exists and the attendee cannot be added again. Notice that the email field is empty, while the first and last names remained. Had we gotten a connection error, none of our input fields would have been erased, and we would have gotten an error saying what the problem was. That's it for handling forms. We've taken care of the successful input case, as well as a couple different error conditions. No longer is it necessary to redirect the user to a list of attendees after the add, because now with our new hook, useFormState, we can handle in our React client running JavaScript, of course, what the browser user needs to see.

Calling Server Actions Directly
So far, the only way we've seen server actions being used is when we pass them through the action attribute on a form tag. That worked whether the form element was in a server or client component. We can also call server actions directly, just like ordinary functions in JavaScript. But there are a few things that you need to be aware of. First, to call server actions directly outside of a form, you must call them from a React client component, not a server component. Second, any parameters you pass in when calling a server action must be serializable. This is the same requirement we had for form data and for the same reasons. Parameters passed in can only include primitives like strings, numbers, and Booleans, and the same with the return. Third is that since server action calls are async, meaning you have to wait for the server to respond, they always return a promise, meaning you'll likely use await when calling them. If you want to be able to track in your React client component when the server action is in flight or pending, you'll need to include the useTransition hook in your component and wrap your call to the action in startTransition, which is the first parameter returned from useTransition. You can then use the second return, pending, to render some kind of progress indicator while waiting for the server action to complete. We didn't need to do this when using forms and the useFormState hook because the React framework called useTransition for us behind the scenes. A good way to demonstrate calling server actions from client components is to update our attendee signup form. Let's update its functionality such that when the browser user tabs out of the email input field, the browser displays a warning if the email exists in the remote database. The way we'll implement this is we'll listen for the blur event on the email input field, and when it occurs, we'll call a new server action that we need to write with the input field's value, that's the email address, then it will return a Boolean indicating whether the email exists or not. In the browser, below the email address, we'll show an error to the browser user if that email exists. Basically, server‑based dynamic form validation.

Implementing Directly Calling Server Actions
We're back here in Visual Studio Code, and specifically our page.tsx that includes our form for adding attendees. Since we are focusing now on our email field, let's scroll down to that and refactor out that code into a new component. It's very straightforward. We replace all the code here with this call to a new, not yet created component, EmailInput, passing in our formData and handleChange event. Then at the top of this component, import it as if it exists from our current folder. Let's also export our FormDataType, as we'll need that in it. Create it as just email‑input.tsx, and let's scaffold out the exact same functionality we had previously. No changes, yet. So here come our changes. To the email input field, add an onBlur event and assign it the function onBlur. Code that to now just extract the email from the passed in event. As this component needs to show if the email does not exist on the server after it's been typed, let's create local component state called emailInDatabase, and if it's true, show a warning to the user so they know not to press Add. At this point, we have our onBlur event handler to know when the user tapped out of the email field, and we have our email and database state that tracks whether the email exists in the database. Let's create a new server action in our existing page‑server‑action.ts file and name it CheckEmailExistsAction. Just like our other server action, it's an async function, have it take as its only parameter, email, and return a promise of a Boolean. Start out by having it delay for 3 seconds, so we can simulate what it would look like on a real node server on the internet. Then, simply check to see if the email exists with Prisma in our SQLite database. If it exists, return true; otherwise, false. That's basically everything for this server action. Let's now go back to our email‑input component and call it from inside our onBlur event handler. Before calling it, though, we need to import it at the top. Then, we simply call our state setter, setEmailInDatabase, passing it the return of our call to our new server action. That essentially sets the local component state of our app so that if the email exists in the database, we can let the user know. So let's do that. Scroll down to the return or the render section, add a JavaScript expression. That checks the local state, emailinDatabase. And if it finds it, renders an error message right below our input, letting the user know the email exists already. Let's see how we did. Bring up a browser and refresh the page, enter a new attendee, but this time enter one we know the email exists already, forcing the onBlur event to happen by clicking on the firstName field. Nothing happens for 3 seconds because of our delay. And then we get the error, as we expected. We've not added any logic to disable the Add button when the email doesn't exist, so if the user does press that, they should expect to get a server‑side error saying the email already exists, and it shouldn't add. At that point, we know that the email field is going to clear, and we want the email message under the input field to go away because we have a new message from the server that we want to pay attention to. Let's see what happens when we click the Add. After 3 seconds, we get the message we got previously from the server saying the attendee with the email already exists. The email address did clear, as we also would have expected because that's what was happening before, but the message from onBlur, email address exists already, which came from our server action, did not clear. So the way I see it, we have two problems. The first is that when we caused the onBlur event to fire by clicking on the firstName, the email check didn't happen for 3 seconds, and there was no feedback to the user that was happening. The second is that after we clicked the Add button and the server responded, the email address cleared as expected, but the error message directly below email address, it came from our server action checking the email did not clear.

Improving Server Action UI Performance
Let's fix the two problems we identified in the last clip. First, the UI not updating when the browser user triggered the onBlur event. As I mentioned earlier, it's always best to use the useTransition hook when calling a server action so you can get feedback in your UI. Let's do that. First import useTransition from React. Then call it, and it returns an array with the first entry being pending, that means that the request is in flight, and the second, startTransition, is what we need to wrap our server action in. Then what we need to do is in our onBlur event, call startTransition, pass it an async function that calls setEmailInDatabase with the results of our call to the CheckEmailExistsAction. Lastly for this, scroll to the bottom and add another ternary expression that checks for pending. And if it's true, render the message, "Checking email address," right below the email input field. That solves the first problem. The second problem is the message from our onBlur event below our email address did not clear after we pressed Add. The reason is even though our form data changed, specifically, our email changed to an empty string, but our local component state did not update, and hence, no re‑render. The way we fix that is with the hook useEffect. Let's scroll to the top and import that. Then, call useEffect, passing in as its first parameter a function that updates our local component state, setting email and database to false. We also have to add the passed in email to the dependency array of useEffect so that when the email address changes, that triggers the function passed in to useEffect to run. Let's see how we did. Add a new attendee that we know exists already, trigger our onBlur event by clicking on the First Name field. Notice immediately we get a message saying "Checking email," followed shortly by "Email address exists already." That's our first UI problem solved. And then clicking the Add button and waiting 3 seconds, after the add completes, we get our error message as we did before, but notice under email address, we no longer have the warning that the email address exists. That's our second problem solved.

Motivation for Runtime Data Validation in Server Actions
Server actions are somewhat deceiving because they make it feel like when your React JavaScript running in the browser calls a JavaScript function running on a node server that there is no potential for bad things to happen in that call. The reason it feels that way is because in a single programming environment, like either just a browser or just a node server, when you call a function, you always have complete confidence that the JavaScript runtime will handle passing the parameters correctly. That's because both the caller and the function are in the same app domain. So, how should we treat server actions differently than we do calling simple JavaScript functions? Well, we need to treat the data that is coming into a server action from a client browser as suspicious, just like we treat data coming into a REST server from a client browser, also suspicious. We need to verify that the data coming in meets certain validation rules. A good way to have our servers do checking of data passed in is to use a runtime data validation library of which there are several out there. Zod, z‑o‑d, is one of them, and it's the most commonly one used with React server actions, so we'll use that for our demos coming up. There is a lot to Zod beyond what I'm going to show here, but I really want you to get a flavor for how to use Zod in a minimal way, which is likely good enough for most React server action code.

Adding Zod Runtime Validation to a Server Action
We're here looking at the server action file we've been building, page‑server‑action.ts. Let's add Zod to one of these actions. What we'll want to do is validate the data coming in from our form that includes our first, last, and email, which are passed in as part of form data. To begin, install Zod in your app. That's just npm install zod at a terminal prompt. Then, import zod as z at the top of your file, so we can just call Zod with the letter z. Now we can do our validation. Let's add that validation to addAttendeeAction. Scroll down to that function and define a Zod schema, which basically defines all the details about the type of data passed to this server action. In other words, what the schema does for us is it tells us that if the data coming in does not meet the schema definition, then throw an error and don't process it. In our case, the schema is saying we have three required fields. We expect email, firstName, and lastName, and an optional id. It tells us that the email has to be valid, the firstName has to be at least 2 characters, the lastName 3, and the id, if it exists, has to be in the format of a UUID, which is a GUID. Any extra passed in data will cause an error, and any data not meeting this criteria will also. Next step is to use this schema to parse the incoming data. That's just const to parsedData = AttendeeSchema.safeParse, And then we pass safeParse an object that simply includes our data. What's returned is a new JavaScript object that includes some extra information, including the validated data passsed in. Going forward in this server action, we'll use that return data to insert in to SQLite rather than the passed in form data. You can think of this as being more or less cleansed by the Zod schema validation. Let's check to make sure the parsedData.success is true. If not, let's iterate through the results of the parse and return as usual an object that includes the previous passed in state, that way the form can redisplay it, but this time add a message that includes a string which is composed of all our validation errors. Just like previously when returning from our server action, now we can be confident that our data is valid. So we continue, but this time we replace the data that makes up our attendee record that will be added to SQLite with the passed in data spread. Let's see how we did. Bring up a browser, add a new attendee, but this time, let's violate one of the rules, which is the first name must have two characters. Press the Add button, wait 3 seconds, and sure enough, we get our validation error saying the firstName string must contain at least two characters. Since our original data came back in the form, we can simply correct that, press Add again, and after the 3‑second delay, the validated data added successfully.

Replacing REST Calls with Server Actions for Speaker Updates
Coming up now, we're going to replace all of our REST services in our conference app with server actions. We'll also include Zod for runtime validation in all those server actions themselves. As there are a lot of details, I've made all those changes, and momentarily will review a diff of them. But just as a reminder, here's how the app works, now, of course, all running with server actions and no REST services. On the home page, we have our subscribe to STAY UPDATED, so let's add a new person here. Press the Subscribe button, put in the first and last name, and press Update. Now, let's log in with that attendee. Going to the speakers page, you can see we have all our speakers, and, of course, none are favored because this is a brand‑new attendee. If we click on the heart for Tammy Baker, her favorite count goes from 57 to 58. Douglas Crockford, same thing, plus 1. If we were to edit Douglas Crockford, change his name to just Doug, press Save, as expected, it updates. Refreshing the browser, the data is re‑retrieved from SQLite, and the changes stick. This is all now working with React Server Actions and no REST server. Let's head over now to VS Code. The source code has all the updates made to support Server Actions and the REST calls removed. Notice right off, we have two new files that are both actions for the different parts of our program. We have footer‑subscribe‑action. That's what gets run when an attendee subscribes for more information. And we have speaker‑data‑context‑actions. That's basically all the code that was in the REST services and now is in our speaker‑data‑context‑actions. Let's do a diff of this clip versus the last one before the conversion. Open our compare files Visual Studio extension, click on select a folder. We're in clip 150. Let's open clip 140 to compare to. Our Compare folder is the original one before Server Actions, so if we expand that, you can see this is all the REST services that we had before which have been removed from this project. Looking at only in my folder, here are the two new Server Action files we created. Notice footer‑subscribe‑action has Zod runtime validation code in it. Scrolling down, we have addAttendeeAction, which is very similar to the code that we did previously, but just specific around these particular SQLite tables. Speaker‑data‑context‑action similarly has Zod verification at the top. Scrolling down, as you would expect, it has a separate call for each CRUD action, whether that's update‑speaker‑action like here, as well as Create and Delete, also. Now for the files that changed. There's only two changed files. Let's first look at the speaker‑data‑context provider code. Let's reduce the size of the project window so we can see the changes easier. Notice at the top, we import from our new speaker‑data‑context‑actions are three new speaker actions, createSpeakerAction, deleteSpeakerAction, and updateSpeakerAction. Scrolling down to the first major change, some changes are just formatting, notice that in createSpeaker, previously on the right side, we had all this code to call the fetch API to do the proper POST. That was to our REST service. And on the left, all we have is a simple call to createSpeakerAction, passing in the speaker record. That's a lot simpler. Scrolling down to updateSpeaker, basically the same pattern. On the right, the REST call, and on the left, the much simpler call to simply await updateSpeakerAction. And finally at the bottom, for deleteSpeaker, again, same pattern. The REST call goes away, and we simply have deleteSpeakerAction. I know lines of code are not a great metric, but notice on the right, the old code was 260 lines, and on the left, the new code is only 220. I'm sure you could see some of those savings. The other file, footer‑subscribe‑action.ts is very similar. We just replaced REST calls with Server Actions, and we got the same functionality. Those are basically all the changes we needed to convert from REST services to speaker actions. Remember, this requires a node server. And of course, if you're using a different server for your REST services, then you need to stick with REST. But otherwise, Server Actions is a great solution.

Takeaway
Server Actions fundamentally improve the way our React apps communicate with node servers, though there's a lot of other ways to communicate data. If you can use Server Actions, I strongly recommend giving it a try. At this point, it really goes without saying that if you are using Server Actions in your apps, you will also likely be using React Server Components. Combining these two things together allow you to have a full REST replacement for your React apps. That is, you can think of Server Components as the GET and Server Actions as the PUT, POST, PATCH, and DELETE. Because all serialization is done for both Server Actions and Server Components behind the scenes, your life as a developer is just easier. It's not all roses, though. There is a lot of REST servers out there, and a lot of people will keep using them for a very long time. They can be really fast, reliable, well‑documented, and in general, just very mature. Server Actions are new, and there will be bumps in the road, and you'll need to be prepared for those. Also, and just as important, Server Actions are very specific to node as your server. React is very powerful even without Server Components and Actions, and there is absolutely nothing wrong with building pure client‑side React apps that work directly with REST or any other data server.

Course Takeaways
Takeaways
I hope now that you've got a good handle on the types of data interactions you will likely run into day‑to‑day when building React apps. Whether you use REST services to access data from purely SPA, or single page apps, or you use the latest concurrent React features that include Suspense, Server Components, and Server Actions, the fundamentals are always the same. Your app needs to give your users a great experience. Those apps need to be easy to build, and easy to maintain. As always, I love feedback on my courses. Feel free to post to the discussion here in the course, or if you want, you can contact me directly on my blog site at peterkellner.net/contact. I'll get back to you as soon as I can. By way of a thank you to my team here at Pluralsight, first, Tom Bell, Pluralsight's Director of Curriculum, who provides me awesome insights into what's going on in the full JavaScript programming arena; Kim Karnatz, my Project Coordinator here at Pluralsight, who is always available and helps to make sure I have everything I need to make my deliverables on time; Alex Walton, my Production Editor, who always has time to help me through any problems I run into, whether it's Premiere Pro editing videos or helping me improve my audio quality, he's always got the best solutions and generously provides his time to me; finally, Reggie Dawson, another author here at Pluralsight, who is my Technical Editor, making sure that I don't make too much up in these courses. Except for a couple weeks in the middle of building this course where I was a little sick, sorry about the froggy voice, it was a true pleasure building it and sharing what I know. Thank you for watching!