Course Overview
Course Overivew
Hi there. I'm Gabriel McNeilly, a QA automation lead, and welcome to my course, JavaScript Unit Testing with Jest. Do you want to learn how to increase the quality of your JavaScript projects? Do you want to learn how to write unit tests for a range of scenarios, and then learn how to measure and enforce test coverage? Some of the major topics that we will cover include adding Jest to an existing codebase, writing unit tests for a variety of functions, using mocks to ensure tests are isolated and reliable, as well as measuring the code coverage of your unit tests. By the end of this course, you'll be able to write unit tests for your JavaScript code using Jest, allowing you to reduce the number of regression bugs when making code changes. Before beginning this course, you should have some experience using JavaScript, as well as a basic understanding of what unit testing is. So I hope you'll join me on this journey to learn how to write unit tests with this course, JavaScript Unit Testing with Jest, here at Pluralsight.

Writing Your First Unit Test with Jest
Course Intro
Hello, and welcome to this course, JavaScript Unit Testing with Jest. I'm Gabriel McNeely, and I'm a QA automation lead, passionate about everything related to software testing. This course will give you a solid understanding of using Jest to write unit tests for your JavaScript code, allowing you and your team to improve the quality of your projects by making them more maintainable. Firstly, we'll confirm what versions this course applies to. This course was created using the displayed versions of JavaScript, Jest, Node.js, and npm. This slide shows the versions of JavaScript and Jest for which the information in this course applies. When it comes to software development, one of the main challenges is that product requirements continually change over time. Performing more testing when making these changes results in less regression bugs being introduced, and ultimately a better experience for the users of your products. So the challenge is, how do we make those changes while still ensuring that we haven't broken or degraded any existing functionality? Well, we could manually test everything every time we made changes, and that might work when we have a very small application, but as the application grows, that would rapidly become impractical, so the core purpose of unit tests is solving that problem. Unlike manual testing, you don't need to be focused on them. They can be run repeatedly and automatically whilst you are working on other things, so they don't take anywhere near the same amount of time as manual testing. Through this, they help us make changes to our code base by giving us confidence that the changes we have made have not broken existing functionality by confirming that the behavior of our existing code has not changed. Unit tests can also be used with test‑driven development, or TDD. Test‑driven development is a development practice where unit tests are created first and then as little source code as possible is written to make them pass. Unit tests can be a great way, and sometimes even the preferred way, to actually understand what the expected behavior of your source code is. You could think of your tests as the definitions of your business rules, whilst your source code is the implementation of them. Unit tests sit at the bottom of the test pyramid, and so they are the first line of defense when it comes to catching bugs in software. If you're not familiar with the test pyramid, as you go down it, the scope of the tests decreases. So whilst an end‑to‑end test will cover many lines of code, a unit test is focused on testing the smallest unit of our code that we can, which will generally be a function. Normally it is the developer of the code that will write unit tests, and the width of the section indicates that there should be more unit tests compared to any other tests. So as a software developer, if you want to create high‑quality software and release new versions with confidence, writing unit tests is a vital skill. So in this course, we started by briefly discussing unit tests themselves, so we now understand why we should write them. Next, we'll discuss some of the key features of Jest and look at adding it to a project. Then we're actually going to get started writing our first unit tests with Jest. We will then dive in a bit deeper and explore how to select the correct matcher for the situation. Then we will get to grips with using mocks to help us handle writing tests for more complex functions. Then we will explore writing unit tests for asynchronous functions. And finally, we will learn how we can measure the code coverage of our unit tests. So let's get started with Jest.

Getting Started with Jest
Jest has some lovely features that make it such a great tool to use. So before we look at installing Jest, let's just run through some of its key benefits. There are a range of options when it comes to JavaScript testing frameworks, so why would we use Jest? Well, firstly, as we'll see shortly, there is 0 config required to get started, which allows us to just get going writing unit tests almost straightaway. It also has a great API with highly fluent syntax, which makes tests both easy to read and write. Tests are automatically run in parallel and isolated by running them in their own processes, which maximizes performance. It also works with most JavaScript projects, whether they use Babel, TypeScript, Node, React, Angular, or Vue. And finally, it is well documented and has a great number of resources available, along with a large community. This is often an overlooked aspect of tools, but having a large community and good documentation just makes for a much easier development experience. So you are now working as part of the Globomantics development team that has just been assigned to take over the GloboTicket ticketing site. Unfortunately, the previous development team was not following best practices, and so there are very few unit tests, and it is your job to remedy this. So once you've had a look at the site and the source code, your first objective will be to add Jest to the project. So let's head over to the GloboTicket's project. So this is the GloboTicket site. It's a fairly straightforward ticketing site, which allows customers to do things such as view what events are available. They can view details and prices for events that they are interested in and buy tickets for those events. Because we are not actually adding or changing any features, we won't really be focusing on the UI for the application, really, as we aren't changing any of its source code. Our sole aim is to add unit tests to this project so that when we do start adding and changing source code, we can do so with confidence. Now that we've seen the application that we'll be working on, let's look at the site source code. So this is the source code for the GloboTicket site, and we will be using Jest to create and run our unit tests. So the first thing we'll need to do is install Jest. Jest can be installed using npm or Yarn. In this course, we'll be using npm. So in our code editor, we're going to go to the Terminal. We can install Jest using the npm install command. We're also going to add in the ‑‑save‑dev option so that it's added to our package.json as a dependency. If we then view our package.json, we're then going to update the npm test script to run the simple test command. This will allow us to use npm test to run our tests. This isn't essential, but I always prefer to use npm scripts to perform dev tasks like this. So we'll be using npm test to run our tests in this course. But if you add Jest to your path environment variable, you can simply type jest into the terminal to run tests. We'll also discuss the Jest CLI in more detail later in the module. So if we now run npm test, we can see that Jest is running, but unfortunately, we're getting a warning, which says that no tests were found. So how are we going to fix that? Well, we better get started writing some unit tests.

Writing a Simple Unit Test
So we're going to start by looking at the Events area of the GloboTicket site. Specifically, we'll be focusing on the getTagLine function. This function takes in an event, a minimumTicketCount, and a Boolean for whether a lot of tickets have sold recently for the event, and it returns a string which is the relevant tagline to display on the site. On the left‑hand side is the file that contains our source code, and on the right‑hand side is the test file where we'll be adding our tests. So the first Jest function we'll be looking at is the most important. It is how you define a test, and to do that you use the test function. The test function can have three arguments. The first is the name of the test. This should make it clear what is actually being tested. It sounds pretty straightforward, but it is essential that it is descriptive and concise. The second is a function. This is the main part of the test and contains the assertions or expectations for the test. The third and final argument is the timeout. This specifies how long Jest will wait before timing out and failing the test. This argument is optional and defaults to 5 seconds, which is suitable for most use cases, so generally you won't need to use it. So let's create our first test. With this test, we'll focus on this if statement. Our aim will be to validate that it returns the Sold Out tagline when the event is sold out. So we're going to add a test with the name Returns Sold Out tagline when no tickets are left. Now for the second argument, which is the function that will contain the main part of the test. So we're going to need an event to pass into the getTagLine function, so let's new up an event with the following values. For this test, most of the values don't matter. The only one that does is the ticketsRemaining property of the event. This needs to be 0 so that the if statement will be true for our event. Next we're actually going to call the function that we are testing, which is the getTagLine function, and we're going to assign it to a constant. We're then going to use the expect function, and this is another Jest function that you will be using in every single test. The argument to the expect function will always be a value or function that your code produces. It is the value that you want to perform some validation on, so we're going to pass in the tagLine constant. Although you'll use it every single time, you'll probably never use the expect function on its own. When you're writing tests, you'll be checking that values meet certain conditions, and the expect function gives access to a number of functions that are known as matches. These let you validate different things. We'll look into matches in much more detail later in the course, but for now, just remember that they are used to specify what validation you want to perform. So what behavior are we trying to validate with this test? Well, we expect the value of our tagline constant to be the string, Event Sold out! We now have a test that will validate that behavior This demonstrates the fluid syntax of Jest, which is one of the reasons why it's so nice to work with. So now let's run our test. So if we run Jest via the terminal using npm test, we will hopefully see our test passing. But, uh‑oh, something's gone wrong. We've got an error. But luckily, Jest prints out some pretty handy info to help us spot what the problem is. Jest displays the location and test name of any failed tests, which is really handy, but what makes it really great is that it actually also prints out what the Expected value was and what the actual Received value was so we can easily debug failures. So what was the cause of the failure? We can clearly see, thanks to Jest, that in this case getTagLine returns a string that has a capitalized O in the message, whereas our test expects a lowercase o, so let's fix our test by updating the expected string to be capitalized. If we now save and run Jest again, we will hopefully see that the test is now passing. Great stuff! We've just written our first unit test with Jest. So let's just recap the parts of a Jest unit test. We have the test function, which defines a test. We'll then call the function that we want to test. We then have the expect function. Into this, we pass the value that we're going to validate. And then we have a matcher which performs the validation, and in this case it is toBe. This structure is how we're going to write all of our Jest unit tests. The value we're testing and the matcher will obviously vary, though, based on the test case. Now that we understand how to write a simple Jest unit test, let's see how we structure our tests when there are more than one.

Test File Structure & Location
We're now looking at the basket section of the GloboTicket site. And as you can see, there are two functions for which unit tests have been written, the calculateTotal and showAdverts functions. The first calculates the value of the tickets in the basket, whilst the other works out whether to show adverts on the basket page. Now, when we wrote our test in the previous clip, we had our test in the root of our test file, and it's the same for these tests here. This is fine when there's a few tests, but as more tests are added, it's going to get a bit confusing and difficult to tell which functions that the tests relate to without digging into the tests themselves. So what we need is some way to group them, and this is where describe blocks are useful. A describe block has a similar structure to the test function in that it takes in a name and a function. It is generally best practice to have one describe block per function, and to give the describe block the same name as the function that is being tested. So in this case, we now have a calculateTotal describe block and a showAdverts describe block. So all the tests for calculateTotal will be kept within the calculateTotal describe block. Now, as well as keeping things neat and tidy, there is also another very good reason for using describe blocks. Some other important features of Jest unit tests are hooks. These allow us to perform tasks before and after tests. Generally, this will be setup and teardown tasks like reseeding a database or generating some data. They are called beforeAll, beforeEach, afterEach, and afterAll. As the names imply, anything within the beforeEach and afterEach hooks will be executed before and after each test in the file, whilst code in the beforeAll and afterAll hooks will run only once, at the start and end of the test file, respectively. If we take a closer look at the calculateTotal tests, you'll notice that there is some repeated code between them. We create the same events and basket items so we need to do something before each test, so you guessed it, we can use the beforeEach hook to avoid this code duplication. So let's refactor our tests and move this setup part into a beforeEach hook. So we've now reduced the code duplication. But wait, we have tests for our showAdverts function in this file as well. Now these events and items are going to be needlessly created for these tests as well. This is where using describe blocks is really handy, as we can put our beforeEach hook inside the calculateTotal describe block. Now that beforeEach hook will only run for the calculateTotal tests and not for the showAdvert tests. So if we go to the terminal and run the tests for this file, we can see that they are passing, and Jest has nicely grouped our tests by describe block. So to recap, we used the beforeEach hook because we wanted to do something before each test. But if we needed to do something after each test, then we could use the afterEach hook in exactly the same way as we used the beforeEach hook. The beforeAll and afterAll hooks can also be scoped to a describe block. In doing so, the code in the beforeAll and afterAll hooks would run before and after all the tests in the describe block, rather than all tests in the whole file. So we now understand the structure of a test file, but something we've not touched on yet is the test files themselves. They must have .test in their name to be found by Jest. It's also best for the name to match the file being tested. So for the basket.js file, we created a test file called basket.test.js. Then, in terms of where to keep the tests, there are two main approaches, and both have their pros and cons. The first option is to keep your tests in the same directory as your source code file. This keeps your tests close to the code that they are actually testing, but it comes at the cost of mixing your test code files in with your source code files, and can require some extra configuration as your code base gets more complex. The alternative, which we will be using in this course, is to create a separate directory for your tests. The test directories mirror the source code directories, so we would add each file to the directory in the test folder that corresponds to the source code we are testing. So in this case, our test file belongs in the basket directory. Personally, I find this approach keeps things cleaner; however, there is no solid consensus within the JavaScript community as to which structure to choose. Both approaches are widely used, so I would simply advise that if you're working on an existing code base that you follow the current structure, and if you're starting a new project, you choose the one that suits you best.

Jest Configuration & CLI
We've already seen for ourselves that Jest requires no configuration to get started, but another one of the fantastic things about it is that it still has the ability to be configured in various ways. Jest can be configured using a configuration file. Any files named like any of these will be automatically discovered and the specified configuration applied, but you can also pass in a path to your configuration file if needed, using the config option when using the CLI. The configuration file needs to either export an object or a function returning an object or it can be a plain object if it's a JSON file. Alternatively, configuration can actually be specified in the projects package.json using the Jest key. We're not going to focus on configuring specific properties at this point as there's so many properties that can be edited. All the available configuration options can be seen in the Jest documentation at the link shown. We will make use of specific configuration later in the course, but for now all you need to be aware of is that there are multiple options available to specify additional configuration values for Jest. So let's now take a look into some Jest CLI options. Whilst Jest can be run really simply, there are many options that can be used with the jest command line runner. There's too many to cover in this course, but like with the configuration files, all the available options can be seen in the Jest documentation at the link shown. So we are just going to run through some of the ways that we can choose what tests that we want to run. When we run the simple jest command, by default it's going to run all of our tests, which is fine for now, but as a project gets larger and more and more tests are added, you'll get to the point where you are waiting minutes or even hours to find out if the tests for a particular file are passing. So luckily, there's a few ways that we can specify what tests run. We can specify a file name or a full path to a file and then only those tests within that file will run. There is also the option to pass in a pattern and it will run all tests in files that match that pattern. Now we get onto the slightly more clever options that are really handy. We can use the findRelatedTests option to run all tests related to particular source files. It accepts a space‑separated list of files and will run all tests that execute code from the specified files. This is really handy when you've only changed a few files and want to test that your changes haven't caused any regressions. Another option in that situation though would be to use the ‑o option, which is an alias for the onlyChanged option. This option tries to work out what files you have changed in the repo and then runs the tests that are associated with them. So it's similar to the findRelatedTests option except you don't need to pass in the names of the files that you've changed. It does, however, require you to be using some kind of source control tooling, such as GIT, but that's going to be the case on almost every enterprise project, so it's a pretty powerful option to use. And finally, just to mention, if you are running Jest using npm test scripts, you can still pass in arguments to Jest. You simply need to put a double dash at the end and then pass in your Jest arguments as normal. So with our npm test script simply running the Jest command, the command shown here would do exactly the same thing as the command above. Let's now wrap up this module by going over some of the key takeaways.

Key Takeaways
In this module, we covered quite a lot. Hopefully you've gained a solid understanding of the basics of writing JavaScript unit tests with Jest and you are now confident writing some basic tests. We started by discussing the purpose of unit tests. They are an essential part of the development process, as they prevent regression bugs, can act as effective forms of documentation, and can even be used to design a system using test‑driven development. We then looked at the project we will be focusing on in this course and added Jest to it using npm, although Jest can also be installed using yarn. We then looked at writing some basic tests using the test function and went over the key parts of a test. They were the expect function, which takes in the value that we want to validate, normally that would be the value returned by a function in our source code; and then we will have a matcher, which is the function that is used to actually perform the validation. We will dive into them in much more detail in the next module. Then we saw how we can use beforeAll, afterAll, beforeEach, and afterEach functions to perform setup and teardown tasks, whilst avoiding code duplication. For example, if we need to reseed a database before each test, then rather than calling functions that seed some data within each test, we could just have a single call within a beforeEach hook. We also looked at how describe blocks are used to group related tests together and where to keep our test files. And finally, we discussed how Jest can be configured, as well as how we can run Jest via the CLI with some useful options which allow us to control what tests are run.

Exploring Common Matchers
Module Overview
We're now going to look at what are known as matchers. We touched on them earlier in the course, but let's refresh our memory and discuss them in some more detail. Matchers let you validate that values meet certain conditions. So they are essentially just the functions used in Jest to make assertions. You can think of them as the actual test parts of the tests. The great thing about them is they help to facilitate the fluent syntax that makes Jest tests so easy to read and write. In general, if you can think of what the English would be, then you can probably work out the correct matcher. For example, if you expect a value to be undefined, you could use the toBeUndefined matcher. There is a wide range of available matchers. In this course, we'll be looking at the most common ones, but a full list with all the information about what matchers are available can be found in the Jest documentation. As well as official Jest matchers, there are also community‑created ones that you might find useful. So now that we understand what matchers are, in this module, we're going to learn how and when to use some of the most common ones. Don't worry, we won't be starting this module by studying Shakespeare, but we will start by diving a little deeper into the use of to be and not to be, then we'll look at some other matchers that we can use to test equality and how they differ in their behavior, then we'll see how we can use matchers to match patterns when we don't know or care about the exact return value of a function, then we'll discuss how we can test functions that return Boolean values before, finally, we look at what matchers we can use to test that our application raises the errors that we expect it to. So let's get started by asking, to be or not to be?

To Be or Not To Be
If you could all get out your Shakespeare textbooks and turn to page three, that would be great. Only joking. Don't worry, we won't be discussing plays or sonnets in this clip. We'll be diving a bit deeper into the toBe matcher that we used earlier to write our first unit test. So in the previous module, we saw how we could use the toBe matcher for validating that the correct string was returned by the get tagline function. We're now going to look at using get for functions that return other types of values. So we also saw, in the previous module, there were two tests that existed for the showAdverts function and both of these make use of the toBe matcher. We can see that it works in exactly the same way with Boolean values as it did with string values. So the first test is going to validate that showAdverts returns false when the user is a premium user. So we create a user and set isPremium to true. We then have an expect function into which we are passing the showAdverts function, and then we are passing in false to the toBe matcher to assert that the value returned is false, as based on the function's logic, premium users should not be shown adverts. Now if we wanted to reverse the assertion and actually validate the opposite of the matcher, we can add not before our matcher. So if rather than confirming the value returned was false, we wanted to confirm that it was not false, we could add an expect statement that uses not.toBe like this. Not can be used with all matches, so if you know how to test something, but want to test its opposite, then just include not before your matcher. Now let's go and take a look at writing a test for the serializedBasketItemsToJson function. This function takes in an array of BasketItems and returns it as JSON. So we'll start by adding a describe block for the function and a test called Basket items are serialized correctly. We will need to pass in some BasketItems into the function, and we need to create an event to create a BasketItem. So let's create a couple of events and use them to create a couple of BasketItems. So we've now got an array of BasketItems. We'll also need to define what the serialized JSON should be for these items, so we'll add that. So based on the code within the serializedBasketItemsToJson function, this is the expected result if we were to pass in the BasketItem's array that we just created. So we're now ready to call the function itself. We're now going to actually call the serializedBasketItemsToJson function and pass in our items array and assign the result to a constant, just to keep things neat. So now we're ready to add our expect statement. First we'll add the expect function and pass in the value returned by the function we are testing. We assign that value to the serializedItems constant, so we will pass that in. Then we're going to add our toBe matcher because we expect the object returned from the function, serializedBasketItemsToJson, to be the JSON object we defined above. So now let's run our test. If we save and go to the terminal and run our tests, we can see our test is actually failing. This is because of what validation the toBe matcher actually performs. It expects the object returned by our function to be the exact same items object that we defined. We are actually comparing a class instance, which is returned by a function, and a literal object, which we defined as the expected result, so the toBe matcher does not consider them to be equal. So how do we solve this using the toBe matcher? Well, the short answer is that we can't, so maybe we'll need to find some other ways of testing equality.

Testing Equality
In the previous clip, we encountered a problem with the toBe matcher. It worked great when we were validating primitive types, but now that we are writing tests for the serializeBasketItemsToJson function, which returns an object, it's no longer suitable. So let's update our expect statement to include not before toBe, and that should now pass when we run the test. So how are we actually going to test that the JSON returned by the serializeBasketItemsToJson function matches the JSON that we defined with our itemsSerializedToJson constant? Well, we can use the matcher, toEqual, instead. So let's add something for that. The toEqual matcher will recursively compare all properties of two objects. So it will still perform the validation that we want, without it behaving in the same way as toBe, which expects that the two values being compared are literally the same object. So if we now go to the terminal and run our tests, we can see our test is passing. This is because we're no longer expecting the object returned by a function to be the same items object that we defined above. But with toEqual, we are still expecting it to have all the same properties and property values as it. So this demonstrates the different use cases for toBe and toEqual. If you want to do an equality check for primitive types such as strings, images, or Booleans, then use the toBe matcher, but if you want to do an equality check for anything else, then use toEqual. There are a few quirks to be aware of, though, when using toEqual, and this is why Jest also has a matcher called toStrictEqual. The toStrictEqual matcher performs the same validation as the toEqual matcher, except for the following things. Firstly, keys with undefined properties are checked with toStrictEqual, so these two objects would not match using the toStrictEqual matcher, but they would match using the toEqual matcher. Array sparseness is also checked with the toStrictEqual matcher, so an array with an empty value will not match an array with a value of undefined, but it would if you were using the toEqual matcher. And finally, it checks object types. With toStrictEqual, a class instance would not match a literal object, even if they have the same fields. Let's look at this final point back in our code editor. So if we were to add another expect statement to our test for the serializeBasketItemsToJson function, but use toStrictEqual instead of toEqual, and then save and go to the terminal to run our tests, we'll see the test is now failing. This is because we are comparing a class instance with a literal object, which will fail for toStrictEqual, as we discussed. So the toEqual statement is the one we're going to use, so let's remove the other two. When it comes to testing equality, toBe, toEqual, and toStrictEqual are the three matches you'll likely use. The exact one you choose will depend on what validation you actually want to perform. There are also many other matches available for testing equality that can be used for various use cases.

Using Pattern Matching
We're now going to explore using pattern matching in our unit tests. We now understand how we can test that values are equal to other values, but we don't always want to validate the entire return value of a function. It may be that a large object with lots and lots of properties is returned, or maybe we don't even know exactly what will be returned, or maybe we just don't care what the full return value actually is. The thing that links these scenarios, though, is that we want to confirm that somewhere in the response is a particular value. For these situations, we can use pattern matching. There are two common matchers for this. These are toContain and toMatch. So first, let's see how we can use the toContain matcher. The toContain matcher's primary usage is to validate that an item is in an array, which makes it ideal for testing the searchBasket function, which returns the items in the basket that match a search query. So let's create a describe block for the searchBasket function, and we're going to add a test that validates that only events matching the query are returned. So in order to test the searchBasket function, we're going to need to create some basket items, which requires us to create some events, which we'll assign to the items constant. That's all the setup we need for this test. So we're going to then call the searchBasket function and assign it to a constant. We are passing in the items array that we just created, and the search query we're going to use is THE. The searchBasket function converts everything to lowercase, so we would expect the first and third item to be contained in the response, as their event names both contain The. So let's add those expect statements using the toContain matcher. We simply pass into toContain the item that we want to confirm is in the array. We could also add another expect statement to validate that foundItems does not contain the second item by including not before the matcher. If we then save and go to the terminal and run our tests, we can see that the tests are passing. Another thing to note about the toContain matcher is that it can be used for other iterables such as strings, sets, node lists, and HTML collections. Now let's take a look at the generateReferralCode function. This function generates a code that users can use to refer their friends to the GloboTicket site. It takes in a userId and returns a string with the referral code. So let's start by adding a describe block and a test to validate the code contains the userId passed in to the function. Then our test would look something like this. We'll define a userId and then call the generateReferralCode function and pass in that userId and assign the result to a constant. We can then pass the referralCode into the expect function. Then we have a choice of matchers. We could either use toContain or toMatch in this situation. For both, we will just pass in the string that we expect to be contained within the result. Both of these matchers will validate that the passed‑in string is a substring of the value returned by our generateReferralCode function. So that's great if we wanted to just check that the generateReferralCode contains a specific string, but what if we want to validate more than just the userId? We can't simply use one of the equality matchers that we saw earlier, as the generated referral code will continually change, as they are all unique. This is because a random ID is included in the referral code. But they should all have the exact same format, which is what we can validate if we use toMatch. So the real benefit of using toMatch is that it also supports passing in a regular expression, which is a lot more powerful, as you validate that the value matches a more complex pattern. So let's add another test to validate that the referral code has the correct format. We'll then do exactly the same steps as the previous test, but for our expect statement, we're going to use the toMatch matcher and pass in a regular expression that will match the pattern produced. This regular expression will mean the test passes whatever numbers are generated for the ID. So if we go back to the terminal and run our tests, we can see that the tests are passing, so our regular expression was correct and we can now be confident that the generated referral codes will have the correct format. Regular expressions are, of course, incredibly configurable, so combining them with the toMatch matcher can be really powerful.

Testing Truthiness & Falsiness
Using Boolean values is pretty common in JavaScript. So let's now take a look at how we can assert that the value is truthy or falsy. So firstly, let's just confirm what we mean by falsy. In JavaScript, there are six falsy values. These are false, 0, an empty string, null, undefined, and NaN; everything else is truthy. Sometimes you may not care what a value is, and you actually just want to assert that the value is true or false in a Boolean context, and this is where the toBeTruthy and toBeFalsy matches are very handy, so let's see how we can use them. So here we are again, looking at the basket section of the GloboTicket site. The createBasketItem function contains an if statement where it checks if the item to be created is already in the basket. As part of this check, it calls the getBasketItem function. There is the not operator in front of it, so if getBasketItem evaluates to false, then the if statement is true, and a new basket item is returned, otherwise it returns null. The getBasketItem function does not return Boolean values, so we can't just use the toBe matcher to assert that it returns true or false. But anyway, we only actually care about whether the result evaluates to true or false. We don't care what the actual value returned is, as it's not used. What we want to assert is whether getBasketItem returns a truthy or a falsy value. So let's start by creating a describe block to keep our tests in. So for our first test, we'll validate that getBasketItem returns a truthy value when the event exists in the basket. We're again going to need to create some events, which we can then use to create some basket items, like so. Now we're going to call the getBasketItem function and assign it to a constant, just to keep the test neat. We're going to pass in the basket items that we created, as well as the first event. So now we can write our expect statements. We will pass the BasketItem constant into the expect function. The value of the BasketItem is the value returned by the getBasketItem function, and we passed in an event that should exist in the basket. So we want to validate that a truthy value is returned. So we will use the matcher, to BeTruthy. This test will now pass whatever is returned by getBasketItem, as long as it's not one of the six falsy values. Now let's add another test to validate that a falsy value is returned when an event does not exist in the basket. For this test, we could actually use the same data setup as for our first test. So let's move the events and items creation into it beforeEach hook. Now for this test case, we're again going to call getBasketItem and assign it to a constant, and we're going to pass in the same basket items that we created earlier; however, this time, we're going to create a new event, as we want to pass in an event that does not exist in the basket already. So now we can write our expect statement. Like last time, we will pass the BasketItem constant into the expect function, but this time, we will expect the value, toBeFalsy. So if we now save and open the terminal and run the tests, we can see that they are both passing. An important thing to appreciate, though, is that because there are those six possible falsy values, using toBeFalsy is not going to work if we want to actually assert that the result is an exact value. Our falsy test would still pass if getBasketItem returned undefined, for example, which is great for cases like this, where we just need to confirm that the value is falsy, but if we wanted to validate that the value returned was specifically null, then we couldn't use toBeFalsy. In this situation, we could make use of the basic toBe matcher that we are familiar with, or actually, the Jest API provides some more specific matches for some of the falsy values. So in this case, if we wanted to confirm it was null, we could use the to beBeNull matcher. And remember, we can use not with any matcher to reverse the condition. So for our first test, if we wanted to confirm that the value was not null, then we could write something like this. So to recap, if you just want to assert a value is truthy or falsy, then use the toBeTruthy or toBeFalsy matches, but if you want to assert that a specific falsy value is returned, then use the appropriate matcher, if there is one, such as toBeNull, otherwise, use the standard toBe matcher.

Testing Errors
Up until now, we focused mainly on testing happy‑path functionality. By this, we mean the ideal behavior of the application. But, of course, in various places in your application there will be error handling, and this is something we can also test with Jest. So here we are looking again at the Events section of the GloboTicket site. The createEvent function has some error handling so that it raises specific error messages if the data passed in is invalid. So how do we test that an application throws an error? Well, we're going to expect a function to throw an error, so you guessed it, we're going to use the toThrow matcher. Let's start by creating a describe block to keep our tests in. We'll start by writing tests for the first if statement. If the name is not a string or if it is longer than 200 characters, then it should throw an InvalidEventNameError. So let's write a test to validate that an error is raised when the name passed into createEvent is not a string. So there's no data setup required for this test, so our first step is going to be to add our expect statement. Now when it comes to testing errors, we need to write our expect statement slightly differently. We need to wrap the function call of our source code in a function, otherwise, the error will not be caught and the test will fail. So for testing errors, we need to write the expect statement like this. So you can see we wrapped the createEvent function call in a function and passed it into the expect function. For the first argument, which is the event name, we passed in a non‑string value, which is what we need for this test case. There's then actually four ways that we can use toThrow to test that a function throws an error when called. The first option is to simply use toThrow with no arguments, and this is going to validate that an error is thrown, which is great if that's as specific as we want to be, but it would mean that this test would pass if any error was thrown by this function. So what if we want to be more specific? Well, if we want to assert that an error is thrown and it contains a particular phrase, we can pass in either a regular expression or a string into the toThrow matcher like this. By passing in a regular expression, it will validate that the error message matches that pattern, and by passing in a string, it will validate that the error message contains that string. We might otherwise want to validate that the error thrown is the correct type, so in order to do that, we would pass in the type that we expect it to be, so in this case, we'll pass in InvalidEventNameError. The final option, if we want to be as specific as possible, we can actually pass in an error object with the exact error message that we expect. So we would create an instance of the InvalidEventNameError with the expected error message, and that's going to validate that both the error's type and the error's message are correct. So for our test we'll just make use of the final option. It would then be exactly the same process for writing a test for the other part of the if statement. For this test, though, we need to create a name that is longer than 200 characters, so we could do something like this. We can actually copy the expect statement from the previous test, but simply change the name that we are passing in so that we're passing in the long name we've just generated rather than the non‑string value that we passed in for the previous test. The expected behavior is then actually the same, so we can reuse our matcher, as we expect the function to throw the same error for this name as it did for the name passed in inside the last test. If we then save and go to the terminal and run our tests, we can see that they are both passing. So we have successfully validated that the correct errors are being raised. The process would be exactly the same for the other if statements in the createEvent function. Let's now wrap up this module by going over some of the key takeaways.

Key Takeaways
In this module, we began by looking at how we could test equality. Firstly using the toBe matcher, which uses Object.is to compare values. It is probably the simplest and most commonly used matcher. Then we looked at two other matchers that we can use to validate equality. Firstly toEqual and then we discussed when to use the matcher toStrictEqual instead. ToStrictEqual validates the objects have the same types, as well as structure, which is the key difference between toEqual and toStrictEqual. We then looked at two matchers that can be used for matching patterns. These are useful when you're not interested in validating the exact return value of a function, but want to ensure it contains a particular value or pattern. ToContain can be used for things like validating that an array contains a particular value, but it can also be used on any iterable, so it can be used to validate that a string contains a certain substring, for example. ToMatch is focused exclusively on pattern matching. It takes in a regular expression and it will validate that a value matches that regular expression. We then discussed truthiness and falsiness. In JavaScript there are six falsy values, which are false, zero, an empty string, null, undefined, and not a number. Everything else is truthy. We used toBeTruthy and toBeFalsy to confirm whether a value was truthy or not, but we are also aware that if we want to confirm a particular falsy value was returned, then there are more specific matchers available. For example, toBeUndefined will assert a value is undefined rather than just any of the falsy values. Finally, we saw how we could test that the correct error was thrown using the toThrow matcher, which accepts different arguments depending on how specific you want your validation to be. In the next module, we'll explore using mocks to write tests for more complex functions.

Using Mocks
Module Overview
We've now got a solid understanding of writing unit tests with Jest for relatively straightforward functions, but we're likely to encounter more complex functions that have dependencies. A mock allows us to test the links between code by erasing the actual implementation of a function, which helps keep our tests small and independent. Mocks are sometimes referred to as spies, because calls to the mock function are captured by it. The information collected from these calls includes information such as what arguments were passed. We can use this information to confirm our code is behaving as expected. We'll see how to do this in a lot more detail later in the module. They also allow us to perform test time configuration of return values for functions. This allows us to easily simulate particular behavior. They also help avoid tasks such as making network requests or writing to a file system that can be time consuming and make tests less reliable. So ultimately, mocks help us take shortcuts to just test exactly what we need to test, as simply and efficiently as possible, by removing or controlling any dependencies. With Jest, there are three ways to mock functions, either by creating a mock function using Jest's automock feature, or writing a manual mock. So in this module, we started by getting an understanding of what a mock is, and now we're going to have a go creating some simple mock functions. Then we'll look at how we can reduce the effort required with mocking by making use of Jest's automock feature, and then finally, we'll look at creating manual mocks to override a module dependency. So let's get started writing some simple mock functions.

Creating Simple Mock Functions
We're now going to explore using simple mock functions. We're going to start by writing a unit test for the getEvents function, which is used to allow users to search for events based on different attributes such as price. It takes in a list of events and a search predicate, which specifies the filtering to perform. It then returns a filtered list of events. We're going to write a test for this function, so let's first add a describe block, then we'll add a test to confirm it returns events with ticket prices less than 30. Now to keep our test isolated, we're going to define a mock function for the search predicate. The search predicate functions will be tested with their own unit tests, so we don't want to test them as part of the unit tests for the getEvents function. So, we will call jest.fn to create a mock function and specify an implementation, which is whether the ticketPrice is less than 30, and we will assign it to a constant to use later. Next we're going to create three events, all of which will have ticket prices less than 30. The ticket price is the third value being passed in for each event. So we've got 20, 10, and 29.99. Then we're going to create an events array with seven events in it. There are the three we just defined, as well as four new ones that have ticket prices above 30. We're then going to call the actual function we're trying to test, which is getEvents, and pass in the events array and the searchPredicateMock, and assign the result to a constant. We can now write our expect statement. And we're going to expect filterResults to equal an array with just the three events that we defined with prices below 30. And we could finish our test there and it would pass, but we wouldn't be getting the full benefit of using the mock. Mocks are also sometimes referred to as spies because, as well as allowing us to change values, they let us spy on calls to it. So for example, we can confirm that the searchPredicateMock is in fact called. So what's the matcher we can use when we expect something to have been called? You guessed it, it is toHaveBeenCalled. So we could add something like this. An alternative, though, to using simple matches is to use the mock property. With Jest, all mocks have a mock property, which can be a bit more configurable and powerful than the simple matches. The searchPredicateMock is a mock, so it has a mock property, which has a calls property, which is where the info around every call to the mock is stored. We can go further than this though and confirm that the mock was called for each of the seven events with the correct argument value. So let's add an expect statement, and we'll access the calls property again for the mock, but this time we want to get the first call that is made to the mock, like so, and then we're going to get the first argument that was passed in, which we can do, like so. So that is going to get the first argument passed into our mock when the mock is first called. We would therefore expect the value to be the first event, so we can add a matcher like this. We can then simply repeat this for the rest of the times it should be called. We would expect the mock to be called seven times, and each time, the first argument should be the corresponding event. So the second time the mock is called, we would expect it to have been called with the second event as the value of the first argument, and so on. If we now save and open the terminal and then run our test, we can see that it is passing. So we can be confident that the correct function calls are being made. Now let's look again at the promotions section of the GloboTicket site that we saw earlier in the course. So earlier in the course, we attempted to write unit tests for the generateReferralCode function, but because the function generates a random ID, we could only test that it was in the correct format using the toMatch matcher. However, we can get around this problem using a mock function to mock the Math.random function. Built‑in functions can be mocked in the same kind of way as ones you have created yourself. So we'll add a new test to confirm that the returned referralCode is correct. We will use the spyOn function on the jest object and pass in Math.random, like so. The spyOn function is essentially the same as using jest.fn, like we did earlier. It also creates a mock function, but as you can see, we are passing in an object and a method, which it will track calls to. We can then call mockReturnValue to specify our return value. This is a really powerful feature of mocks. There are also various other methods available to you so you can configure it to return a different response for the first time it is called compared to the second time, for example. Then we can add our expect statement. And because we mocked the return value of Math.random, we can now specify an exact value that the referralCode should be. Based on the logic of the function, if the generated ID is 76567, then the referralCode should be this. And just to confirm, we'll also add another expect statement to assert that our mock was called. If we now save and open the terminal and then run our test, we can see that it is passing. So we have successfully mocked the built‑in Math.random function. Jest also has some built‑in mock functions, which we can use. Let's move over and look at the site's filters functionality. There are functions available to allow events in different date ranges to be displayed. The challenge with writing unit tests for these functions is that filters are all relative to today's date, which will obviously change over time. So there are some tests already written for these functions, so let's just walk through them. The first test is confirming that the today filter returns true for an event that is today. We start by creating a couple of new dates and assigning them to some constants. Notice that they are both actually for the same date. We then use Jest's built‑in mock functionality to mock the system's time. So rather than it being the actual date when the tests are run, it will always have the value we defined in our now constant. We then use the eventDate constant to create an event for the specified date. And then finally, we have an expect statement where we assert that true is returned by the today function when we pass in our event. Thanks to our mock, this test will always pass no matter what today's date actually is. These fake timers can also be used to speed up tests by mocking the implementation of timer functions such as setTimeout. So Jest's mock functionality can be really powerful, and there's even more aspects to explore. In the next clip, we'll explore a Jest feature known as automock.

Automock
We now understand how to write simple mock functions and spies. Jest also has an automock feature that can take some of the work out of mocking module dependencies in our unit tests. Automock is toggled on using a simple property in your Jest's configuration. Toggling on automock tells Jest to automatically mock all imported modules in your tests. So with automock toggled on, we know that by default, all module dependencies, aside from built‑in node modules, will be mocked, and therefore we can use all the same mock properties in the same way, as if we had added mock functions like we did earlier in the module. The only downside is that whilst it removes the noise in our tests of adding mock functions, we need to explicitly unmock any functions that we don't want to be mocked, such as the function that we are testing. The downside is only slight, as it's actually quite a useful way to see how focused your unit test is. If you are having to add more than one unmock statement, then maybe you need to rethink the test that you are writing, as it may need splitting up to be a proper unit test. You should be wary, though, of toggling on automock for existing test suites, if they are quite large. You are changing Jest's default behavior, and you might find that it causes a lot of tests to fail, if things that weren't explicitly mocked previously are now being mocked. So it can be introduced to existing test suites, but like with a lot of things, ideally, it should be introduced from the start. Now that we understand what automock is, let's head over to our code editor to see how we can use it. Here we are looking at the getPastPurchases function, which gets a user's past purchases to display in their account. There is currently a test written for this function, but there's a problem. The getPastPurchases function calls another function called getPurchaseHistory, and if we take a look at that function, we can see that it makes an HTTP request to retrieve some data. So this is something that is going to add latency and flakiness to any tests for the getPastPurchases function, as well as requiring us to have the endpoint available that it is retrieving the data from. The purchaseHistory dependency is therefore a great candidate for a mock. Remember, a mock allows us to isolate our tests. It removes the dependency on the actual getPurchaseHistory implementation and allows us to specify the values it returns. So normally, to mock a module dependency, we would just use jest.mock and pass in the path to the dependency like so. Jest.mock must be called in the same scope as the corresponding require or import statement. So this require statement is in the root of the file, so that's where we need to call jest.mock. However, the ordering doesn't matter. Jest will automatically hoist the mock statements to the top of the file so that the mock implementation is still used, even if we have a require statement above where we call jest.mock, but in this case, rather than having to call jest.mock for every dependency, we're going to be using automock. Automock can be toggled on via your Jest configuration. So we're going to add a JSON file for our configuration, and into it, we're going to add an object with a property, automock, with a value of true. It defaults to false, so if you don't want to use automock, then you can just leave it out of your configuration. Now remember, automock is going to mock every dependency, except for built‑in node modules, but we don't want it to mock the function that we are actually trying to test. So we need to use jest.unmock so that the getPastPurchases function that we are trying to test is not mocked. If we now save and go to the terminal and run this test, we will see that it is failing. This is because the getPurchaseHistory function is now being mocked, but no mock implementation has been defined, so we're not getting a value returned. This is something that can be fixed using a manual mock, which we'll explore in the next clip.

Creating Manual Mocks
We're now going to look at using manual mocks to define mock implementations for module dependencies in our tests. So in order to create a manual mock, we add a mock directory in the same directory as the file we want to mock. And then we're going to add a file to it with the same name, which in this case is purchaseHistory.js. Then inside our new mock file, we're going to start by adding a line to create the mock and assign it to the constant. We're going to add a constant, purchaseHistory, and we're going to call the createMockFromModule function on the Jest object. And we're going to pass in the path to the file that contains the actual module implementation. And we're going to export the module like we normally would. So now we have created a mock for the module, we need to mock the getPurchaseHistory function. So we're going to add a function called __getPurchaseHistory. It doesn't have to be that exact name; the underscores are just used as a convention, and then within the function, this is where we want to define the mock implementation. So we want to return some static data so that we know in our test what data to expect. So in the actual implementation, it sends a HTTP request and returns the response. So we need to make sure the value returned by our mock is in the same format. So for brevity, here is the format of what is normally returned. So we just then need to return the response object. The final part is to then assign this new implementation to the mock we created at the start. So we'll add the following statement so that when the module mock is called, it will use the implementation we have defined above. We would repeat this for any other functions in the file that we wanted to mock, but we don't need to for now, so that's it. Our manual mock is now ready to use. Now remember, in the previous clip, we toggled on automock, and automock should use any manual mock implementations that we define. So if we now open the terminal and run the test again, we can see it is now passing, as the getPurchaseHistory function has been mocked successfully and is using the implementation that we defined. So that's great, but what if we wanted to add another test for the getPastPurchases function, to confirm that an error is thrown when the readyState is not 4? With our manual mock, we specify that the response should have a readyState of 4, so how can we test the code in the else statement of the getPastPurchases function? Well, luckily, we can override the manual mock using the spyOn function that we used earlier. We can combine spyOn and mockReturnValue to define a different return value for the getPurchaseHistory function. GetPurchaseHistory will now return this value. So we can add an expect statement to assert that an error is thrown with the correct message. Remember though, as we saw earlier in the course, we have to wrap our function call within a function when testing that it throws an error. So if we now open the terminal and run the tests again, we can see that they are both passing, which means we are successfully returning different values from the getPurchaseHistory function between the tests. So this shows how great Jest's mock functionality is. It allows us a lot of control and makes it as easy as possible to write independent and reliable tests. Let's now wrap up this module by going over some of the key takeaways.

Key Takeaways
In this module, we gained the ability to use mocks to help us write unit tests for more complex functions. Firstly, we discussed what mocks are. They allow us to erase the implementation of a function, and instead specify return values so that we can test the links between our code whilst avoiding actually performing slow and flaky tasks as part of our tests. Then we got started writing some mock functions, so that our unit tests avoided carrying out network requests. Mocks are also sometimes referred to as spies, as we saw how to spy on the functions to confirm they were called correctly. Then we discussed using Jest's automock functionality. It is not enabled by default, but can be toggled on via a project's Jest config file. When toggled on, Jest will automatically mock all imported modules, except for built‑in node modules. This can be a massive time saver as it is all automatic, as the name implies; however, it can be difficult to introduce retrospectively to a large code base. Finally, we looked at manual mocks, which are used to mock module dependencies. When a mock function is called for a module, it will use the manual mock implementation, if there is one; they can also be used in combination with automock. Manual mocks must be kept in separate mock directories, next to the module that they relate to. In the next module, we'll learn how we can write unit tests with Jest for asynchronous code.

Testing Asynchronous Code
Module Overview
So far in this course, we've written tests for functions that are synchronous. So are there any differences when it comes to writing tests for asynchronous code? Let's start exploring that by firstly summarizing what we mean by asynchronous code. Asynchronous code continues to become more and more common within the JavaScript community, both for front end and back end applications. This makes it highly likely that you will need to write tests for asynchronous functions. We're not going to dive into this in much detail, but the reason behind its increased usage is that it can reduce the execution times of tasks, because it stops threads being blocked and can allow processes to run in parallel. There are various kinds of asynchronous code. It can be used in a variety of situations. For example, it could be used to allow UI to retrieve data from an API after a web page has loaded. Also, certain frameworks, such as Node.js, are built upon asynchronous code, so callbacks are quite a fundamental part of Node.js. In this module, we'll be discussing two types of asynchronous code, promises and callbacks. We'll start by looking at promises. We'll explore writing tests for asynchronous functions that make use of promises and a few of the different ways that we can structure our tests. Then we'll look at how we can write tests for asynchronous functions that make use of callbacks. So by the end of this module, you should be confident writing unit tests for any kind of function, whether its synchronous or asynchronous. So let's get started writing unit tests using promises.

Using Promises
We're now going to explore writing tests for asynchronous functions that make use of promises. We're going to write some tests for the createAccount function. So let's start by creating a describe block for our tests. We'll start by testing that createAccount returns the correct data when an account is created successfully. Now the createAccount function calls two other functions, so we are going to mock them using jest.spyOn. So first, we're going to mock the userExists function, and notice that it is an asynchronous function, so we will use the mockResolvedValue method and set it to false. Then we're going to mock the createUserId function and have it return 2. Then in the actual test, first, we're going to call the createAccount function and pass in an email address. It doesn't really matter whether the email address has already been used, as we have mocked the return value of the userExists function. The createAccount function returns a promise. This means we can use the then function. It is within this that we will need to add our expect statement. Based on the logic of the createAccount function, we should get an object in the following format. The userId property value should be 2, as we have specified 2 as the mockReturnValue, and the username should be the email address that we passed in. One thing to be cautious of, though, with asynchronous functions is making sure that you are always telling Jest to wait for the function to complete. So the final part to remember is to return the promise. So we need to add return before our function call, otherwise Jest may complete the test without actually running our assertions. This can lead to false positives where you think that a test is passing, but it's actually just not running your assertions, so it would never fail. A way of making sure that you never get caught out with this is to add an extra expect statement to tests for asynchronous functions. Adding expect.HasAssertions will assert that at least one assertion is run. This way, if Jest is finishing the test before running the assertions, that assertion will fail the Jest test and help you avoid false positives. You can also use expect.assertions to specify an exact number of assertions that you expect to be run. Another option we have for writing tests for asynchronous functions is to use the async/await keywords. Again, it's something you may well have used in your main source code. So let's add another test that does the same as the previous test, but uses async and await. So we'll add a new test called, "Returns user data when account created successfully," but we'll mock this one as async/await, just to differentiate it. So the first thing we'll do is add the async keyword in front of the function we pass into the test. We're also again going to add our expect.HasAssertions statement to ensure our assertions are being called. We can then call the createAccount function with the same email address we used above, and we'll assign the result to the userAccount constant. Crucially, though, what we need to do is add the await keyword in front of the createAccount function. Then we can actually copy the expect statement from our first test and paste it in for this one, as it has the same expected behavior. And that's it. Hopefully, you can see there's not really anything special about using async functions with Jest. The async/await keywords are used exactly as you would use them in your source code. Finally, we can use .resolves or .rejects to write tests for the createAccount function. First, let's add the same test as above, but we'll use .resolves instead. Again, we're going to add our expect.HasAssertions statement to ensure our assertions are being called, and then add an expect function into which we will pass our function call. Then we will add .resolves, and then we can just copy the matcher we used above. So those three tests will all test the same thing; they are just written in different ways. But what if we wanted to test what happens when a username is passed in that is already in use? So we can use .rejects to test what happens when the promise is rejected. So lets add a test to confirm that an error message is returned when a user already exists. Again, we're going to add our expect.HasAssertions statement to ensure our assertions are being called. We now need to override our mockReturnValue. We need the mockReturnValue to be true for userExists so that we can test what happens when a user already exists. So we're going to copy the spyOn function call from the beforeEach hook, and paste it into our test, but change the mockReturnValue to be true. And then we'll add an expect statement. We're going to add return and then add an expect function, into which we will pass our function call. This time, though, userExists has been mocked to be true, which will cause the promise to be rejected based on the logic in the createAccount function. So we will add .rejects and use toStrictEqual with an expected value of User already exists. The final option to note is that we can actually combine async/await with the .resolves or .rejects. So we could rewrite the final test like this. So there are plenty of options to choose from, that's for sure, so use whichever works for you and your code base. What is important, though, is that we are always returning or awaiting the asynchronous function. And then finally, just to confirm that all the methods are valid, we will save and go to the terminal and run our tests, and we will see that all of our tests are passing. So for each test, Jest is waiting for the asynchronous function to complete, and our assertions are being run successfully. Now that we understand how to write tests using promises, let's look at writing tests using callbacks.

Using Callbacks
Asynchronous JavaScript functions may use callbacks rather than promises, so let's look at how we can write unit tests for functions like that. Here, we are looking at the getExchangeRate function. This is used to convert prices, which are in British pounds by default, into various other currencies such as US dollars. If we look at this function, we can see, it expects a callback to be passed in. So let's look how we could write a test for it. We'll start by adding a describe block for the getExchangeRate function, and we'll add a test to confirm that it returns the correct exchange rate for US dollars. When we pass in a currency code, it calls the callExchangeProvider function to get the latest exchange rate, and then the two currencies and the exchange rate should be passed into the callback function. So in our test, firstly, we need to mock the callExchangeProvider function, as the actual implementation will require network calls, and the value returned will continuously vary. So we're going to add a spyOn function and mock the callExchangeProvider function so that it returns 1.21. Next, we'll add a simple callback function, which we will come back to in a moment. Outside of it, we'll call the getExchangeRate function and pass in USD to get the exchange rate for US dollars. We will also pass in the callback function we defined above. We're then ready to add our expect statements. We need to add these inside the callback function. So we'll get the response value passed into the callback and add some assertions. Firstly, based on the logic of the getExchangeRate function, we will expect response.originalCurrency to be the string, GBP. We will also expect that response.newCurrency will be the string, USD. And finally, we will expect that response.exchangeRate will be close to 1.21. Remember, we mocked the value returned by callExchangeRateProvider to be 1.21. We also have to use the toBeCloseTo matcher rather than say toEqual, because of the tiny rounding discrepancies that occur when using floats in JavaScript. So you might think that we are done, but there are a couple of extra things we need to do when using callbacks in our tests. Firstly, we need to use an alternative version of the test function. We've always been putting the test in a function with an empty argument, but instead, we can use a single argument, done, and update our test, like so. Now when we run the test, Jest knows to wait until the done callback is called before finishing the test. But we're not done yet. If done is never called, then the test will fail with a timeout error, which is what we would expect, so that's fine. However, if the expect statement fails, it would throw an error, so done would also not be called in this situation. This would mean that a timeout error would be raised, rather than the normal Jest assertion error, which would make debugging the failure more difficult. So if we want to see the value that was received, we need to wrap the expect statement in a try block and pass the error to the done callback, like so. So if we now save and open the terminal and run our test, we can see that it is passing. So Jest is correctly waiting for our function to finish and running the appropriate assertions. Let's now wrap up this module by going over some of the key takeaways.

Key Takeaways
In this module, we gained the ability to write unit tests for asynchronous code. Firstly, we discussed using promises. If a promise is returned from a test, then Jest will wait for the promise to resolve, or will fail the test if it is rejected. It is vital, though, that the promise is returned or awaited, otherwise the test will complete before the promise is resolved or rejected. As well as returning the promise, you can also make use of async/await keywords with or without the .resolves or .rejects to create tests for asynchronous code that uses promises. We then looked at how we could write unit tests for asynchronous code using callbacks rather than promises. In a similar way to promises, it is essential to tell Jest to wait for the code to complete. This is achieved using the done callback, which stops Jest from completing the test before the callback has completed. It's also important to use try/catch blocks with your expect statements. Without doing so, if an assertion fails, then Jest will raise a timeout error that doesn't include the value that was received by the expect statement, which makes debugging the failure difficult. In the next module, we'll look at measuring the code coverage of our unit tests with Jest.

Measuring Code Coverage
Module Overview
Code coverage is a great metric to assess the health of a project. In this module, we'll be focusing on how we can collect it, visualize the results, and enforce minimum coverage standards. So, what do we mean by code coverage? Well, put simply, it is a measure of how much of our code is actually executed by our tests. It may also be referred to as test coverage. It's not perfect, of course; you could have 100% code coverage and yet the UI for your project provides a terrible user experience, for example. But due to the benefits of unit tests that we discussed earlier in the course, generally, the more the better. So code coverage is a good way of giving insight into the quality of a code base. Under the hood, we'll be using the default coverage provider for Jest, which is Babel. The use of different providers is beyond the scope of this course, but essentially, a coverage provider facilitates keeping account of what lines of code have been executed during our test run. Jest provides four main metrics for code coverage, which are: what percentage of statements, branches, functions, and lines have been executed by tests. Hopefully, measuring the number of lines, statements, and functions covered are fairly self‑explanatory, but let's just clarify what we mean by branch coverage. Branches are created by control structures. So a simple if/else statement would have two branches, one where the condition is true, and one where the condition is false. So if we only had one unit test for the calculatePrice function, and that test called calculatePrice with isSaleItem being true, then this branch would be executed, but the else branch would not be, so we would have achieved 50% branch coverage. So in this module, we'll start by looking at how to collect code coverage statistics for a project. Then we'll see ways in which we can visualize that data, before finally configuring minimum coverage thresholds, so that Jest flags up went code coverage drops below specified limits. So now that we understand what they are, let's look at how we can collect coverage statistics with Jest.

Collecting Code Coverage Statistics
When it comes to collecting code coverage statistics, like with most things with Jest, it's pretty straightforward. When running Jest from the command line, we can just add the coverage or collect coverage argument. But instead, we'll be adding it to our Jest configuration file, so that we don't need to add that argument each time. So we're going to add a collect coverage property and set the value to true. We also need to specify what files to collect coverage for. We are going to specify a pattern that will match all of the JavaScript files in our JavaScript directory. If we didn't specify this value, Jest would only collect coverage for source files referenced by our tests. So we could potentially be missing out lots of files. Then if we save, and open the terminal, and run our tests, we will see that Jest has run our tests as it has done before. But once it's done, we're presented with this table output in the terminal. You can see on the left‑hand side, we have names of files. And then we have columns displaying the percentage coverage based on the various entities. As we discussed earlier, they are statements, branches, functions, and lines. The final column displays the lines that are not covered. That metric is useful if you want to aim for 100% coverage. But as it's not a percentage, it makes comparing the health of a project over time more difficult, as the total number of lines will change. An alternative option, when collecting coverage statistics, is to use the onlyChanged argument that we saw earlier in the course. This can be combined with the coverage argument to measure the coverage stats just for files that have been changed. In the next clip, we'll see another way that we can visualize our code coverage, and then, how we can try to enforce minimum test coverage standards.

Code Coverage Results
In the previous clip, we saw the code coverage results outputted to the terminal. But Jest also actually outputs the results into various file formats. When we ran our tests in the previous clip, a coverage directory was created. The exact contents of this will vary depending on what coverage provider is being used. But here, we have an XML file, as well as a JSON file, containing all of the coverage statistics. More interestingly though, there is a lcov‑report directory and some HTML files. If we open the index.html in our browser, we will see this really nice way of visualizing the coverage statistics. We can see them for all of the different directories, and it's nicely formatted with options to filter and sort the table. We can also click into a directory and then into a file. Here we can see exactly how many times each statement was called and what lines are not covered, so it's a really nice way of digging into the details. So we now understand how we can measure and view our code coverage. But particularly when working as part of a team, you may want to enforce certain development standards so that code quality is maintained. So it just allows you to configure thresholds to ensure the expected level of code coverage is maintained. So back in our code editor, this can be done using the coverage threshold option in the Jest configuration file. Thresholds can be specified globally or for a particular directory or file path. Generally though, you should only add global thresholds, just to keep things simple. Different thresholds for particular directories or files can be useful when retrospectively adding test to a code base like we have been doing in this course. For example, you might want to enforce high coverage for certain areas of a project, but you're still working on adding tests for other areas and you don't want Jest to keep failing every time it runs before you've had chance to cover every area of the project with tests. Firstly, we're going to add the coverageThreshold object, and then within that, we're going to create a global object, which will have four properties, statements, branches, functions, and lines. So if you want to specify different minimum levels of coverage for each, then you can do, but again, by default, it's easier just to keep things simple and set them all to be the same. For now, we're going to specify 50 for all of them, which means Jest will flag up if less than 50% of statements, branches, functions, or lines in our source files are executed by tests. So if we save and open the terminal, and run our tests, we should see that Jest is printing a message saying that the branch coverage is below 50%. So we were a bit optimistic with our thresholds. If we had just added some new source code without adding new tests, which lowered the test coverage, then we would need to add some tests until the threshold was reached. But in this case, as we're retrospectively adding tests, let's adjust the branch threshold to be 30%. This threshold can then be increased over time as we add more and more tests. We can also specify a negative number. If for lines we specify a negative number, such as ‑10, this would mean that Jest will flag up if there are more than 10 lines that are not covered by our tests. So with a negative number, it is no longer using a percentage, it is a simple count. If we then run the tests again, then we can see Jest is flagged up, that there are more than 10 lines that are not covered by tests. You could then actually take this further and make the running of Jest with coverage thresholds, an automatic process, by making use of something like a Git pre‑commit hook. That way, every time someone went to commit some changes, they could be prevented from doing so if the code coverage was below the specified thresholds. That's beyond the scope of this course though, but more info around pre‑commit hooks can be found at the link shown. Now that we understand how to configure and view code coverage with Jest, let's wrap up the course by going over the key takeaways.

Course Summary
So, in this module, we started by discussing how code coverage was a measure of the amount of source code executed by tests. There are different ways to measure it. The percentage coverage of statements, branches, functions, and lines, as well as the individual lines not covered, are all measured by Jest. We then saw how Jest makes it easy to collect code coverage statistics. Coverage statistics can be outputted in a variety of formats, depending on how you want to visualize them. Finally, we explored configuring code coverage thresholds. These can be used to ensure the desired level of test coverage is maintained when working on a project. We began this course by getting an understanding of what the purpose of writing unit tests was, and then saw how we could get set up to write unit tests by adding Jest to a project using NPM. We then got writing some basic tests and learned about using describe blocks, as well as hooks, to structure our test files, as well as looking at some useful Jest CLI commands. Jest has a variety of options to support running specific subsets of tests. We then explored using some common matches and learned how to select an appropriate matcher for a variety of different functions. Whilst we covered the most commonly used matchers, there are many more matches available. What additional matchers are available, and how to use them, can be found in the Jest documentation. We then learned how to use mocks to help us test more complex functions by mocking dependencies. We saw how we can use mock functions to return specific values or just spy on function calls, as well as how to use auto mock and create manual mocks for module dependencies in our tests. Then we learned how to write tests for asynchronous functions that make use of promises and callbacks. A lot of JavaScript is asynchronous by nature, so this is something that you will likely come across fairly regularly. The key thing to remember is that you must return or await the promise or use the done callback to ensure Jest waits until the tests have fully completed. And then finally, in this module, we looked at code coverage, as we just discussed. So all that's left to say is that my name is Gabriel McNeilly, and I hope you've enjoyed this course, JavaScript Unit Testing with Jest, and have found it useful in improving the quality of your development work. If so, adding a course rating would be much appreciated. Thanks for watching.